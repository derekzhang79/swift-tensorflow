/*
 * DO NOT EDIT.
 *
 * Generated by the protocol buffer compiler.
 * Source: tensorflow/tools/tfprof/tfprof_log.proto
 *
 */

import Foundation
import SwiftProtobuf


struct Tensorflow_Tfprof_OpLogEntry: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_Tfprof_OpLogEntry"}
  public var protoMessageName: String {return "OpLogEntry"}
  public var protoPackageName: String {return "tensorflow.tfprof"}
  public var jsonFieldNames: [String: Int] {return [
    "name": 1,
    "floatOps": 2,
    "types": 3,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "name": 1,
    "float_ops": 2,
    "types": 3,
  ]}

  var unknown = ProtobufUnknownStorage()

  ///   op name.
  private var _name: String? = nil
  public var name: String {
    get {return _name ?? ""}
    set {_name = newValue}
  }
  public var hasName: Bool {
    return _name != nil
  }
  public mutating func clearName() {
    return _name = nil
  }

  ///   float_ops is filled by tfprof Python API when called. It requires the
  ///   op has RegisterStatistics defined. Currently, Conv2D, MatMul, etc, are
  ///   implemented.
  private var _floatOps: Int64? = nil
  public var floatOps: Int64 {
    get {return _floatOps ?? 0}
    set {_floatOps = newValue}
  }
  public var hasFloatOps: Bool {
    return _floatOps != nil
  }
  public mutating func clearFloatOps() {
    return _floatOps = nil
  }

  ///   User can define extra op type information for an op. This allows the user
  ///   to select a group of ops precisely using op_type as a key.
  public var types: [String] = []

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &_name)
    case 2: handled = try setter.decodeSingularField(fieldType: ProtobufInt64.self, value: &_floatOps)
    case 3: handled = try setter.decodeRepeatedField(fieldType: ProtobufString.self, value: &types)
    default:
      handled = false
    }
    if handled {
        return true
    } else {
        return try unknown.decodeField(setter: &setter)
    }
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if let v = _name {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: v, protoFieldNumber: 1, protoFieldName: "name", jsonFieldName: "name", swiftFieldName: "name")
    }
    if let v = _floatOps {
      try visitor.visitSingularField(fieldType: ProtobufInt64.self, value: v, protoFieldNumber: 2, protoFieldName: "float_ops", jsonFieldName: "floatOps", swiftFieldName: "floatOps")
    }
    if !types.isEmpty {
      try visitor.visitRepeatedField(fieldType: ProtobufString.self, value: types, protoFieldNumber: 3, protoFieldName: "types", jsonFieldName: "types", swiftFieldName: "types")
    }
    unknown.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_Tfprof_OpLogEntry) -> Bool {
    if (name != other.name) {return false}
    if (floatOps != other.floatOps) {return false}
    if types != other.types {return false}
    if unknown != other.unknown {return false}
    return true
  }
}

struct Tensorflow_Tfprof_OpLog: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_Tfprof_OpLog"}
  public var protoMessageName: String {return "OpLog"}
  public var protoPackageName: String {return "tensorflow.tfprof"}
  public var jsonFieldNames: [String: Int] {return [
    "logEntries": 1,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "log_entries": 1,
  ]}

  var unknown = ProtobufUnknownStorage()

  public var logEntries: [Tensorflow_Tfprof_OpLogEntry] = []

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeRepeatedMessageField(fieldType: Tensorflow_Tfprof_OpLogEntry.self, value: &logEntries)
    default:
      handled = false
    }
    if handled {
        return true
    } else {
        return try unknown.decodeField(setter: &setter)
    }
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if !logEntries.isEmpty {
      try visitor.visitRepeatedMessageField(value: logEntries, protoFieldNumber: 1, protoFieldName: "log_entries", jsonFieldName: "logEntries", swiftFieldName: "logEntries")
    }
    unknown.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_Tfprof_OpLog) -> Bool {
    if logEntries != other.logEntries {return false}
    if unknown != other.unknown {return false}
    return true
  }
}
