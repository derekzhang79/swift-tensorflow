/*
 * DO NOT EDIT.
 *
 * Generated by the protocol buffer compiler.
 * Source: tensorflow/core/protobuf/control_flow.proto
 *
 */

import Foundation
import SwiftProtobuf


//  Control flow context related protocol buffers.

///   Protocol buffer representing the values in ControlFlowContext.
struct Tensorflow_ValuesDef: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_ValuesDef"}
  public var protoMessageName: String {return "ValuesDef"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "values": 1,
    "externalValues": 2,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "values": 1,
    "external_values": 2,
  ]}

  ///   Value names that have been seen in this context.
  public var values: [String] = []

  ///   Value names referenced by but external to this context.
  public var externalValues: Dictionary<String,String> = [:]

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeRepeatedField(fieldType: ProtobufString.self, value: &values)
    case 2: handled = try setter.decodeMapField(fieldType: ProtobufMap<ProtobufString,ProtobufString>.self, value: &externalValues)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if !values.isEmpty {
      try visitor.visitRepeatedField(fieldType: ProtobufString.self, value: values, protoFieldNumber: 1, protoFieldName: "values", jsonFieldName: "values", swiftFieldName: "values")
    }
    if !externalValues.isEmpty {
      try visitor.visitMapField(fieldType: ProtobufMap<ProtobufString,ProtobufString>.self, value: externalValues, protoFieldNumber: 2, protoFieldName: "external_values", jsonFieldName: "externalValues", swiftFieldName: "externalValues")
    }
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_ValuesDef) -> Bool {
    if values != other.values {return false}
    if externalValues != other.externalValues {return false}
    return true
  }
}

///   Protocol buffer representing a CondContext object.
struct Tensorflow_CondContextDef: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_CondContextDef"}
  public var protoMessageName: String {return "CondContextDef"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "contextName": 1,
    "predName": 2,
    "pivotName": 3,
    "branch": 4,
    "valuesDef": 5,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "context_name": 1,
    "pred_name": 2,
    "pivot_name": 3,
    "branch": 4,
    "values_def": 5,
  ]}

  private class _StorageClass {
    typealias ProtobufExtendedMessage = Tensorflow_CondContextDef
    var _contextName: String = ""
    var _predName: String = ""
    var _pivotName: String = ""
    var _branch: Int32 = 0
    var _valuesDef: Tensorflow_ValuesDef? = nil

    init() {}

    func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &_contextName)
      case 2: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &_predName)
      case 3: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &_pivotName)
      case 4: handled = try setter.decodeSingularField(fieldType: ProtobufInt32.self, value: &_branch)
      case 5: handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_ValuesDef.self, value: &_valuesDef)
      default:
        handled = false
      }
      return handled
    }

    func traverse(visitor: inout ProtobufVisitor) throws {
      if _contextName != "" {
        try visitor.visitSingularField(fieldType: ProtobufString.self, value: _contextName, protoFieldNumber: 1, protoFieldName: "context_name", jsonFieldName: "contextName", swiftFieldName: "contextName")
      }
      if _predName != "" {
        try visitor.visitSingularField(fieldType: ProtobufString.self, value: _predName, protoFieldNumber: 2, protoFieldName: "pred_name", jsonFieldName: "predName", swiftFieldName: "predName")
      }
      if _pivotName != "" {
        try visitor.visitSingularField(fieldType: ProtobufString.self, value: _pivotName, protoFieldNumber: 3, protoFieldName: "pivot_name", jsonFieldName: "pivotName", swiftFieldName: "pivotName")
      }
      if _branch != 0 {
        try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: _branch, protoFieldNumber: 4, protoFieldName: "branch", jsonFieldName: "branch", swiftFieldName: "branch")
      }
      if let v = _valuesDef {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 5, protoFieldName: "values_def", jsonFieldName: "valuesDef", swiftFieldName: "valuesDef")
      }
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _contextName != other._contextName {return false}
      if _predName != other._predName {return false}
      if _pivotName != other._pivotName {return false}
      if _branch != other._branch {return false}
      if _valuesDef != other._valuesDef {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._contextName = _contextName
      clone._predName = _predName
      clone._pivotName = _pivotName
      clone._branch = _branch
      clone._valuesDef = _valuesDef
      return clone
    }
  }

  private var _storage = _StorageClass()

  ///   Name of the context.
  public var contextName: String {
    get {return _storage._contextName}
    set {_uniqueStorage()._contextName = newValue}
  }

  ///   Name of the pred tensor.
  public var predName: String {
    get {return _storage._predName}
    set {_uniqueStorage()._predName = newValue}
  }

  ///   Name of the pivot tensor.
  public var pivotName: String {
    get {return _storage._pivotName}
    set {_uniqueStorage()._pivotName = newValue}
  }

  ///   Branch prediction. 0 or 1.
  public var branch: Int32 {
    get {return _storage._branch}
    set {_uniqueStorage()._branch = newValue}
  }

  ///   Values and external values in control flow context.
  public var valuesDef: Tensorflow_ValuesDef {
    get {return _storage._valuesDef ?? Tensorflow_ValuesDef()}
    set {_uniqueStorage()._valuesDef = newValue}
  }
  public var hasValuesDef: Bool {
    return _storage._valuesDef != nil
  }
  public mutating func clearValuesDef() {
    return _storage._valuesDef = nil
  }

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    try _storage.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_CondContextDef) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

///   Protocol buffer representing a WhileContext object.
struct Tensorflow_WhileContextDef: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_WhileContextDef"}
  public var protoMessageName: String {return "WhileContextDef"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "contextName": 1,
    "parallelIterations": 2,
    "backProp": 3,
    "swapMemory": 4,
    "pivotName": 5,
    "pivotForPredName": 6,
    "pivotForBodyName": 7,
    "loopExitNames": 8,
    "valuesDef": 9,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "context_name": 1,
    "parallel_iterations": 2,
    "back_prop": 3,
    "swap_memory": 4,
    "pivot_name": 5,
    "pivot_for_pred_name": 6,
    "pivot_for_body_name": 7,
    "loop_exit_names": 8,
    "values_def": 9,
  ]}

  private class _StorageClass {
    typealias ProtobufExtendedMessage = Tensorflow_WhileContextDef
    var _contextName: String = ""
    var _parallelIterations: Int32 = 0
    var _backProp: Bool = false
    var _swapMemory: Bool = false
    var _pivotName: String = ""
    var _pivotForPredName: String = ""
    var _pivotForBodyName: String = ""
    var _loopExitNames: [String] = []
    var _valuesDef: Tensorflow_ValuesDef? = nil

    init() {}

    func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &_contextName)
      case 2: handled = try setter.decodeSingularField(fieldType: ProtobufInt32.self, value: &_parallelIterations)
      case 3: handled = try setter.decodeSingularField(fieldType: ProtobufBool.self, value: &_backProp)
      case 4: handled = try setter.decodeSingularField(fieldType: ProtobufBool.self, value: &_swapMemory)
      case 5: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &_pivotName)
      case 6: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &_pivotForPredName)
      case 7: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &_pivotForBodyName)
      case 8: handled = try setter.decodeRepeatedField(fieldType: ProtobufString.self, value: &_loopExitNames)
      case 9: handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_ValuesDef.self, value: &_valuesDef)
      default:
        handled = false
      }
      return handled
    }

    func traverse(visitor: inout ProtobufVisitor) throws {
      if _contextName != "" {
        try visitor.visitSingularField(fieldType: ProtobufString.self, value: _contextName, protoFieldNumber: 1, protoFieldName: "context_name", jsonFieldName: "contextName", swiftFieldName: "contextName")
      }
      if _parallelIterations != 0 {
        try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: _parallelIterations, protoFieldNumber: 2, protoFieldName: "parallel_iterations", jsonFieldName: "parallelIterations", swiftFieldName: "parallelIterations")
      }
      if _backProp != false {
        try visitor.visitSingularField(fieldType: ProtobufBool.self, value: _backProp, protoFieldNumber: 3, protoFieldName: "back_prop", jsonFieldName: "backProp", swiftFieldName: "backProp")
      }
      if _swapMemory != false {
        try visitor.visitSingularField(fieldType: ProtobufBool.self, value: _swapMemory, protoFieldNumber: 4, protoFieldName: "swap_memory", jsonFieldName: "swapMemory", swiftFieldName: "swapMemory")
      }
      if _pivotName != "" {
        try visitor.visitSingularField(fieldType: ProtobufString.self, value: _pivotName, protoFieldNumber: 5, protoFieldName: "pivot_name", jsonFieldName: "pivotName", swiftFieldName: "pivotName")
      }
      if _pivotForPredName != "" {
        try visitor.visitSingularField(fieldType: ProtobufString.self, value: _pivotForPredName, protoFieldNumber: 6, protoFieldName: "pivot_for_pred_name", jsonFieldName: "pivotForPredName", swiftFieldName: "pivotForPredName")
      }
      if _pivotForBodyName != "" {
        try visitor.visitSingularField(fieldType: ProtobufString.self, value: _pivotForBodyName, protoFieldNumber: 7, protoFieldName: "pivot_for_body_name", jsonFieldName: "pivotForBodyName", swiftFieldName: "pivotForBodyName")
      }
      if !_loopExitNames.isEmpty {
        try visitor.visitRepeatedField(fieldType: ProtobufString.self, value: _loopExitNames, protoFieldNumber: 8, protoFieldName: "loop_exit_names", jsonFieldName: "loopExitNames", swiftFieldName: "loopExitNames")
      }
      if let v = _valuesDef {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 9, protoFieldName: "values_def", jsonFieldName: "valuesDef", swiftFieldName: "valuesDef")
      }
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _contextName != other._contextName {return false}
      if _parallelIterations != other._parallelIterations {return false}
      if _backProp != other._backProp {return false}
      if _swapMemory != other._swapMemory {return false}
      if _pivotName != other._pivotName {return false}
      if _pivotForPredName != other._pivotForPredName {return false}
      if _pivotForBodyName != other._pivotForBodyName {return false}
      if _loopExitNames != other._loopExitNames {return false}
      if _valuesDef != other._valuesDef {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._contextName = _contextName
      clone._parallelIterations = _parallelIterations
      clone._backProp = _backProp
      clone._swapMemory = _swapMemory
      clone._pivotName = _pivotName
      clone._pivotForPredName = _pivotForPredName
      clone._pivotForBodyName = _pivotForBodyName
      clone._loopExitNames = _loopExitNames
      clone._valuesDef = _valuesDef
      return clone
    }
  }

  private var _storage = _StorageClass()

  ///   Name of the context.
  public var contextName: String {
    get {return _storage._contextName}
    set {_uniqueStorage()._contextName = newValue}
  }

  ///   The number of iterations allowed to run in parallel.
  public var parallelIterations: Int32 {
    get {return _storage._parallelIterations}
    set {_uniqueStorage()._parallelIterations = newValue}
  }

  ///   Whether backprop is enabled for this while loop.
  public var backProp: Bool {
    get {return _storage._backProp}
    set {_uniqueStorage()._backProp = newValue}
  }

  ///   Whether GPU-CPU memory swap is enabled for this loop.
  public var swapMemory: Bool {
    get {return _storage._swapMemory}
    set {_uniqueStorage()._swapMemory = newValue}
  }

  ///   Name of the pivot tensor.
  public var pivotName: String {
    get {return _storage._pivotName}
    set {_uniqueStorage()._pivotName = newValue}
  }

  ///   Name of the pivot_for_pred tensor.
  public var pivotForPredName: String {
    get {return _storage._pivotForPredName}
    set {_uniqueStorage()._pivotForPredName = newValue}
  }

  ///   Name of the pivot_for_body tensor.
  public var pivotForBodyName: String {
    get {return _storage._pivotForBodyName}
    set {_uniqueStorage()._pivotForBodyName = newValue}
  }

  ///   List of names for exit tensors.
  public var loopExitNames: [String] {
    get {return _storage._loopExitNames}
    set {_uniqueStorage()._loopExitNames = newValue}
  }

  ///   Values and external values in control flow context.
  public var valuesDef: Tensorflow_ValuesDef {
    get {return _storage._valuesDef ?? Tensorflow_ValuesDef()}
    set {_uniqueStorage()._valuesDef = newValue}
  }
  public var hasValuesDef: Bool {
    return _storage._valuesDef != nil
  }
  public mutating func clearValuesDef() {
    return _storage._valuesDef = nil
  }

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    try _storage.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_WhileContextDef) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}
