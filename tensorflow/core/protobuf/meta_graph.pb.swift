/*
 * DO NOT EDIT.
 *
 * Generated by the protocol buffer compiler.
 * Source: tensorflow/core/protobuf/meta_graph.proto
 *
 */

import Foundation
import SwiftProtobuf


///   NOTE: This protocol buffer is evolving, and will go through revisions in the
///   coming months.
///  
///   Protocol buffer containing the following which are necessary to restart
///   training, run inference. It can be used to serialize/de-serialize memory
///   objects necessary for running computation in a graph when crossing the
///   process boundary. It can be used for long term storage of graphs,
///   cross-language execution of graphs, etc.
///     MetaInfoDef
///     GraphDef
///     SaverDef
///     CollectionDef
///     TensorInfo
///     SignatureDef
struct Tensorflow_MetaGraphDef: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_MetaGraphDef"}
  public var protoMessageName: String {return "MetaGraphDef"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "metaInfoDef": 1,
    "graphDef": 2,
    "saverDef": 3,
    "collectionDef": 4,
    "signatureDef": 5,
    "assetFileDef": 6,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "meta_info_def": 1,
    "graph_def": 2,
    "saver_def": 3,
    "collection_def": 4,
    "signature_def": 5,
    "asset_file_def": 6,
  ]}

  private class _StorageClass {
    typealias ProtobufExtendedMessage = Tensorflow_MetaGraphDef
    var _metaInfoDef: Tensorflow_MetaGraphDef.MetaInfoDef? = nil
    var _graphDef: Tensorflow_GraphDef? = nil
    var _saverDef: Tensorflow_SaverDef? = nil
    var _collectionDef: Dictionary<String,Tensorflow_CollectionDef> = [:]
    var _signatureDef: Dictionary<String,Tensorflow_SignatureDef> = [:]
    var _assetFileDef: [Tensorflow_AssetFileDef] = []

    init() {}

    func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_MetaGraphDef.MetaInfoDef.self, value: &_metaInfoDef)
      case 2: handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_GraphDef.self, value: &_graphDef)
      case 3: handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_SaverDef.self, value: &_saverDef)
      case 4: handled = try setter.decodeMapField(fieldType: ProtobufMap<ProtobufString,Tensorflow_CollectionDef>.self, value: &_collectionDef)
      case 5: handled = try setter.decodeMapField(fieldType: ProtobufMap<ProtobufString,Tensorflow_SignatureDef>.self, value: &_signatureDef)
      case 6: handled = try setter.decodeRepeatedMessageField(fieldType: Tensorflow_AssetFileDef.self, value: &_assetFileDef)
      default:
        handled = false
      }
      return handled
    }

    func traverse(visitor: inout ProtobufVisitor) throws {
      if let v = _metaInfoDef {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 1, protoFieldName: "meta_info_def", jsonFieldName: "metaInfoDef", swiftFieldName: "metaInfoDef")
      }
      if let v = _graphDef {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 2, protoFieldName: "graph_def", jsonFieldName: "graphDef", swiftFieldName: "graphDef")
      }
      if let v = _saverDef {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 3, protoFieldName: "saver_def", jsonFieldName: "saverDef", swiftFieldName: "saverDef")
      }
      if !_collectionDef.isEmpty {
        try visitor.visitMapField(fieldType: ProtobufMap<ProtobufString,Tensorflow_CollectionDef>.self, value: _collectionDef, protoFieldNumber: 4, protoFieldName: "collection_def", jsonFieldName: "collectionDef", swiftFieldName: "collectionDef")
      }
      if !_signatureDef.isEmpty {
        try visitor.visitMapField(fieldType: ProtobufMap<ProtobufString,Tensorflow_SignatureDef>.self, value: _signatureDef, protoFieldNumber: 5, protoFieldName: "signature_def", jsonFieldName: "signatureDef", swiftFieldName: "signatureDef")
      }
      if !_assetFileDef.isEmpty {
        try visitor.visitRepeatedMessageField(value: _assetFileDef, protoFieldNumber: 6, protoFieldName: "asset_file_def", jsonFieldName: "assetFileDef", swiftFieldName: "assetFileDef")
      }
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _metaInfoDef != other._metaInfoDef {return false}
      if _graphDef != other._graphDef {return false}
      if _saverDef != other._saverDef {return false}
      if _collectionDef != other._collectionDef {return false}
      if _signatureDef != other._signatureDef {return false}
      if _assetFileDef != other._assetFileDef {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._metaInfoDef = _metaInfoDef
      clone._graphDef = _graphDef
      clone._saverDef = _saverDef
      clone._collectionDef = _collectionDef
      clone._signatureDef = _signatureDef
      clone._assetFileDef = _assetFileDef
      return clone
    }
  }

  private var _storage = _StorageClass()

  ///   Meta information regarding the graph to be exported.  To be used by users
  ///   of this protocol buffer to encode information regarding their meta graph.
  struct MetaInfoDef: ProtobufGeneratedMessage {
    public var swiftClassName: String {return "Tensorflow_MetaGraphDef.MetaInfoDef"}
    public var protoMessageName: String {return "MetaInfoDef"}
    public var protoPackageName: String {return "tensorflow"}
    public var jsonFieldNames: [String: Int] {return [
      "metaGraphVersion": 1,
      "strippedOpList": 2,
      "anyInfo": 3,
      "tags": 4,
    ]}
    public var protoFieldNames: [String: Int] {return [
      "meta_graph_version": 1,
      "stripped_op_list": 2,
      "any_info": 3,
      "tags": 4,
    ]}

    private class _StorageClass {
      typealias ProtobufExtendedMessage = Tensorflow_MetaGraphDef.MetaInfoDef
      var _metaGraphVersion: String = ""
      var _strippedOpList: Tensorflow_OpList? = nil
      var _anyInfo: Google_Protobuf_Any? = nil
      var _tags: [String] = []

      init() {}

      func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
        let handled: Bool
        switch protoFieldNumber {
        case 1: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &_metaGraphVersion)
        case 2: handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_OpList.self, value: &_strippedOpList)
        case 3: handled = try setter.decodeSingularMessageField(fieldType: Google_Protobuf_Any.self, value: &_anyInfo)
        case 4: handled = try setter.decodeRepeatedField(fieldType: ProtobufString.self, value: &_tags)
        default:
          handled = false
        }
        return handled
      }

      func traverse(visitor: inout ProtobufVisitor) throws {
        if _metaGraphVersion != "" {
          try visitor.visitSingularField(fieldType: ProtobufString.self, value: _metaGraphVersion, protoFieldNumber: 1, protoFieldName: "meta_graph_version", jsonFieldName: "metaGraphVersion", swiftFieldName: "metaGraphVersion")
        }
        if let v = _strippedOpList {
          try visitor.visitSingularMessageField(value: v, protoFieldNumber: 2, protoFieldName: "stripped_op_list", jsonFieldName: "strippedOpList", swiftFieldName: "strippedOpList")
        }
        if let v = _anyInfo {
          try visitor.visitSingularMessageField(value: v, protoFieldNumber: 3, protoFieldName: "any_info", jsonFieldName: "anyInfo", swiftFieldName: "anyInfo")
        }
        if !_tags.isEmpty {
          try visitor.visitRepeatedField(fieldType: ProtobufString.self, value: _tags, protoFieldNumber: 4, protoFieldName: "tags", jsonFieldName: "tags", swiftFieldName: "tags")
        }
      }

      func isEqualTo(other: _StorageClass) -> Bool {
        if _metaGraphVersion != other._metaGraphVersion {return false}
        if _strippedOpList != other._strippedOpList {return false}
        if _anyInfo != other._anyInfo {return false}
        if _tags != other._tags {return false}
        return true
      }

      func copy() -> _StorageClass {
        let clone = _StorageClass()
        clone._metaGraphVersion = _metaGraphVersion
        clone._strippedOpList = _strippedOpList
        clone._anyInfo = _anyInfo
        clone._tags = _tags
        return clone
      }
    }

    private var _storage = _StorageClass()

    ///   Version string. Can be the name of the model and revision, steps this
    ///   model has been trained to, etc.
    public var metaGraphVersion: String {
      get {return _storage._metaGraphVersion}
      set {_uniqueStorage()._metaGraphVersion = newValue}
    }

    ///   A copy of the OpDefs used by the producer of this graph_def.
    ///   Descriptions and Ops not used in graph_def are stripped out.
    public var strippedOpList: Tensorflow_OpList {
      get {return _storage._strippedOpList ?? Tensorflow_OpList()}
      set {_uniqueStorage()._strippedOpList = newValue}
    }
    public var hasStrippedOpList: Bool {
      return _storage._strippedOpList != nil
    }
    public mutating func clearStrippedOpList() {
      return _storage._strippedOpList = nil
    }

    ///   A serialized protobuf. Can be the time this meta graph is created, or
    ///   modified, or name of the model.
    public var anyInfo: Google_Protobuf_Any {
      get {return _storage._anyInfo ?? Google_Protobuf_Any()}
      set {_uniqueStorage()._anyInfo = newValue}
    }
    public var hasAnyInfo: Bool {
      return _storage._anyInfo != nil
    }
    public mutating func clearAnyInfo() {
      return _storage._anyInfo = nil
    }

    ///   User supplied tag(s) on the meta_graph and included graph_def.
    ///  
    ///   MetaGraphDefs should be tagged with their capabilities or use-cases.
    ///   Examples: "train", "serve", "gpu", "tpu", etc.
    ///   These tags enable loaders to access the MetaGraph(s) appropriate for a
    ///   specific use-case or runtime environment.
    public var tags: [String] {
      get {return _storage._tags}
      set {_uniqueStorage()._tags = newValue}
    }

    public init() {}

    public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
    }

    public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
      try _storage.traverse(visitor: &visitor)
    }

    public func _protoc_generated_isEqualTo(other: Tensorflow_MetaGraphDef.MetaInfoDef) -> Bool {
      return _storage === other._storage || _storage.isEqualTo(other: other._storage)
    }

    private mutating func _uniqueStorage() -> _StorageClass {
      if !isKnownUniquelyReferenced(&_storage) {
        _storage = _storage.copy()
      }
      return _storage
    }
  }

  public var metaInfoDef: Tensorflow_MetaGraphDef.MetaInfoDef {
    get {return _storage._metaInfoDef ?? Tensorflow_MetaGraphDef.MetaInfoDef()}
    set {_uniqueStorage()._metaInfoDef = newValue}
  }
  public var hasMetaInfoDef: Bool {
    return _storage._metaInfoDef != nil
  }
  public mutating func clearMetaInfoDef() {
    return _storage._metaInfoDef = nil
  }

  ///   GraphDef.
  public var graphDef: Tensorflow_GraphDef {
    get {return _storage._graphDef ?? Tensorflow_GraphDef()}
    set {_uniqueStorage()._graphDef = newValue}
  }
  public var hasGraphDef: Bool {
    return _storage._graphDef != nil
  }
  public mutating func clearGraphDef() {
    return _storage._graphDef = nil
  }

  ///   SaverDef.
  public var saverDef: Tensorflow_SaverDef {
    get {return _storage._saverDef ?? Tensorflow_SaverDef()}
    set {_uniqueStorage()._saverDef = newValue}
  }
  public var hasSaverDef: Bool {
    return _storage._saverDef != nil
  }
  public mutating func clearSaverDef() {
    return _storage._saverDef = nil
  }

  ///   collection_def: Map from collection name to collections.
  ///   See CollectionDef section for details.
  public var collectionDef: Dictionary<String,Tensorflow_CollectionDef> {
    get {return _storage._collectionDef}
    set {_uniqueStorage()._collectionDef = newValue}
  }

  ///   signature_def: Map from user supplied key for a signature to a single
  ///   SignatureDef.
  public var signatureDef: Dictionary<String,Tensorflow_SignatureDef> {
    get {return _storage._signatureDef}
    set {_uniqueStorage()._signatureDef = newValue}
  }

  ///   Asset file def to be used with the defined graph.
  public var assetFileDef: [Tensorflow_AssetFileDef] {
    get {return _storage._assetFileDef}
    set {_uniqueStorage()._assetFileDef = newValue}
  }

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    try _storage.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_MetaGraphDef) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

///   CollectionDef should cover most collections.
///   To add a user-defined collection, do one of the following:
///   1. For simple data types, such as string, int, float:
///        tf.add_to_collection("your_collection_name", your_simple_value)
///      strings will be stored as bytes_list.
///  
///   2. For Protobuf types, there are three ways to add them:
///      1) tf.add_to_collection("your_collection_name",
///           your_proto.SerializeToString())
///  
///         collection_def {
///           key: "user_defined_bytes_collection"
///           value {
///             bytes_list {
///               value: "queue_name: \"test_queue\"\n"
///             }
///           }
///         }
///  
///    or
///  
///      2) tf.add_to_collection("your_collection_name", str(your_proto))
///  
///         collection_def {
///           key: "user_defined_string_collection"
///           value {
///            bytes_list {
///               value: "\n\ntest_queue"
///             }
///           }
///         }
///  
///    or
///  
///      3) any_buf = any_pb2.Any()
///         tf.add_to_collection("your_collection_name",
///           any_buf.Pack(your_proto))
///  
///         collection_def {
///           key: "user_defined_any_collection"
///           value {
///             any_list {
///               value {
///                 type_url: "type.googleapis.com/tensorflow.QueueRunnerDef"
///                 value: "\n\ntest_queue"
///               }
///             }
///           }
///         }
///  
///   3. For Python objects, implement to_proto() and from_proto(), and register
///      them in the following manner:
///      ops.register_proto_function("your_collection_name",
///                                  proto_type,
///                                  to_proto=YourPythonObject.to_proto,
///                                  from_proto=YourPythonObject.from_proto)
///      These functions will be invoked to serialize and de-serialize the
///      collection. For example,
///      ops.register_proto_function(ops.GraphKeys.VARIABLES,
///                                  proto_type=variable_pb2.VariableDef,
///                                  to_proto=Variable.to_proto,
///                                  from_proto=Variable.from_proto)
struct Tensorflow_CollectionDef: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_CollectionDef"}
  public var protoMessageName: String {return "CollectionDef"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "nodeList": 1,
    "bytesList": 2,
    "int64List": 3,
    "floatList": 4,
    "anyList": 5,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "node_list": 1,
    "bytes_list": 2,
    "int64_list": 3,
    "float_list": 4,
    "any_list": 5,
  ]}

  private class _StorageClass {
    typealias ProtobufExtendedMessage = Tensorflow_CollectionDef
    var _kind = Tensorflow_CollectionDef.OneOf_Kind()

    init() {}

    func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1, 2, 3, 4, 5:
        handled = try _kind.decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
      default:
        handled = false
      }
      return handled
    }

    func traverse(visitor: inout ProtobufVisitor) throws {
      try _kind.traverse(visitor: &visitor, start: 1, end: 6)
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _kind != other._kind {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._kind = _kind
      return clone
    }
  }

  private var _storage = _StorageClass()

  enum OneOf_Kind: ExpressibleByNilLiteral, ProtobufOneofEnum {
    case nodeList(Tensorflow_CollectionDef.NodeList)
    case bytesList(Tensorflow_CollectionDef.BytesList)
    case int64List(Tensorflow_CollectionDef.Int64List)
    case floatList(Tensorflow_CollectionDef.FloatList)
    case anyList(Tensorflow_CollectionDef.AnyList)
    case None

    public init(nilLiteral: ()) {
      self = .None
    }

    public init() {
      self = .None
    }

    public mutating func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      if self != .None && setter.rejectConflictingOneof {
        throw ProtobufDecodingError.duplicatedOneOf
      }
      let handled: Bool
      switch protoFieldNumber {
      case 1:
        var value: Tensorflow_CollectionDef.NodeList?
        handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_CollectionDef.NodeList.self, value: &value)
        if let value = value, handled {
          self = .nodeList(value)
        }
      case 2:
        var value: Tensorflow_CollectionDef.BytesList?
        handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_CollectionDef.BytesList.self, value: &value)
        if let value = value, handled {
          self = .bytesList(value)
        }
      case 3:
        var value: Tensorflow_CollectionDef.Int64List?
        handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_CollectionDef.Int64List.self, value: &value)
        if let value = value, handled {
          self = .int64List(value)
        }
      case 4:
        var value: Tensorflow_CollectionDef.FloatList?
        handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_CollectionDef.FloatList.self, value: &value)
        if let value = value, handled {
          self = .floatList(value)
        }
      case 5:
        var value: Tensorflow_CollectionDef.AnyList?
        handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_CollectionDef.AnyList.self, value: &value)
        if let value = value, handled {
          self = .anyList(value)
        }
      default:
        handled = false
        self = .None
      }
      return handled
    }

    public func traverse(visitor: inout ProtobufVisitor, start: Int, end: Int) throws {
      switch self {
      case .nodeList(let v):
        if start <= 1 && 1 < end {
          try visitor.visitSingularMessageField(value: v, protoFieldNumber: 1, protoFieldName: "node_list", jsonFieldName: "nodeList", swiftFieldName: "nodeList")
        }
      case .bytesList(let v):
        if start <= 2 && 2 < end {
          try visitor.visitSingularMessageField(value: v, protoFieldNumber: 2, protoFieldName: "bytes_list", jsonFieldName: "bytesList", swiftFieldName: "bytesList")
        }
      case .int64List(let v):
        if start <= 3 && 3 < end {
          try visitor.visitSingularMessageField(value: v, protoFieldNumber: 3, protoFieldName: "int64_list", jsonFieldName: "int64List", swiftFieldName: "int64List")
        }
      case .floatList(let v):
        if start <= 4 && 4 < end {
          try visitor.visitSingularMessageField(value: v, protoFieldNumber: 4, protoFieldName: "float_list", jsonFieldName: "floatList", swiftFieldName: "floatList")
        }
      case .anyList(let v):
        if start <= 5 && 5 < end {
          try visitor.visitSingularMessageField(value: v, protoFieldNumber: 5, protoFieldName: "any_list", jsonFieldName: "anyList", swiftFieldName: "anyList")
        }
      case .None:
        break
      }
    }
  }

  ///   NodeList is used for collecting nodes in graph. For example
  ///   collection_def {
  ///     key: "summaries"
  ///     value {
  ///       node_list {
  ///         value: "input_producer/ScalarSummary:0"
  ///         value: "shuffle_batch/ScalarSummary:0"
  ///         value: "ImageSummary:0"
  ///       }
  ///     }
  struct NodeList: ProtobufGeneratedMessage {
    public var swiftClassName: String {return "Tensorflow_CollectionDef.NodeList"}
    public var protoMessageName: String {return "NodeList"}
    public var protoPackageName: String {return "tensorflow"}
    public var jsonFieldNames: [String: Int] {return [
      "value": 1,
    ]}
    public var protoFieldNames: [String: Int] {return [
      "value": 1,
    ]}

    public var value: [String] = []

    public init() {}

    public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodeRepeatedField(fieldType: ProtobufString.self, value: &value)
      default:
        handled = false
      }
      return handled
    }

    public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
      if !value.isEmpty {
        try visitor.visitRepeatedField(fieldType: ProtobufString.self, value: value, protoFieldNumber: 1, protoFieldName: "value", jsonFieldName: "value", swiftFieldName: "value")
      }
    }

    public func _protoc_generated_isEqualTo(other: Tensorflow_CollectionDef.NodeList) -> Bool {
      if value != other.value {return false}
      return true
    }
  }

  ///   BytesList is used for collecting strings and serialized protobufs. For
  ///   example:
  ///   collection_def {
  ///     key: "trainable_variables"
  ///     value {
  ///       bytes_list {
  ///         value: "\n\017conv1/weights:0\022\024conv1/weights/Assign
  ///                \032\024conv1/weights/read:0"
  ///         value: "\n\016conv1/biases:0\022\023conv1/biases/Assign\032
  ///                \023conv1/biases/read:0"
  ///       }
  ///     }
  ///   }
  struct BytesList: ProtobufGeneratedMessage {
    public var swiftClassName: String {return "Tensorflow_CollectionDef.BytesList"}
    public var protoMessageName: String {return "BytesList"}
    public var protoPackageName: String {return "tensorflow"}
    public var jsonFieldNames: [String: Int] {return [
      "value": 1,
    ]}
    public var protoFieldNames: [String: Int] {return [
      "value": 1,
    ]}

    public var value: [Data] = []

    public init() {}

    public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodeRepeatedField(fieldType: ProtobufBytes.self, value: &value)
      default:
        handled = false
      }
      return handled
    }

    public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
      if !value.isEmpty {
        try visitor.visitRepeatedField(fieldType: ProtobufBytes.self, value: value, protoFieldNumber: 1, protoFieldName: "value", jsonFieldName: "value", swiftFieldName: "value")
      }
    }

    public func _protoc_generated_isEqualTo(other: Tensorflow_CollectionDef.BytesList) -> Bool {
      if value != other.value {return false}
      return true
    }
  }

  ///   Int64List is used for collecting int, int64 and long values.
  struct Int64List: ProtobufGeneratedMessage {
    public var swiftClassName: String {return "Tensorflow_CollectionDef.Int64List"}
    public var protoMessageName: String {return "Int64List"}
    public var protoPackageName: String {return "tensorflow"}
    public var jsonFieldNames: [String: Int] {return [
      "value": 1,
    ]}
    public var protoFieldNames: [String: Int] {return [
      "value": 1,
    ]}

    public var value: [Int64] = []

    public init() {}

    public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodePackedField(fieldType: ProtobufInt64.self, value: &value)
      default:
        handled = false
      }
      return handled
    }

    public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
      if !value.isEmpty {
        try visitor.visitPackedField(fieldType: ProtobufInt64.self, value: value, protoFieldNumber: 1, protoFieldName: "value", jsonFieldName: "value", swiftFieldName: "value")
      }
    }

    public func _protoc_generated_isEqualTo(other: Tensorflow_CollectionDef.Int64List) -> Bool {
      if value != other.value {return false}
      return true
    }
  }

  ///   FloatList is used for collecting float values.
  struct FloatList: ProtobufGeneratedMessage {
    public var swiftClassName: String {return "Tensorflow_CollectionDef.FloatList"}
    public var protoMessageName: String {return "FloatList"}
    public var protoPackageName: String {return "tensorflow"}
    public var jsonFieldNames: [String: Int] {return [
      "value": 1,
    ]}
    public var protoFieldNames: [String: Int] {return [
      "value": 1,
    ]}

    public var value: [Float] = []

    public init() {}

    public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodePackedField(fieldType: ProtobufFloat.self, value: &value)
      default:
        handled = false
      }
      return handled
    }

    public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
      if !value.isEmpty {
        try visitor.visitPackedField(fieldType: ProtobufFloat.self, value: value, protoFieldNumber: 1, protoFieldName: "value", jsonFieldName: "value", swiftFieldName: "value")
      }
    }

    public func _protoc_generated_isEqualTo(other: Tensorflow_CollectionDef.FloatList) -> Bool {
      if value != other.value {return false}
      return true
    }
  }

  ///   AnyList is used for collecting Any protos.
  struct AnyList: ProtobufGeneratedMessage {
    public var swiftClassName: String {return "Tensorflow_CollectionDef.AnyList"}
    public var protoMessageName: String {return "AnyList"}
    public var protoPackageName: String {return "tensorflow"}
    public var jsonFieldNames: [String: Int] {return [
      "value": 1,
    ]}
    public var protoFieldNames: [String: Int] {return [
      "value": 1,
    ]}

    public var value: [Google_Protobuf_Any] = []

    public init() {}

    public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodeRepeatedMessageField(fieldType: Google_Protobuf_Any.self, value: &value)
      default:
        handled = false
      }
      return handled
    }

    public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
      if !value.isEmpty {
        try visitor.visitRepeatedMessageField(value: value, protoFieldNumber: 1, protoFieldName: "value", jsonFieldName: "value", swiftFieldName: "value")
      }
    }

    public func _protoc_generated_isEqualTo(other: Tensorflow_CollectionDef.AnyList) -> Bool {
      if value != other.value {return false}
      return true
    }
  }

  public var nodeList: Tensorflow_CollectionDef.NodeList {
    get {
      if case .nodeList(let v) = _storage._kind {
        return v
      }
      return Tensorflow_CollectionDef.NodeList()
    }
    set {
      _uniqueStorage()._kind = .nodeList(newValue)
    }
  }

  public var bytesList: Tensorflow_CollectionDef.BytesList {
    get {
      if case .bytesList(let v) = _storage._kind {
        return v
      }
      return Tensorflow_CollectionDef.BytesList()
    }
    set {
      _uniqueStorage()._kind = .bytesList(newValue)
    }
  }

  public var int64List: Tensorflow_CollectionDef.Int64List {
    get {
      if case .int64List(let v) = _storage._kind {
        return v
      }
      return Tensorflow_CollectionDef.Int64List()
    }
    set {
      _uniqueStorage()._kind = .int64List(newValue)
    }
  }

  public var floatList: Tensorflow_CollectionDef.FloatList {
    get {
      if case .floatList(let v) = _storage._kind {
        return v
      }
      return Tensorflow_CollectionDef.FloatList()
    }
    set {
      _uniqueStorage()._kind = .floatList(newValue)
    }
  }

  public var anyList: Tensorflow_CollectionDef.AnyList {
    get {
      if case .anyList(let v) = _storage._kind {
        return v
      }
      return Tensorflow_CollectionDef.AnyList()
    }
    set {
      _uniqueStorage()._kind = .anyList(newValue)
    }
  }

  public var kind: OneOf_Kind {
    get {return _storage._kind}
    set {
      _uniqueStorage()._kind = newValue
    }
  }

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    try _storage.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_CollectionDef) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

///   Information about a Tensor necessary for feeding or retrieval.
struct Tensorflow_TensorInfo: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_TensorInfo"}
  public var protoMessageName: String {return "TensorInfo"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "name": 1,
    "dtype": 2,
    "tensorShape": 3,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "name": 1,
    "dtype": 2,
    "tensor_shape": 3,
  ]}

  private class _StorageClass {
    typealias ProtobufExtendedMessage = Tensorflow_TensorInfo
    var _name: String = ""
    var _dtype: Tensorflow_DataType = Tensorflow_DataType.dtInvalid
    var _tensorShape: Tensorflow_TensorShapeProto? = nil

    init() {}

    func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &_name)
      case 2: handled = try setter.decodeSingularField(fieldType: Tensorflow_DataType.self, value: &_dtype)
      case 3: handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_TensorShapeProto.self, value: &_tensorShape)
      default:
        handled = false
      }
      return handled
    }

    func traverse(visitor: inout ProtobufVisitor) throws {
      if _name != "" {
        try visitor.visitSingularField(fieldType: ProtobufString.self, value: _name, protoFieldNumber: 1, protoFieldName: "name", jsonFieldName: "name", swiftFieldName: "name")
      }
      if _dtype != Tensorflow_DataType.dtInvalid {
        try visitor.visitSingularField(fieldType: Tensorflow_DataType.self, value: _dtype, protoFieldNumber: 2, protoFieldName: "dtype", jsonFieldName: "dtype", swiftFieldName: "dtype")
      }
      if let v = _tensorShape {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 3, protoFieldName: "tensor_shape", jsonFieldName: "tensorShape", swiftFieldName: "tensorShape")
      }
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _name != other._name {return false}
      if _dtype != other._dtype {return false}
      if _tensorShape != other._tensorShape {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._name = _name
      clone._dtype = _dtype
      clone._tensorShape = _tensorShape
      return clone
    }
  }

  private var _storage = _StorageClass()

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var dtype: Tensorflow_DataType {
    get {return _storage._dtype}
    set {_uniqueStorage()._dtype = newValue}
  }

  public var tensorShape: Tensorflow_TensorShapeProto {
    get {return _storage._tensorShape ?? Tensorflow_TensorShapeProto()}
    set {_uniqueStorage()._tensorShape = newValue}
  }
  public var hasTensorShape: Bool {
    return _storage._tensorShape != nil
  }
  public mutating func clearTensorShape() {
    return _storage._tensorShape = nil
  }

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    try _storage.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_TensorInfo) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

///   SignatureDef defines the signature of a computation supported by a TensorFlow
///   graph.
///  
///   For example, a model with two loss computations, sharing a single input,
///   might have the following signature_def map.
///  
///   Note that across the two SignatureDefs "loss_A" and "loss_B", the input key,
///   output key, and method_name are identical, and will be used by system(s) that
///   implement or rely upon this particular loss method. The output tensor names
///   differ, demonstrating how different outputs can exist for the same method.
///  
///   signature_def {
///     key: "loss_A"
///     value {
///       inputs {
///         key: "input"
///         value {
///           name: "input:0"
///           dtype: DT_STRING
///           tensor_shape: ...
///         }
///       }
///       outputs {
///         key: "loss_output"
///         value {
///           name: "loss_output_A:0"
///           dtype: DT_FLOAT
///           tensor_shape: ...
///         }
///       }
///     }
///     ...
///     method_name: "some/package/compute_loss"
///   }
///   signature_def {
///     key: "loss_B"
///     value {
///       inputs {
///         key: "input"
///         value {
///           name: "input:0"
///           dtype: DT_STRING
///           tensor_shape: ...
///         }
///       }
///       outputs {
///         key: "loss_output"
///         value {
///           name: "loss_output_B:0"
///           dtype: DT_FLOAT
///           tensor_shape: ...
///         }
///       }
///     }
///     ...
///     method_name: "some/package/compute_loss"
///   }
struct Tensorflow_SignatureDef: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_SignatureDef"}
  public var protoMessageName: String {return "SignatureDef"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "inputs": 1,
    "outputs": 2,
    "methodName": 3,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "inputs": 1,
    "outputs": 2,
    "method_name": 3,
  ]}

  ///   Named input parameters.
  public var inputs: Dictionary<String,Tensorflow_TensorInfo> = [:]

  ///   Named output parameters.
  public var outputs: Dictionary<String,Tensorflow_TensorInfo> = [:]

  ///   Extensible method_name information enabling third-party users to mark a
  ///   SignatureDef as supporting a particular method. This enables producers and
  ///   consumers of SignatureDefs, e.g. a model definition library and a serving
  ///   library to have a clear hand-off regarding the semantics of a computation.
  ///  
  ///   Note that multiple SignatureDefs in a single MetaGraphDef may have the same
  ///   method_name. This is commonly used to support multi-headed computation,
  ///   where a single graph computation may return multiple results.
  public var methodName: String = ""

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeMapField(fieldType: ProtobufMap<ProtobufString,Tensorflow_TensorInfo>.self, value: &inputs)
    case 2: handled = try setter.decodeMapField(fieldType: ProtobufMap<ProtobufString,Tensorflow_TensorInfo>.self, value: &outputs)
    case 3: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &methodName)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if !inputs.isEmpty {
      try visitor.visitMapField(fieldType: ProtobufMap<ProtobufString,Tensorflow_TensorInfo>.self, value: inputs, protoFieldNumber: 1, protoFieldName: "inputs", jsonFieldName: "inputs", swiftFieldName: "inputs")
    }
    if !outputs.isEmpty {
      try visitor.visitMapField(fieldType: ProtobufMap<ProtobufString,Tensorflow_TensorInfo>.self, value: outputs, protoFieldNumber: 2, protoFieldName: "outputs", jsonFieldName: "outputs", swiftFieldName: "outputs")
    }
    if methodName != "" {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: methodName, protoFieldNumber: 3, protoFieldName: "method_name", jsonFieldName: "methodName", swiftFieldName: "methodName")
    }
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_SignatureDef) -> Bool {
    if inputs != other.inputs {return false}
    if outputs != other.outputs {return false}
    if methodName != other.methodName {return false}
    return true
  }
}

///   An asset file def for a single file or a set of sharded files with the same
///   name.
struct Tensorflow_AssetFileDef: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_AssetFileDef"}
  public var protoMessageName: String {return "AssetFileDef"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "tensorInfo": 1,
    "filename": 2,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "tensor_info": 1,
    "filename": 2,
  ]}

  private class _StorageClass {
    typealias ProtobufExtendedMessage = Tensorflow_AssetFileDef
    var _tensorInfo: Tensorflow_TensorInfo? = nil
    var _filename: String = ""

    init() {}

    func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_TensorInfo.self, value: &_tensorInfo)
      case 2: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &_filename)
      default:
        handled = false
      }
      return handled
    }

    func traverse(visitor: inout ProtobufVisitor) throws {
      if let v = _tensorInfo {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 1, protoFieldName: "tensor_info", jsonFieldName: "tensorInfo", swiftFieldName: "tensorInfo")
      }
      if _filename != "" {
        try visitor.visitSingularField(fieldType: ProtobufString.self, value: _filename, protoFieldNumber: 2, protoFieldName: "filename", jsonFieldName: "filename", swiftFieldName: "filename")
      }
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _tensorInfo != other._tensorInfo {return false}
      if _filename != other._filename {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._tensorInfo = _tensorInfo
      clone._filename = _filename
      return clone
    }
  }

  private var _storage = _StorageClass()

  ///   The tensor to bind the asset filename to.
  public var tensorInfo: Tensorflow_TensorInfo {
    get {return _storage._tensorInfo ?? Tensorflow_TensorInfo()}
    set {_uniqueStorage()._tensorInfo = newValue}
  }
  public var hasTensorInfo: Bool {
    return _storage._tensorInfo != nil
  }
  public mutating func clearTensorInfo() {
    return _storage._tensorInfo = nil
  }

  ///   The filename within an assets directory. Note: does not include the path
  ///   prefix, i.e. directories. For an asset at /tmp/path/vocab.txt, the filename
  ///   would be "vocab.txt".
  public var filename: String {
    get {return _storage._filename}
    set {_uniqueStorage()._filename = newValue}
  }

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    try _storage.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_AssetFileDef) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

func ==(lhs: Tensorflow_CollectionDef.OneOf_Kind, rhs: Tensorflow_CollectionDef.OneOf_Kind) -> Bool {
  switch (lhs, rhs) {
  case (.nodeList(let l), .nodeList(let r)): return l == r
  case (.bytesList(let l), .bytesList(let r)): return l == r
  case (.int64List(let l), .int64List(let r)): return l == r
  case (.floatList(let l), .floatList(let r)): return l == r
  case (.anyList(let l), .anyList(let r)): return l == r
  case (.None, .None): return true
  default: return false
  }
}
