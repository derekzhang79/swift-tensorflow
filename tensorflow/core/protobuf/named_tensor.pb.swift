/*
 * DO NOT EDIT.
 *
 * Generated by the protocol buffer compiler.
 * Source: tensorflow/core/protobuf/named_tensor.proto
 *
 */

import Foundation
import SwiftProtobuf


///   A pair of tensor name and tensor values.
struct Tensorflow_NamedTensorProto: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_NamedTensorProto"}
  public var protoMessageName: String {return "NamedTensorProto"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "name": 1,
    "tensor": 2,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "name": 1,
    "tensor": 2,
  ]}

  private class _StorageClass {
    typealias ProtobufExtendedMessage = Tensorflow_NamedTensorProto
    var _name: String = ""
    var _tensor: Tensorflow_TensorProto? = nil

    init() {}

    func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &_name)
      case 2: handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_TensorProto.self, value: &_tensor)
      default:
        handled = false
      }
      return handled
    }

    func traverse(visitor: inout ProtobufVisitor) throws {
      if _name != "" {
        try visitor.visitSingularField(fieldType: ProtobufString.self, value: _name, protoFieldNumber: 1, protoFieldName: "name", jsonFieldName: "name", swiftFieldName: "name")
      }
      if let v = _tensor {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 2, protoFieldName: "tensor", jsonFieldName: "tensor", swiftFieldName: "tensor")
      }
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _name != other._name {return false}
      if _tensor != other._tensor {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._name = _name
      clone._tensor = _tensor
      return clone
    }
  }

  private var _storage = _StorageClass()

  ///   Name of the tensor.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  ///   The client can populate a TensorProto using a tensorflow::Tensor`, or
  ///   directly using the protobuf field accessors.
  ///  
  ///   The client specifies whether the returned tensor values should be
  ///   filled tensor fields (float_val, int_val, etc.) or encoded in a
  ///   compact form in tensor.tensor_content.
  public var tensor: Tensorflow_TensorProto {
    get {return _storage._tensor ?? Tensorflow_TensorProto()}
    set {_uniqueStorage()._tensor = newValue}
  }
  public var hasTensor: Bool {
    return _storage._tensor != nil
  }
  public mutating func clearTensor() {
    return _storage._tensor = nil
  }

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    try _storage.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_NamedTensorProto) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}
