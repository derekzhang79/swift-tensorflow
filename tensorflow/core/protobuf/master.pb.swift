/*
 * DO NOT EDIT.
 *
 * Generated by the protocol buffer compiler.
 * Source: tensorflow/core/protobuf/master.proto
 *
 */

//  Copyright 2016 The TensorFlow Authors. All Rights Reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ==============================================================================

import Foundation
import SwiftProtobuf


// //////////////////////////////////////////////////////////////////////////////
// 
//  CreateSession method request/response protos.
// 
// //////////////////////////////////////////////////////////////////////////////

struct Tensorflow_CreateSessionRequest: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_CreateSessionRequest"}
  public var protoMessageName: String {return "CreateSessionRequest"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "graphDef": 1,
    "config": 2,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "graph_def": 1,
    "config": 2,
  ]}

  private class _StorageClass {
    typealias ProtobufExtendedMessage = Tensorflow_CreateSessionRequest
    var _graphDef: Tensorflow_GraphDef? = nil
    var _config: Tensorflow_ConfigProto? = nil

    init() {}

    func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_GraphDef.self, value: &_graphDef)
      case 2: handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_ConfigProto.self, value: &_config)
      default:
        handled = false
      }
      return handled
    }

    func traverse(visitor: inout ProtobufVisitor) throws {
      if let v = _graphDef {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 1, protoFieldName: "graph_def", jsonFieldName: "graphDef", swiftFieldName: "graphDef")
      }
      if let v = _config {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 2, protoFieldName: "config", jsonFieldName: "config", swiftFieldName: "config")
      }
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _graphDef != other._graphDef {return false}
      if _config != other._config {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._graphDef = _graphDef
      clone._config = _config
      return clone
    }
  }

  private var _storage = _StorageClass()

  ///   The initial graph definition.
  public var graphDef: Tensorflow_GraphDef {
    get {return _storage._graphDef ?? Tensorflow_GraphDef()}
    set {_uniqueStorage()._graphDef = newValue}
  }
  public var hasGraphDef: Bool {
    return _storage._graphDef != nil
  }
  public mutating func clearGraphDef() {
    return _storage._graphDef = nil
  }

  ///   Configuration options.
  public var config: Tensorflow_ConfigProto {
    get {return _storage._config ?? Tensorflow_ConfigProto()}
    set {_uniqueStorage()._config = newValue}
  }
  public var hasConfig: Bool {
    return _storage._config != nil
  }
  public mutating func clearConfig() {
    return _storage._config = nil
  }

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    try _storage.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_CreateSessionRequest) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

struct Tensorflow_CreateSessionResponse: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_CreateSessionResponse"}
  public var protoMessageName: String {return "CreateSessionResponse"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "sessionHandle": 1,
    "graphVersion": 2,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "session_handle": 1,
    "graph_version": 2,
  ]}

  ///   The session handle to be used in subsequent calls for the created session.
  ///  
  ///   The client must arrange to call CloseSession with this returned
  ///   session handle to close the session.
  public var sessionHandle: String = ""

  ///   The initial version number for the graph, to be used in the next call
  ///   to ExtendSession.
  public var graphVersion: Int64 = 0

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &sessionHandle)
    case 2: handled = try setter.decodeSingularField(fieldType: ProtobufInt64.self, value: &graphVersion)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if sessionHandle != "" {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: sessionHandle, protoFieldNumber: 1, protoFieldName: "session_handle", jsonFieldName: "sessionHandle", swiftFieldName: "sessionHandle")
    }
    if graphVersion != 0 {
      try visitor.visitSingularField(fieldType: ProtobufInt64.self, value: graphVersion, protoFieldNumber: 2, protoFieldName: "graph_version", jsonFieldName: "graphVersion", swiftFieldName: "graphVersion")
    }
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_CreateSessionResponse) -> Bool {
    if sessionHandle != other.sessionHandle {return false}
    if graphVersion != other.graphVersion {return false}
    return true
  }
}

// //////////////////////////////////////////////////////////////////////////////
// 
//  ExtendSession method request/response protos.
// 
//  The "graph_def" specifies a set of nodes to be added to the session's graph.
// 
//  A typical "graph_def" will contain:
// 
//  * Zero or more new nodes with names that do not exist in the server-side
//    graph. These will be added to the graph.
// 
//  PRECONDITION: The server-side current version is req.current_version.
//    None of the names in req.graph_def appeared in previous successful calls to
//    CreateSession or ExtendSession with the same session_handle.
//  POSTCONDITION: The server-side current version is resp.new_version.
// 
// //////////////////////////////////////////////////////////////////////////////

struct Tensorflow_ExtendSessionRequest: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_ExtendSessionRequest"}
  public var protoMessageName: String {return "ExtendSessionRequest"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "sessionHandle": 1,
    "graphDef": 2,
    "currentGraphVersion": 3,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "session_handle": 1,
    "graph_def": 2,
    "current_graph_version": 3,
  ]}

  private class _StorageClass {
    typealias ProtobufExtendedMessage = Tensorflow_ExtendSessionRequest
    var _sessionHandle: String = ""
    var _graphDef: Tensorflow_GraphDef? = nil
    var _currentGraphVersion: Int64 = 0

    init() {}

    func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &_sessionHandle)
      case 2: handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_GraphDef.self, value: &_graphDef)
      case 3: handled = try setter.decodeSingularField(fieldType: ProtobufInt64.self, value: &_currentGraphVersion)
      default:
        handled = false
      }
      return handled
    }

    func traverse(visitor: inout ProtobufVisitor) throws {
      if _sessionHandle != "" {
        try visitor.visitSingularField(fieldType: ProtobufString.self, value: _sessionHandle, protoFieldNumber: 1, protoFieldName: "session_handle", jsonFieldName: "sessionHandle", swiftFieldName: "sessionHandle")
      }
      if let v = _graphDef {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 2, protoFieldName: "graph_def", jsonFieldName: "graphDef", swiftFieldName: "graphDef")
      }
      if _currentGraphVersion != 0 {
        try visitor.visitSingularField(fieldType: ProtobufInt64.self, value: _currentGraphVersion, protoFieldNumber: 3, protoFieldName: "current_graph_version", jsonFieldName: "currentGraphVersion", swiftFieldName: "currentGraphVersion")
      }
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _sessionHandle != other._sessionHandle {return false}
      if _graphDef != other._graphDef {return false}
      if _currentGraphVersion != other._currentGraphVersion {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._sessionHandle = _sessionHandle
      clone._graphDef = _graphDef
      clone._currentGraphVersion = _currentGraphVersion
      return clone
    }
  }

  private var _storage = _StorageClass()

  ///   REQUIRED: session_handle must be returned by a CreateSession call
  ///   to the same master service.
  public var sessionHandle: String {
    get {return _storage._sessionHandle}
    set {_uniqueStorage()._sessionHandle = newValue}
  }

  ///   REQUIRED: The nodes to be added to the session's graph. If any node has
  ///   the same name as an existing node, the operation will fail with
  ///   ILLEGAL_ARGUMENT.
  public var graphDef: Tensorflow_GraphDef {
    get {return _storage._graphDef ?? Tensorflow_GraphDef()}
    set {_uniqueStorage()._graphDef = newValue}
  }
  public var hasGraphDef: Bool {
    return _storage._graphDef != nil
  }
  public mutating func clearGraphDef() {
    return _storage._graphDef = nil
  }

  ///   REQUIRED: The version number of the graph to be extended. This will be
  ///   tested against the current server-side version number, and the operation
  ///   will fail with FAILED_PRECONDITION if they do not match.
  public var currentGraphVersion: Int64 {
    get {return _storage._currentGraphVersion}
    set {_uniqueStorage()._currentGraphVersion = newValue}
  }

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    try _storage.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_ExtendSessionRequest) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

///   TODO(mrry): Return something about the operation?
struct Tensorflow_ExtendSessionResponse: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_ExtendSessionResponse"}
  public var protoMessageName: String {return "ExtendSessionResponse"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "newGraphVersion": 4,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "new_graph_version": 4,
  ]}

  ///   The new version number for the extended graph, to be used in the next call
  ///   to ExtendSession.
  public var newGraphVersion: Int64 = 0

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 4: handled = try setter.decodeSingularField(fieldType: ProtobufInt64.self, value: &newGraphVersion)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if newGraphVersion != 0 {
      try visitor.visitSingularField(fieldType: ProtobufInt64.self, value: newGraphVersion, protoFieldNumber: 4, protoFieldName: "new_graph_version", jsonFieldName: "newGraphVersion", swiftFieldName: "newGraphVersion")
    }
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_ExtendSessionResponse) -> Bool {
    if newGraphVersion != other.newGraphVersion {return false}
    return true
  }
}

// //////////////////////////////////////////////////////////////////////////////
// 
//  RunStep method request/response protos.
// 
//  The caller should provide the feeds needed by the graph and specify
//  what nodes should be fetched.
// 
// //////////////////////////////////////////////////////////////////////////////

struct Tensorflow_RunStepRequest: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_RunStepRequest"}
  public var protoMessageName: String {return "RunStepRequest"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "sessionHandle": 1,
    "feed": 2,
    "fetch": 3,
    "target": 4,
    "options": 5,
    "partialRunHandle": 6,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "session_handle": 1,
    "feed": 2,
    "fetch": 3,
    "target": 4,
    "options": 5,
    "partial_run_handle": 6,
  ]}

  private class _StorageClass {
    typealias ProtobufExtendedMessage = Tensorflow_RunStepRequest
    var _sessionHandle: String = ""
    var _feed: [Tensorflow_NamedTensorProto] = []
    var _fetch: [String] = []
    var _target: [String] = []
    var _options: Tensorflow_RunOptions? = nil
    var _partialRunHandle: String = ""

    init() {}

    func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &_sessionHandle)
      case 2: handled = try setter.decodeRepeatedMessageField(fieldType: Tensorflow_NamedTensorProto.self, value: &_feed)
      case 3: handled = try setter.decodeRepeatedField(fieldType: ProtobufString.self, value: &_fetch)
      case 4: handled = try setter.decodeRepeatedField(fieldType: ProtobufString.self, value: &_target)
      case 5: handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_RunOptions.self, value: &_options)
      case 6: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &_partialRunHandle)
      default:
        handled = false
      }
      return handled
    }

    func traverse(visitor: inout ProtobufVisitor) throws {
      if _sessionHandle != "" {
        try visitor.visitSingularField(fieldType: ProtobufString.self, value: _sessionHandle, protoFieldNumber: 1, protoFieldName: "session_handle", jsonFieldName: "sessionHandle", swiftFieldName: "sessionHandle")
      }
      if !_feed.isEmpty {
        try visitor.visitRepeatedMessageField(value: _feed, protoFieldNumber: 2, protoFieldName: "feed", jsonFieldName: "feed", swiftFieldName: "feed")
      }
      if !_fetch.isEmpty {
        try visitor.visitRepeatedField(fieldType: ProtobufString.self, value: _fetch, protoFieldNumber: 3, protoFieldName: "fetch", jsonFieldName: "fetch", swiftFieldName: "fetch")
      }
      if !_target.isEmpty {
        try visitor.visitRepeatedField(fieldType: ProtobufString.self, value: _target, protoFieldNumber: 4, protoFieldName: "target", jsonFieldName: "target", swiftFieldName: "target")
      }
      if let v = _options {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 5, protoFieldName: "options", jsonFieldName: "options", swiftFieldName: "options")
      }
      if _partialRunHandle != "" {
        try visitor.visitSingularField(fieldType: ProtobufString.self, value: _partialRunHandle, protoFieldNumber: 6, protoFieldName: "partial_run_handle", jsonFieldName: "partialRunHandle", swiftFieldName: "partialRunHandle")
      }
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _sessionHandle != other._sessionHandle {return false}
      if _feed != other._feed {return false}
      if _fetch != other._fetch {return false}
      if _target != other._target {return false}
      if _options != other._options {return false}
      if _partialRunHandle != other._partialRunHandle {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._sessionHandle = _sessionHandle
      clone._feed = _feed
      clone._fetch = _fetch
      clone._target = _target
      clone._options = _options
      clone._partialRunHandle = _partialRunHandle
      return clone
    }
  }

  private var _storage = _StorageClass()

  ///   REQUIRED: session_handle must be returned by a CreateSession call
  ///   to the same master service.
  public var sessionHandle: String {
    get {return _storage._sessionHandle}
    set {_uniqueStorage()._sessionHandle = newValue}
  }

  ///   Tensors to be fed in the step. Each feed is a named tensor.
  public var feed: [Tensorflow_NamedTensorProto] {
    get {return _storage._feed}
    set {_uniqueStorage()._feed = newValue}
  }

  ///   Fetches. A list of tensor names. The caller expects a tensor to
  ///   be returned for each fetch[i] (see RunStepResponse.tensor). The
  ///   order of specified fetches does not change the execution order.
  public var fetch: [String] {
    get {return _storage._fetch}
    set {_uniqueStorage()._fetch = newValue}
  }

  ///   Target Nodes. A list of node names. The named nodes will be run
  ///   to but their outputs will not be fetched.
  public var target: [String] {
    get {return _storage._target}
    set {_uniqueStorage()._target = newValue}
  }

  ///   Options for the run call.
  public var options: Tensorflow_RunOptions {
    get {return _storage._options ?? Tensorflow_RunOptions()}
    set {_uniqueStorage()._options = newValue}
  }
  public var hasOptions: Bool {
    return _storage._options != nil
  }
  public mutating func clearOptions() {
    return _storage._options = nil
  }

  ///   Partial run handle (optional). If specified, this will be a partial run
  ///   execution, run up to the specified fetches.
  public var partialRunHandle: String {
    get {return _storage._partialRunHandle}
    set {_uniqueStorage()._partialRunHandle = newValue}
  }

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    try _storage.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_RunStepRequest) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

struct Tensorflow_RunStepResponse: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_RunStepResponse"}
  public var protoMessageName: String {return "RunStepResponse"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "tensor": 1,
    "metadata": 2,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "tensor": 1,
    "metadata": 2,
  ]}

  private class _StorageClass {
    typealias ProtobufExtendedMessage = Tensorflow_RunStepResponse
    var _tensor: [Tensorflow_NamedTensorProto] = []
    var _metadata: Tensorflow_RunMetadata? = nil

    init() {}

    func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodeRepeatedMessageField(fieldType: Tensorflow_NamedTensorProto.self, value: &_tensor)
      case 2: handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_RunMetadata.self, value: &_metadata)
      default:
        handled = false
      }
      return handled
    }

    func traverse(visitor: inout ProtobufVisitor) throws {
      if !_tensor.isEmpty {
        try visitor.visitRepeatedMessageField(value: _tensor, protoFieldNumber: 1, protoFieldName: "tensor", jsonFieldName: "tensor", swiftFieldName: "tensor")
      }
      if let v = _metadata {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 2, protoFieldName: "metadata", jsonFieldName: "metadata", swiftFieldName: "metadata")
      }
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _tensor != other._tensor {return false}
      if _metadata != other._metadata {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._tensor = _tensor
      clone._metadata = _metadata
      return clone
    }
  }

  private var _storage = _StorageClass()

  ///   NOTE: The order of the returned tensors may or may not match
  ///   the fetch order specified in RunStepRequest.
  public var tensor: [Tensorflow_NamedTensorProto] {
    get {return _storage._tensor}
    set {_uniqueStorage()._tensor = newValue}
  }

  ///   Returned metadata if requested in the options.
  public var metadata: Tensorflow_RunMetadata {
    get {return _storage._metadata ?? Tensorflow_RunMetadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  public var hasMetadata: Bool {
    return _storage._metadata != nil
  }
  public mutating func clearMetadata() {
    return _storage._metadata = nil
  }

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    try _storage.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_RunStepResponse) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

// //////////////////////////////////////////////////////////////////////////////
// 
//  PartialRunSetup method request/response protos.
// 
//  The caller should provide the future partial run feeds, fetches, and targets.
//  Then the caller can use RunStepRequest with is_partial set to make partial
//  run calls.
// 
// //////////////////////////////////////////////////////////////////////////////

struct Tensorflow_PartialRunSetupRequest: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_PartialRunSetupRequest"}
  public var protoMessageName: String {return "PartialRunSetupRequest"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "sessionHandle": 1,
    "feed": 2,
    "fetch": 3,
    "target": 4,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "session_handle": 1,
    "feed": 2,
    "fetch": 3,
    "target": 4,
  ]}

  ///   REQUIRED: session_handle must be returned by a CreateSession call
  ///   to the same master service.
  public var sessionHandle: String = ""

  ///   Tensors to be fed in future steps.
  public var feed: [String] = []

  ///   Fetches. A list of tensor names. The caller expects a tensor to be returned
  ///   for each fetch[i] (see RunStepResponse.tensor), for corresponding partial
  ///   RunStepRequests. The order of specified fetches does not change the
  ///   execution order.
  public var fetch: [String] = []

  ///   Target Nodes. A list of node names. The named nodes will be run in future
  ///   steps, but their outputs will not be fetched.
  public var target: [String] = []

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &sessionHandle)
    case 2: handled = try setter.decodeRepeatedField(fieldType: ProtobufString.self, value: &feed)
    case 3: handled = try setter.decodeRepeatedField(fieldType: ProtobufString.self, value: &fetch)
    case 4: handled = try setter.decodeRepeatedField(fieldType: ProtobufString.self, value: &target)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if sessionHandle != "" {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: sessionHandle, protoFieldNumber: 1, protoFieldName: "session_handle", jsonFieldName: "sessionHandle", swiftFieldName: "sessionHandle")
    }
    if !feed.isEmpty {
      try visitor.visitRepeatedField(fieldType: ProtobufString.self, value: feed, protoFieldNumber: 2, protoFieldName: "feed", jsonFieldName: "feed", swiftFieldName: "feed")
    }
    if !fetch.isEmpty {
      try visitor.visitRepeatedField(fieldType: ProtobufString.self, value: fetch, protoFieldNumber: 3, protoFieldName: "fetch", jsonFieldName: "fetch", swiftFieldName: "fetch")
    }
    if !target.isEmpty {
      try visitor.visitRepeatedField(fieldType: ProtobufString.self, value: target, protoFieldNumber: 4, protoFieldName: "target", jsonFieldName: "target", swiftFieldName: "target")
    }
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_PartialRunSetupRequest) -> Bool {
    if sessionHandle != other.sessionHandle {return false}
    if feed != other.feed {return false}
    if fetch != other.fetch {return false}
    if target != other.target {return false}
    return true
  }
}

struct Tensorflow_PartialRunSetupResponse: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_PartialRunSetupResponse"}
  public var protoMessageName: String {return "PartialRunSetupResponse"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "partialRunHandle": 1,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "partial_run_handle": 1,
  ]}

  ///   The unique handle corresponding to the ongoing partial run call setup by
  ///   the invocation to PartialRunSetup. This handle may be passed to
  ///   RunStepRequest to send and receive tensors for this partial run.
  public var partialRunHandle: String = ""

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &partialRunHandle)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if partialRunHandle != "" {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: partialRunHandle, protoFieldNumber: 1, protoFieldName: "partial_run_handle", jsonFieldName: "partialRunHandle", swiftFieldName: "partialRunHandle")
    }
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_PartialRunSetupResponse) -> Bool {
    if partialRunHandle != other.partialRunHandle {return false}
    return true
  }
}

// //////////////////////////////////////////////////////////////////////////////
// 
//  CloseSession method request/response protos.
// 
// //////////////////////////////////////////////////////////////////////////////

struct Tensorflow_CloseSessionRequest: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_CloseSessionRequest"}
  public var protoMessageName: String {return "CloseSessionRequest"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "sessionHandle": 1,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "session_handle": 1,
  ]}

  ///   REQUIRED: session_handle must be returned by a CreateSession call
  ///   to the same master service.
  public var sessionHandle: String = ""

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &sessionHandle)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if sessionHandle != "" {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: sessionHandle, protoFieldNumber: 1, protoFieldName: "session_handle", jsonFieldName: "sessionHandle", swiftFieldName: "sessionHandle")
    }
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_CloseSessionRequest) -> Bool {
    if sessionHandle != other.sessionHandle {return false}
    return true
  }
}

struct Tensorflow_CloseSessionResponse: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_CloseSessionResponse"}
  public var protoMessageName: String {return "CloseSessionResponse"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [:]}
  public var protoFieldNames: [String: Int] {return [:]}

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return false // Proto3 ignores unknown fields
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_CloseSessionResponse) -> Bool {
    return true
  }
}

struct Tensorflow_ResetRequest: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_ResetRequest"}
  public var protoMessageName: String {return "ResetRequest"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "container": 1,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "container": 1,
  ]}

  ///   A list of container names, which may be empty.
  ///  
  ///   If 'container' is not empty, releases resoures in the given
  ///   containers in all devices.
  ///  
  ///   If 'container' is empty, releases resources in the default
  ///   container in all devices.
  public var container: [String] = []

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeRepeatedField(fieldType: ProtobufString.self, value: &container)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if !container.isEmpty {
      try visitor.visitRepeatedField(fieldType: ProtobufString.self, value: container, protoFieldNumber: 1, protoFieldName: "container", jsonFieldName: "container", swiftFieldName: "container")
    }
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_ResetRequest) -> Bool {
    if container != other.container {return false}
    return true
  }
}

struct Tensorflow_ResetResponse: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_ResetResponse"}
  public var protoMessageName: String {return "ResetResponse"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [:]}
  public var protoFieldNames: [String: Int] {return [:]}

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return false // Proto3 ignores unknown fields
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_ResetResponse) -> Bool {
    return true
  }
}

// //////////////////////////////////////////////////////////////////////////////
// 
//  ListDevices method request/response protos.
// 
//  Returns information about the TensorFlow devices that are available
//  to this master.
// 
// //////////////////////////////////////////////////////////////////////////////

struct Tensorflow_ListDevicesRequest: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_ListDevicesRequest"}
  public var protoMessageName: String {return "ListDevicesRequest"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [:]}
  public var protoFieldNames: [String: Int] {return [:]}

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return false // Proto3 ignores unknown fields
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_ListDevicesRequest) -> Bool {
    return true
  }
}

struct Tensorflow_ListDevicesResponse: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_ListDevicesResponse"}
  public var protoMessageName: String {return "ListDevicesResponse"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "localDevice": 1,
    "remoteDevice": 2,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "local_device": 1,
    "remote_device": 2,
  ]}

  public var localDevice: [Tensorflow_DeviceAttributes] = []

  public var remoteDevice: [Tensorflow_DeviceAttributes] = []

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeRepeatedMessageField(fieldType: Tensorflow_DeviceAttributes.self, value: &localDevice)
    case 2: handled = try setter.decodeRepeatedMessageField(fieldType: Tensorflow_DeviceAttributes.self, value: &remoteDevice)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if !localDevice.isEmpty {
      try visitor.visitRepeatedMessageField(value: localDevice, protoFieldNumber: 1, protoFieldName: "local_device", jsonFieldName: "localDevice", swiftFieldName: "localDevice")
    }
    if !remoteDevice.isEmpty {
      try visitor.visitRepeatedMessageField(value: remoteDevice, protoFieldNumber: 2, protoFieldName: "remote_device", jsonFieldName: "remoteDevice", swiftFieldName: "remoteDevice")
    }
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_ListDevicesResponse) -> Bool {
    if localDevice != other.localDevice {return false}
    if remoteDevice != other.remoteDevice {return false}
    return true
  }
}
