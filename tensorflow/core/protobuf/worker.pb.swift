/*
 * DO NOT EDIT.
 *
 * Generated by the protocol buffer compiler.
 * Source: tensorflow/core/protobuf/worker.proto
 *
 */

//  Copyright 2016 The TensorFlow Authors. All Rights Reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ==============================================================================

import Foundation
import SwiftProtobuf


// //////////////////////////////////////////////////////////////////////////////
// 
//  GetStatus method request/response messages
// 
// //////////////////////////////////////////////////////////////////////////////

struct Tensorflow_GetStatusRequest: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_GetStatusRequest"}
  public var protoMessageName: String {return "GetStatusRequest"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [:]}
  public var protoFieldNames: [String: Int] {return [:]}

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return false // Proto3 ignores unknown fields
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_GetStatusRequest) -> Bool {
    return true
  }
}

struct Tensorflow_GetStatusResponse: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_GetStatusResponse"}
  public var protoMessageName: String {return "GetStatusResponse"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "deviceAttributes": 1,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "device_attributes": 1,
  ]}

  public var deviceAttributes: [Tensorflow_DeviceAttributes] = []

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeRepeatedMessageField(fieldType: Tensorflow_DeviceAttributes.self, value: &deviceAttributes)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if !deviceAttributes.isEmpty {
      try visitor.visitRepeatedMessageField(value: deviceAttributes, protoFieldNumber: 1, protoFieldName: "device_attributes", jsonFieldName: "deviceAttributes", swiftFieldName: "deviceAttributes")
    }
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_GetStatusResponse) -> Bool {
    if deviceAttributes != other.deviceAttributes {return false}
    return true
  }
}

// //////////////////////////////////////////////////////////////////////////////
// 
//  RegisterGraph method request/response messages
// 
//  For each session, after the master placed every node on a device,
//  it partitions the whole graph into many subgraphs. All the nodes in
//  a subgraph were in the same worker, but potentially on many devices
//  owned by that worker (e.g. cpu0, plus gpu0, gpu1, ..., gpu7). The
//  master registers subgraphs for a worker before running any steps. A
//  successful registration returns a graph handle to be used in latter
//  RunGraph requests.
// 
// //////////////////////////////////////////////////////////////////////////////

struct Tensorflow_RegisterGraphRequest: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_RegisterGraphRequest"}
  public var protoMessageName: String {return "RegisterGraphRequest"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "sessionHandle": 1,
    "graphDef": 2,
    "hasControlFlow": 3,
    "graphOptions": 4,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "session_handle": 1,
    "graph_def": 2,
    "has_control_flow": 3,
    "graph_options": 4,
  ]}

  private class _StorageClass {
    typealias ProtobufExtendedMessage = Tensorflow_RegisterGraphRequest
    var _sessionHandle: String = ""
    var _graphDef: Tensorflow_GraphDef? = nil
    var _hasControlFlow: Bool = false
    var _graphOptions: Tensorflow_GraphOptions? = nil

    init() {}

    func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &_sessionHandle)
      case 2: handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_GraphDef.self, value: &_graphDef)
      case 3: handled = try setter.decodeSingularField(fieldType: ProtobufBool.self, value: &_hasControlFlow)
      case 4: handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_GraphOptions.self, value: &_graphOptions)
      default:
        handled = false
      }
      return handled
    }

    func traverse(visitor: inout ProtobufVisitor) throws {
      if _sessionHandle != "" {
        try visitor.visitSingularField(fieldType: ProtobufString.self, value: _sessionHandle, protoFieldNumber: 1, protoFieldName: "session_handle", jsonFieldName: "sessionHandle", swiftFieldName: "sessionHandle")
      }
      if let v = _graphDef {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 2, protoFieldName: "graph_def", jsonFieldName: "graphDef", swiftFieldName: "graphDef")
      }
      if _hasControlFlow != false {
        try visitor.visitSingularField(fieldType: ProtobufBool.self, value: _hasControlFlow, protoFieldNumber: 3, protoFieldName: "has_control_flow", jsonFieldName: "hasControlFlow", swiftFieldName: "hasControlFlow")
      }
      if let v = _graphOptions {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 4, protoFieldName: "graph_options", jsonFieldName: "graphOptions", swiftFieldName: "graphOptions")
      }
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _sessionHandle != other._sessionHandle {return false}
      if _graphDef != other._graphDef {return false}
      if _hasControlFlow != other._hasControlFlow {return false}
      if _graphOptions != other._graphOptions {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._sessionHandle = _sessionHandle
      clone._graphDef = _graphDef
      clone._hasControlFlow = _hasControlFlow
      clone._graphOptions = _graphOptions
      return clone
    }
  }

  private var _storage = _StorageClass()

  ///   Subgraphs are scoped within one session.
  public var sessionHandle: String {
    get {return _storage._sessionHandle}
    set {_uniqueStorage()._sessionHandle = newValue}
  }

  ///   "graph_def" has the subgraph of nodes for this worker, with each node
  ///   having its device_name filled in.
  public var graphDef: Tensorflow_GraphDef {
    get {return _storage._graphDef ?? Tensorflow_GraphDef()}
    set {_uniqueStorage()._graphDef = newValue}
  }
  public var hasGraphDef: Bool {
    return _storage._graphDef != nil
  }
  public mutating func clearGraphDef() {
    return _storage._graphDef = nil
  }

  ///   True iff the graph (before partitioning) contains control flow nodes.
  ///  
  ///   As of 01/11/2015, this is no longer set by clients.
  public var hasControlFlow: Bool {
    get {return _storage._hasControlFlow}
    set {_uniqueStorage()._hasControlFlow = newValue}
  }

  ///   Configuration options for the session in which this graph was created.
  public var graphOptions: Tensorflow_GraphOptions {
    get {return _storage._graphOptions ?? Tensorflow_GraphOptions()}
    set {_uniqueStorage()._graphOptions = newValue}
  }
  public var hasGraphOptions: Bool {
    return _storage._graphOptions != nil
  }
  public mutating func clearGraphOptions() {
    return _storage._graphOptions = nil
  }

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    try _storage.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_RegisterGraphRequest) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

struct Tensorflow_RegisterGraphResponse: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_RegisterGraphResponse"}
  public var protoMessageName: String {return "RegisterGraphResponse"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "graphHandle": 1,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "graph_handle": 1,
  ]}

  ///   If the registration succeeds, returns an opaque graph_handle to
  ///   the master. The master calls RunGraph with graph_handle to
  ///   compute different steps.
  public var graphHandle: String = ""

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &graphHandle)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if graphHandle != "" {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: graphHandle, protoFieldNumber: 1, protoFieldName: "graph_handle", jsonFieldName: "graphHandle", swiftFieldName: "graphHandle")
    }
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_RegisterGraphResponse) -> Bool {
    if graphHandle != other.graphHandle {return false}
    return true
  }
}

// //////////////////////////////////////////////////////////////////////////////
// 
//  DeregisterGraph method request/response messages
// 
//  The master deregisters the given graph_handle when the graph is no
//  longer needed (e.g., the overall graph is re-scheduled and nodes
//  are re-placed).
// 
//  The worker deregisters a graph_handle automatically according to on
//  a TTL-base policy in case of master restarts.
// 
// //////////////////////////////////////////////////////////////////////////////

struct Tensorflow_DeregisterGraphRequest: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_DeregisterGraphRequest"}
  public var protoMessageName: String {return "DeregisterGraphRequest"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "graphHandle": 1,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "graph_handle": 1,
  ]}

  ///   REQUIRED: graph_handle must be returned by a RegisterGraph call
  ///   to the same WorkerService.
  public var graphHandle: String = ""

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &graphHandle)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if graphHandle != "" {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: graphHandle, protoFieldNumber: 1, protoFieldName: "graph_handle", jsonFieldName: "graphHandle", swiftFieldName: "graphHandle")
    }
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_DeregisterGraphRequest) -> Bool {
    if graphHandle != other.graphHandle {return false}
    return true
  }
}

///   TODO(mrry): Optionally add summary stats for the graph.
struct Tensorflow_DeregisterGraphResponse: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_DeregisterGraphResponse"}
  public var protoMessageName: String {return "DeregisterGraphResponse"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [:]}
  public var protoFieldNames: [String: Int] {return [:]}

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return false // Proto3 ignores unknown fields
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_DeregisterGraphResponse) -> Bool {
    return true
  }
}

// //////////////////////////////////////////////////////////////////////////////
// 
//  CleanupAll method request/response messages
// 
// //////////////////////////////////////////////////////////////////////////////

struct Tensorflow_CleanupAllRequest: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_CleanupAllRequest"}
  public var protoMessageName: String {return "CleanupAllRequest"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "container": 1,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "container": 1,
  ]}

  ///   A list of container names.
  ///  
  ///   If 'container' is not empty, releases resoures in the given
  ///   containers in all devices.
  ///  
  ///   If 'container' is empty, releases resources in the default
  ///   container in all devices.
  public var container: [String] = []

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeRepeatedField(fieldType: ProtobufString.self, value: &container)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if !container.isEmpty {
      try visitor.visitRepeatedField(fieldType: ProtobufString.self, value: container, protoFieldNumber: 1, protoFieldName: "container", jsonFieldName: "container", swiftFieldName: "container")
    }
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_CleanupAllRequest) -> Bool {
    if container != other.container {return false}
    return true
  }
}

struct Tensorflow_CleanupAllResponse: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_CleanupAllResponse"}
  public var protoMessageName: String {return "CleanupAllResponse"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [:]}
  public var protoFieldNames: [String: Int] {return [:]}

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return false // Proto3 ignores unknown fields
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_CleanupAllResponse) -> Bool {
    return true
  }
}

// //////////////////////////////////////////////////////////////////////////////
// 
//  RunGraph request / response messages
// 
//  The worker executes all subgraphs registered under graph_handle.
//  RunGraph returns after the execution finishes or an error is
//  encountered.
//  A sequence of RunGraphRequests with is_partial may be sent to RunGraph for
//  partial graph execution.
// 
// //////////////////////////////////////////////////////////////////////////////

///   A pair of tensor name and tensor values.
struct Tensorflow_NamedTensor: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_NamedTensor"}
  public var protoMessageName: String {return "NamedTensor"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "key": 1,
    "val": 2,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "key": 1,
    "val": 2,
  ]}

  private class _StorageClass {
    typealias ProtobufExtendedMessage = Tensorflow_NamedTensor
    var _key: String = ""
    var _val: Tensorflow_TensorProto? = nil

    init() {}

    func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &_key)
      case 2: handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_TensorProto.self, value: &_val)
      default:
        handled = false
      }
      return handled
    }

    func traverse(visitor: inout ProtobufVisitor) throws {
      if _key != "" {
        try visitor.visitSingularField(fieldType: ProtobufString.self, value: _key, protoFieldNumber: 1, protoFieldName: "key", jsonFieldName: "key", swiftFieldName: "key")
      }
      if let v = _val {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 2, protoFieldName: "val", jsonFieldName: "val", swiftFieldName: "val")
      }
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _key != other._key {return false}
      if _val != other._val {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._key = _key
      clone._val = _val
      return clone
    }
  }

  private var _storage = _StorageClass()

  ///   The name of the named tensor.
  public var key: String {
    get {return _storage._key}
    set {_uniqueStorage()._key = newValue}
  }

  ///   The value of the named tensor.
  public var val: Tensorflow_TensorProto {
    get {return _storage._val ?? Tensorflow_TensorProto()}
    set {_uniqueStorage()._val = newValue}
  }
  public var hasVal: Bool {
    return _storage._val != nil
  }
  public mutating func clearVal() {
    return _storage._val = nil
  }

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    try _storage.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_NamedTensor) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

///   Options specific to the execution of a single step.
struct Tensorflow_ExecutorOpts: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_ExecutorOpts"}
  public var protoMessageName: String {return "ExecutorOpts"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "recordCosts": 1,
    "recordTimeline": 3,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "record_costs": 1,
    "record_timeline": 3,
  ]}

  public var recordCosts: Bool = false

  public var recordTimeline: Bool = false

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeSingularField(fieldType: ProtobufBool.self, value: &recordCosts)
    case 3: handled = try setter.decodeSingularField(fieldType: ProtobufBool.self, value: &recordTimeline)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if recordCosts != false {
      try visitor.visitSingularField(fieldType: ProtobufBool.self, value: recordCosts, protoFieldNumber: 1, protoFieldName: "record_costs", jsonFieldName: "recordCosts", swiftFieldName: "recordCosts")
    }
    if recordTimeline != false {
      try visitor.visitSingularField(fieldType: ProtobufBool.self, value: recordTimeline, protoFieldNumber: 3, protoFieldName: "record_timeline", jsonFieldName: "recordTimeline", swiftFieldName: "recordTimeline")
    }
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_ExecutorOpts) -> Bool {
    if recordCosts != other.recordCosts {return false}
    if recordTimeline != other.recordTimeline {return false}
    return true
  }
}

struct Tensorflow_RunGraphRequest: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_RunGraphRequest"}
  public var protoMessageName: String {return "RunGraphRequest"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "graphHandle": 1,
    "stepId": 2,
    "execOpts": 5,
    "send": 3,
    "recvKey": 4,
    "isPartial": 6,
    "isLastPartialRun": 7,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "graph_handle": 1,
    "step_id": 2,
    "exec_opts": 5,
    "send": 3,
    "recv_key": 4,
    "is_partial": 6,
    "is_last_partial_run": 7,
  ]}

  private class _StorageClass {
    typealias ProtobufExtendedMessage = Tensorflow_RunGraphRequest
    var _graphHandle: String = ""
    var _stepId: Int64 = 0
    var _execOpts: Tensorflow_ExecutorOpts? = nil
    var _send: [Tensorflow_NamedTensor] = []
    var _recvKey: [String] = []
    var _isPartial: Bool = false
    var _isLastPartialRun: Bool = false

    init() {}

    func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &_graphHandle)
      case 2: handled = try setter.decodeSingularField(fieldType: ProtobufInt64.self, value: &_stepId)
      case 5: handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_ExecutorOpts.self, value: &_execOpts)
      case 3: handled = try setter.decodeRepeatedMessageField(fieldType: Tensorflow_NamedTensor.self, value: &_send)
      case 4: handled = try setter.decodeRepeatedField(fieldType: ProtobufString.self, value: &_recvKey)
      case 6: handled = try setter.decodeSingularField(fieldType: ProtobufBool.self, value: &_isPartial)
      case 7: handled = try setter.decodeSingularField(fieldType: ProtobufBool.self, value: &_isLastPartialRun)
      default:
        handled = false
      }
      return handled
    }

    func traverse(visitor: inout ProtobufVisitor) throws {
      if _graphHandle != "" {
        try visitor.visitSingularField(fieldType: ProtobufString.self, value: _graphHandle, protoFieldNumber: 1, protoFieldName: "graph_handle", jsonFieldName: "graphHandle", swiftFieldName: "graphHandle")
      }
      if _stepId != 0 {
        try visitor.visitSingularField(fieldType: ProtobufInt64.self, value: _stepId, protoFieldNumber: 2, protoFieldName: "step_id", jsonFieldName: "stepId", swiftFieldName: "stepId")
      }
      if !_send.isEmpty {
        try visitor.visitRepeatedMessageField(value: _send, protoFieldNumber: 3, protoFieldName: "send", jsonFieldName: "send", swiftFieldName: "send")
      }
      if !_recvKey.isEmpty {
        try visitor.visitRepeatedField(fieldType: ProtobufString.self, value: _recvKey, protoFieldNumber: 4, protoFieldName: "recv_key", jsonFieldName: "recvKey", swiftFieldName: "recvKey")
      }
      if let v = _execOpts {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 5, protoFieldName: "exec_opts", jsonFieldName: "execOpts", swiftFieldName: "execOpts")
      }
      if _isPartial != false {
        try visitor.visitSingularField(fieldType: ProtobufBool.self, value: _isPartial, protoFieldNumber: 6, protoFieldName: "is_partial", jsonFieldName: "isPartial", swiftFieldName: "isPartial")
      }
      if _isLastPartialRun != false {
        try visitor.visitSingularField(fieldType: ProtobufBool.self, value: _isLastPartialRun, protoFieldNumber: 7, protoFieldName: "is_last_partial_run", jsonFieldName: "isLastPartialRun", swiftFieldName: "isLastPartialRun")
      }
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _graphHandle != other._graphHandle {return false}
      if _stepId != other._stepId {return false}
      if _execOpts != other._execOpts {return false}
      if _send != other._send {return false}
      if _recvKey != other._recvKey {return false}
      if _isPartial != other._isPartial {return false}
      if _isLastPartialRun != other._isLastPartialRun {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._graphHandle = _graphHandle
      clone._stepId = _stepId
      clone._execOpts = _execOpts
      clone._send = _send
      clone._recvKey = _recvKey
      clone._isPartial = _isPartial
      clone._isLastPartialRun = _isLastPartialRun
      return clone
    }
  }

  private var _storage = _StorageClass()

  ///   REQUIRED: graph_handle must be returned by a RegisterGraph call
  ///   to the same WorkerService.
  public var graphHandle: String {
    get {return _storage._graphHandle}
    set {_uniqueStorage()._graphHandle = newValue}
  }

  ///   A unique ID to distinguish different runs of the same graph.
  ///  
  ///   The master generates a global unique `step_id` to distinguish
  ///   different runs of the graph computation. Subgraphs communicate
  ///   (e.g., send/recv ops) with each other using `step_id` to
  ///   distinguish tensors generated by different runs.
  public var stepId: Int64 {
    get {return _storage._stepId}
    set {_uniqueStorage()._stepId = newValue}
  }

  ///   Options for this step.
  public var execOpts: Tensorflow_ExecutorOpts {
    get {return _storage._execOpts ?? Tensorflow_ExecutorOpts()}
    set {_uniqueStorage()._execOpts = newValue}
  }
  public var hasExecOpts: Bool {
    return _storage._execOpts != nil
  }
  public mutating func clearExecOpts() {
    return _storage._execOpts = nil
  }

  ///   Runs the graph.
  ///  
  ///   Sends the tensors in "send" into the graph before the run and
  ///   fetches the keys into `RunGraphResponse.recv` after the run.
  public var send: [Tensorflow_NamedTensor] {
    get {return _storage._send}
    set {_uniqueStorage()._send = newValue}
  }

  public var recvKey: [String] {
    get {return _storage._recvKey}
    set {_uniqueStorage()._recvKey = newValue}
  }

  ///   True if the RunGraphRequest is a partial run request.
  public var isPartial: Bool {
    get {return _storage._isPartial}
    set {_uniqueStorage()._isPartial = newValue}
  }

  ///   True if this is the last partial run request in a sequence of requests.
  public var isLastPartialRun: Bool {
    get {return _storage._isLastPartialRun}
    set {_uniqueStorage()._isLastPartialRun = newValue}
  }

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    try _storage.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_RunGraphRequest) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

struct Tensorflow_RunGraphResponse: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_RunGraphResponse"}
  public var protoMessageName: String {return "RunGraphResponse"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "recv": 1,
    "stepStats": 2,
    "costGraph": 3,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "recv": 1,
    "step_stats": 2,
    "cost_graph": 3,
  ]}

  private class _StorageClass {
    typealias ProtobufExtendedMessage = Tensorflow_RunGraphResponse
    var _recv: [Tensorflow_NamedTensor] = []
    var _stepStats: Tensorflow_StepStats? = nil
    var _costGraph: Tensorflow_CostGraphDef? = nil

    init() {}

    func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodeRepeatedMessageField(fieldType: Tensorflow_NamedTensor.self, value: &_recv)
      case 2: handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_StepStats.self, value: &_stepStats)
      case 3: handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_CostGraphDef.self, value: &_costGraph)
      default:
        handled = false
      }
      return handled
    }

    func traverse(visitor: inout ProtobufVisitor) throws {
      if !_recv.isEmpty {
        try visitor.visitRepeatedMessageField(value: _recv, protoFieldNumber: 1, protoFieldName: "recv", jsonFieldName: "recv", swiftFieldName: "recv")
      }
      if let v = _stepStats {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 2, protoFieldName: "step_stats", jsonFieldName: "stepStats", swiftFieldName: "stepStats")
      }
      if let v = _costGraph {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 3, protoFieldName: "cost_graph", jsonFieldName: "costGraph", swiftFieldName: "costGraph")
      }
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _recv != other._recv {return false}
      if _stepStats != other._stepStats {return false}
      if _costGraph != other._costGraph {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._recv = _recv
      clone._stepStats = _stepStats
      clone._costGraph = _costGraph
      return clone
    }
  }

  private var _storage = _StorageClass()

  ///   A list of tensors corresponding to those requested by
  ///   `RunGraphRequest.recv_key`.
  public var recv: [Tensorflow_NamedTensor] {
    get {return _storage._recv}
    set {_uniqueStorage()._recv = newValue}
  }

  ///   If the request asked for execution stats or cost graph, these are returned
  ///   here.
  public var stepStats: Tensorflow_StepStats {
    get {return _storage._stepStats ?? Tensorflow_StepStats()}
    set {_uniqueStorage()._stepStats = newValue}
  }
  public var hasStepStats: Bool {
    return _storage._stepStats != nil
  }
  public mutating func clearStepStats() {
    return _storage._stepStats = nil
  }

  public var costGraph: Tensorflow_CostGraphDef {
    get {return _storage._costGraph ?? Tensorflow_CostGraphDef()}
    set {_uniqueStorage()._costGraph = newValue}
  }
  public var hasCostGraph: Bool {
    return _storage._costGraph != nil
  }
  public mutating func clearCostGraph() {
    return _storage._costGraph = nil
  }

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    try _storage.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_RunGraphResponse) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

// //////////////////////////////////////////////////////////////////////////////
// 
//  CleanupGraph method request/response messages
// 
//  After the master receives RunGraph responses from all workers, the
//  master instructs every worker to cleanup any remaining state of a
//  step (e.g. tensors buffered by a `Send` op but not picked up by
//  other workers). The master does not necessarily need to wait for
//  completion of CleanupGraph calls.
// 
//  Workers should cleanup step states automatically according to a
//  TTL-based policy in case of master restarts.
// 
// //////////////////////////////////////////////////////////////////////////////

struct Tensorflow_CleanupGraphRequest: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_CleanupGraphRequest"}
  public var protoMessageName: String {return "CleanupGraphRequest"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "stepId": 1,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "step_id": 1,
  ]}

  public var stepId: Int64 = 0

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeSingularField(fieldType: ProtobufInt64.self, value: &stepId)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if stepId != 0 {
      try visitor.visitSingularField(fieldType: ProtobufInt64.self, value: stepId, protoFieldNumber: 1, protoFieldName: "step_id", jsonFieldName: "stepId", swiftFieldName: "stepId")
    }
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_CleanupGraphRequest) -> Bool {
    if stepId != other.stepId {return false}
    return true
  }
}

struct Tensorflow_CleanupGraphResponse: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_CleanupGraphResponse"}
  public var protoMessageName: String {return "CleanupGraphResponse"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [:]}
  public var protoFieldNames: [String: Int] {return [:]}

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return false // Proto3 ignores unknown fields
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_CleanupGraphResponse) -> Bool {
    return true
  }
}

// //////////////////////////////////////////////////////////////////////////////
// 
//  RecvTensor method request/response messages
// 
// //////////////////////////////////////////////////////////////////////////////

struct Tensorflow_RecvTensorRequest: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_RecvTensorRequest"}
  public var protoMessageName: String {return "RecvTensorRequest"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "stepId": 1,
    "rendezvousKey": 2,
    "dmaOk": 3,
    "clientLocality": 4,
    "serverLocality": 5,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "step_id": 1,
    "rendezvous_key": 2,
    "dma_ok": 3,
    "client_locality": 4,
    "server_locality": 5,
  ]}

  private class _StorageClass {
    typealias ProtobufExtendedMessage = Tensorflow_RecvTensorRequest
    var _stepId: Int64 = 0
    var _rendezvousKey: String = ""
    var _dmaOk: Bool = false
    var _clientLocality: Tensorflow_DeviceLocality? = nil
    var _serverLocality: Tensorflow_DeviceLocality? = nil

    init() {}

    func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodeSingularField(fieldType: ProtobufInt64.self, value: &_stepId)
      case 2: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &_rendezvousKey)
      case 3: handled = try setter.decodeSingularField(fieldType: ProtobufBool.self, value: &_dmaOk)
      case 4: handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_DeviceLocality.self, value: &_clientLocality)
      case 5: handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_DeviceLocality.self, value: &_serverLocality)
      default:
        handled = false
      }
      return handled
    }

    func traverse(visitor: inout ProtobufVisitor) throws {
      if _stepId != 0 {
        try visitor.visitSingularField(fieldType: ProtobufInt64.self, value: _stepId, protoFieldNumber: 1, protoFieldName: "step_id", jsonFieldName: "stepId", swiftFieldName: "stepId")
      }
      if _rendezvousKey != "" {
        try visitor.visitSingularField(fieldType: ProtobufString.self, value: _rendezvousKey, protoFieldNumber: 2, protoFieldName: "rendezvous_key", jsonFieldName: "rendezvousKey", swiftFieldName: "rendezvousKey")
      }
      if _dmaOk != false {
        try visitor.visitSingularField(fieldType: ProtobufBool.self, value: _dmaOk, protoFieldNumber: 3, protoFieldName: "dma_ok", jsonFieldName: "dmaOk", swiftFieldName: "dmaOk")
      }
      if let v = _clientLocality {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 4, protoFieldName: "client_locality", jsonFieldName: "clientLocality", swiftFieldName: "clientLocality")
      }
      if let v = _serverLocality {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 5, protoFieldName: "server_locality", jsonFieldName: "serverLocality", swiftFieldName: "serverLocality")
      }
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _stepId != other._stepId {return false}
      if _rendezvousKey != other._rendezvousKey {return false}
      if _dmaOk != other._dmaOk {return false}
      if _clientLocality != other._clientLocality {return false}
      if _serverLocality != other._serverLocality {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._stepId = _stepId
      clone._rendezvousKey = _rendezvousKey
      clone._dmaOk = _dmaOk
      clone._clientLocality = _clientLocality
      clone._serverLocality = _serverLocality
      return clone
    }
  }

  private var _storage = _StorageClass()

  ///   The step in which the tensor will be produced.
  ///  
  ///   REQUIRED: This must eventually correspond to the `step_id` passed
  ///   into a RunGraph call on the same WorkerService.
  public var stepId: Int64 {
    get {return _storage._stepId}
    set {_uniqueStorage()._stepId = newValue}
  }

  ///   A key that identifies the tensor to be received.
  public var rendezvousKey: String {
    get {return _storage._rendezvousKey}
    set {_uniqueStorage()._rendezvousKey = newValue}
  }

  ///   If true, use an out-of-band DMA mechanism to transfer the
  ///   received tensor.
  public var dmaOk: Bool {
    get {return _storage._dmaOk}
    set {_uniqueStorage()._dmaOk = newValue}
  }

  ///   Optional information on client-side device locality.
  public var clientLocality: Tensorflow_DeviceLocality {
    get {return _storage._clientLocality ?? Tensorflow_DeviceLocality()}
    set {_uniqueStorage()._clientLocality = newValue}
  }
  public var hasClientLocality: Bool {
    return _storage._clientLocality != nil
  }
  public mutating func clearClientLocality() {
    return _storage._clientLocality = nil
  }

  ///   Optional information on server-side device locality.
  public var serverLocality: Tensorflow_DeviceLocality {
    get {return _storage._serverLocality ?? Tensorflow_DeviceLocality()}
    set {_uniqueStorage()._serverLocality = newValue}
  }
  public var hasServerLocality: Bool {
    return _storage._serverLocality != nil
  }
  public mutating func clearServerLocality() {
    return _storage._serverLocality = nil
  }

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    try _storage.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_RecvTensorRequest) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

struct Tensorflow_RecvTensorResponse: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_RecvTensorResponse"}
  public var protoMessageName: String {return "RecvTensorResponse"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "tensor": 1,
    "isDead": 2,
    "sendStartMicros": 3,
    "transportOptions": 4,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "tensor": 1,
    "is_dead": 2,
    "send_start_micros": 3,
    "transport_options": 4,
  ]}

  private class _StorageClass {
    typealias ProtobufExtendedMessage = Tensorflow_RecvTensorResponse
    var _tensor: Tensorflow_TensorProto? = nil
    var _isDead: Bool = false
    var _sendStartMicros: Int64 = 0
    var _transportOptions: Google_Protobuf_Any? = nil

    init() {}

    func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_TensorProto.self, value: &_tensor)
      case 2: handled = try setter.decodeSingularField(fieldType: ProtobufBool.self, value: &_isDead)
      case 3: handled = try setter.decodeSingularField(fieldType: ProtobufInt64.self, value: &_sendStartMicros)
      case 4: handled = try setter.decodeSingularMessageField(fieldType: Google_Protobuf_Any.self, value: &_transportOptions)
      default:
        handled = false
      }
      return handled
    }

    func traverse(visitor: inout ProtobufVisitor) throws {
      if let v = _tensor {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 1, protoFieldName: "tensor", jsonFieldName: "tensor", swiftFieldName: "tensor")
      }
      if _isDead != false {
        try visitor.visitSingularField(fieldType: ProtobufBool.self, value: _isDead, protoFieldNumber: 2, protoFieldName: "is_dead", jsonFieldName: "isDead", swiftFieldName: "isDead")
      }
      if _sendStartMicros != 0 {
        try visitor.visitSingularField(fieldType: ProtobufInt64.self, value: _sendStartMicros, protoFieldNumber: 3, protoFieldName: "send_start_micros", jsonFieldName: "sendStartMicros", swiftFieldName: "sendStartMicros")
      }
      if let v = _transportOptions {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 4, protoFieldName: "transport_options", jsonFieldName: "transportOptions", swiftFieldName: "transportOptions")
      }
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _tensor != other._tensor {return false}
      if _isDead != other._isDead {return false}
      if _sendStartMicros != other._sendStartMicros {return false}
      if _transportOptions != other._transportOptions {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._tensor = _tensor
      clone._isDead = _isDead
      clone._sendStartMicros = _sendStartMicros
      clone._transportOptions = _transportOptions
      return clone
    }
  }

  private var _storage = _StorageClass()

  ///   The tensor as a proto.
  public var tensor: Tensorflow_TensorProto {
    get {return _storage._tensor ?? Tensorflow_TensorProto()}
    set {_uniqueStorage()._tensor = newValue}
  }
  public var hasTensor: Bool {
    return _storage._tensor != nil
  }
  public mutating func clearTensor() {
    return _storage._tensor = nil
  }

  ///   If true, this tensor was the output of a dead node, and the
  ///   content is invalid.
  public var isDead: Bool {
    get {return _storage._isDead}
    set {_uniqueStorage()._isDead = newValue}
  }

  ///   The time at which tensor was available and started to be returned.
  public var sendStartMicros: Int64 {
    get {return _storage._sendStartMicros}
    set {_uniqueStorage()._sendStartMicros = newValue}
  }

  ///   Optional additional information about how to receive the tensor,
  ///   in the event that `RecvTensorRequest.dma_ok` was true.
  public var transportOptions: Google_Protobuf_Any {
    get {return _storage._transportOptions ?? Google_Protobuf_Any()}
    set {_uniqueStorage()._transportOptions = newValue}
  }
  public var hasTransportOptions: Bool {
    return _storage._transportOptions != nil
  }
  public mutating func clearTransportOptions() {
    return _storage._transportOptions = nil
  }

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    try _storage.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_RecvTensorResponse) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

// //////////////////////////////////////////////////////////////////////////////
// 
//  Logging method request/response messages
// 
//  NOTE(mrry): This feature is not supported in the open-source
//  version, and these messages are expected to change.
// 
// //////////////////////////////////////////////////////////////////////////////

///   Out-of-band request to begin or end logging, or
///   to retrieve logs for particular steps.
struct Tensorflow_LoggingRequest: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_LoggingRequest"}
  public var protoMessageName: String {return "LoggingRequest"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "rpcLogging": 1,
    "clear": 2,
    "fetchStepId": 3,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "rpc_logging": 1,
    "clear": 2,
    "fetch_step_id": 3,
  ]}

  ///   If true, RPC logging will be activated.
  public var rpcLogging: Bool = false

  ///   If true, discard any saved logging data (for all steps).
  public var clear: Bool = false

  ///   When set, requests all saved log data pertaining to the step.
  ///   Any log data retrieved is eliminated from the store and cannot be
  ///   retrieved again.
  public var fetchStepId: [Int64] = []

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeSingularField(fieldType: ProtobufBool.self, value: &rpcLogging)
    case 2: handled = try setter.decodeSingularField(fieldType: ProtobufBool.self, value: &clear)
    case 3: handled = try setter.decodePackedField(fieldType: ProtobufInt64.self, value: &fetchStepId)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if rpcLogging != false {
      try visitor.visitSingularField(fieldType: ProtobufBool.self, value: rpcLogging, protoFieldNumber: 1, protoFieldName: "rpc_logging", jsonFieldName: "rpcLogging", swiftFieldName: "rpcLogging")
    }
    if clear != false {
      try visitor.visitSingularField(fieldType: ProtobufBool.self, value: clear, protoFieldNumber: 2, protoFieldName: "clear", jsonFieldName: "clear", swiftFieldName: "clear")
    }
    if !fetchStepId.isEmpty {
      try visitor.visitPackedField(fieldType: ProtobufInt64.self, value: fetchStepId, protoFieldNumber: 3, protoFieldName: "fetch_step_id", jsonFieldName: "fetchStepId", swiftFieldName: "fetchStepId")
    }
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_LoggingRequest) -> Bool {
    if rpcLogging != other.rpcLogging {return false}
    if clear != other.clear {return false}
    if fetchStepId != other.fetchStepId {return false}
    return true
  }
}

struct Tensorflow_LabeledStepStats: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_LabeledStepStats"}
  public var protoMessageName: String {return "LabeledStepStats"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "stepId": 1,
    "stepStats": 2,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "step_id": 1,
    "step_stats": 2,
  ]}

  private class _StorageClass {
    typealias ProtobufExtendedMessage = Tensorflow_LabeledStepStats
    var _stepId: Int64 = 0
    var _stepStats: Tensorflow_StepStats? = nil

    init() {}

    func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodeSingularField(fieldType: ProtobufInt64.self, value: &_stepId)
      case 2: handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_StepStats.self, value: &_stepStats)
      default:
        handled = false
      }
      return handled
    }

    func traverse(visitor: inout ProtobufVisitor) throws {
      if _stepId != 0 {
        try visitor.visitSingularField(fieldType: ProtobufInt64.self, value: _stepId, protoFieldNumber: 1, protoFieldName: "step_id", jsonFieldName: "stepId", swiftFieldName: "stepId")
      }
      if let v = _stepStats {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 2, protoFieldName: "step_stats", jsonFieldName: "stepStats", swiftFieldName: "stepStats")
      }
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _stepId != other._stepId {return false}
      if _stepStats != other._stepStats {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._stepId = _stepId
      clone._stepStats = _stepStats
      return clone
    }
  }

  private var _storage = _StorageClass()

  public var stepId: Int64 {
    get {return _storage._stepId}
    set {_uniqueStorage()._stepId = newValue}
  }

  public var stepStats: Tensorflow_StepStats {
    get {return _storage._stepStats ?? Tensorflow_StepStats()}
    set {_uniqueStorage()._stepStats = newValue}
  }
  public var hasStepStats: Bool {
    return _storage._stepStats != nil
  }
  public mutating func clearStepStats() {
    return _storage._stepStats = nil
  }

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    try _storage.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_LabeledStepStats) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

struct Tensorflow_LoggingResponse: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_LoggingResponse"}
  public var protoMessageName: String {return "LoggingResponse"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "step": 1,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "step": 1,
  ]}

  public var step: [Tensorflow_LabeledStepStats] = []

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeRepeatedMessageField(fieldType: Tensorflow_LabeledStepStats.self, value: &step)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if !step.isEmpty {
      try visitor.visitRepeatedMessageField(value: step, protoFieldNumber: 1, protoFieldName: "step", jsonFieldName: "step", swiftFieldName: "step")
    }
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_LoggingResponse) -> Bool {
    if step != other.step {return false}
    return true
  }
}

// //////////////////////////////////////////////////////////////////////////////
// 
//  Tracing method request/response messages
// 
//  NOTE(mrry): This feature is not supported in the open-source
//  version, and these messages are expected to change.
// 
// //////////////////////////////////////////////////////////////////////////////

struct Tensorflow_TraceOpts: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_TraceOpts"}
  public var protoMessageName: String {return "TraceOpts"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "duration": 1,
    "useStepProfiler": 2,
    "useKernelProfiler": 3,
    "useExtendedProfiler": 4,
    "useGpuProfiler": 5,
    "useSampleProfiler": 6,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "duration": 1,
    "use_step_profiler": 2,
    "use_kernel_profiler": 3,
    "use_extended_profiler": 4,
    "use_gpu_profiler": 5,
    "use_sample_profiler": 6,
  ]}

  ///   Length of the trace to be taken, in seconds.
  public var duration: Double = 0

  ///   If true, capture step profile locally in each worker. Currently
  ///   unimplemented.
  public var useStepProfiler: Bool = false

  ///   If true, capture kernel events from each worker.
  public var useKernelProfiler: Bool = false

  ///   If true, capture extended profiling events from TensorFlow process.
  public var useExtendedProfiler: Bool = false

  ///   If true, capture GPU profiling events locally on each
  ///   machine. Currently unimplemented.
  public var useGpuProfiler: Bool = false

  ///   If true, collect sampled profile events. Currently unimplemented.
  public var useSampleProfiler: Bool = false

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeSingularField(fieldType: ProtobufDouble.self, value: &duration)
    case 2: handled = try setter.decodeSingularField(fieldType: ProtobufBool.self, value: &useStepProfiler)
    case 3: handled = try setter.decodeSingularField(fieldType: ProtobufBool.self, value: &useKernelProfiler)
    case 4: handled = try setter.decodeSingularField(fieldType: ProtobufBool.self, value: &useExtendedProfiler)
    case 5: handled = try setter.decodeSingularField(fieldType: ProtobufBool.self, value: &useGpuProfiler)
    case 6: handled = try setter.decodeSingularField(fieldType: ProtobufBool.self, value: &useSampleProfiler)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if duration != 0 {
      try visitor.visitSingularField(fieldType: ProtobufDouble.self, value: duration, protoFieldNumber: 1, protoFieldName: "duration", jsonFieldName: "duration", swiftFieldName: "duration")
    }
    if useStepProfiler != false {
      try visitor.visitSingularField(fieldType: ProtobufBool.self, value: useStepProfiler, protoFieldNumber: 2, protoFieldName: "use_step_profiler", jsonFieldName: "useStepProfiler", swiftFieldName: "useStepProfiler")
    }
    if useKernelProfiler != false {
      try visitor.visitSingularField(fieldType: ProtobufBool.self, value: useKernelProfiler, protoFieldNumber: 3, protoFieldName: "use_kernel_profiler", jsonFieldName: "useKernelProfiler", swiftFieldName: "useKernelProfiler")
    }
    if useExtendedProfiler != false {
      try visitor.visitSingularField(fieldType: ProtobufBool.self, value: useExtendedProfiler, protoFieldNumber: 4, protoFieldName: "use_extended_profiler", jsonFieldName: "useExtendedProfiler", swiftFieldName: "useExtendedProfiler")
    }
    if useGpuProfiler != false {
      try visitor.visitSingularField(fieldType: ProtobufBool.self, value: useGpuProfiler, protoFieldNumber: 5, protoFieldName: "use_gpu_profiler", jsonFieldName: "useGpuProfiler", swiftFieldName: "useGpuProfiler")
    }
    if useSampleProfiler != false {
      try visitor.visitSingularField(fieldType: ProtobufBool.self, value: useSampleProfiler, protoFieldNumber: 6, protoFieldName: "use_sample_profiler", jsonFieldName: "useSampleProfiler", swiftFieldName: "useSampleProfiler")
    }
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_TraceOpts) -> Bool {
    if duration != other.duration {return false}
    if useStepProfiler != other.useStepProfiler {return false}
    if useKernelProfiler != other.useKernelProfiler {return false}
    if useExtendedProfiler != other.useExtendedProfiler {return false}
    if useGpuProfiler != other.useGpuProfiler {return false}
    if useSampleProfiler != other.useSampleProfiler {return false}
    return true
  }
}

///   Out-of-band request to configure distributed tracing.
struct Tensorflow_TracingRequest: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_TracingRequest"}
  public var protoMessageName: String {return "TracingRequest"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "options": 1,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "options": 1,
  ]}

  private class _StorageClass {
    typealias ProtobufExtendedMessage = Tensorflow_TracingRequest
    var _options: Tensorflow_TraceOpts? = nil

    init() {}

    func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_TraceOpts.self, value: &_options)
      default:
        handled = false
      }
      return handled
    }

    func traverse(visitor: inout ProtobufVisitor) throws {
      if let v = _options {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 1, protoFieldName: "options", jsonFieldName: "options", swiftFieldName: "options")
      }
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _options != other._options {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._options = _options
      return clone
    }
  }

  private var _storage = _StorageClass()

  public var options: Tensorflow_TraceOpts {
    get {return _storage._options ?? Tensorflow_TraceOpts()}
    set {_uniqueStorage()._options = newValue}
  }
  public var hasOptions: Bool {
    return _storage._options != nil
  }
  public mutating func clearOptions() {
    return _storage._options = nil
  }

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    try _storage.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_TracingRequest) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

struct Tensorflow_TracingResponse: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_TracingResponse"}
  public var protoMessageName: String {return "TracingResponse"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [:]}
  public var protoFieldNames: [String: Int] {return [:]}

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return false // Proto3 ignores unknown fields
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_TracingResponse) -> Bool {
    return true
  }
}
