/*
 * DO NOT EDIT.
 *
 * Generated by the protocol buffer compiler.
 * Source: tensorflow/core/protobuf/config.proto
 *
 */

import Foundation
import SwiftProtobuf


struct Tensorflow_GPUOptions: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_GPUOptions"}
  public var protoMessageName: String {return "GPUOptions"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "perProcessGpuMemoryFraction": 1,
    "allocatorType": 2,
    "deferredDeletionBytes": 3,
    "allowGrowth": 4,
    "visibleDeviceList": 5,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "per_process_gpu_memory_fraction": 1,
    "allocator_type": 2,
    "deferred_deletion_bytes": 3,
    "allow_growth": 4,
    "visible_device_list": 5,
  ]}

  ///   A value between 0 and 1 that indicates what fraction of the
  ///   available GPU memory to pre-allocate for each process.  1 means
  ///   to pre-allocate all of the GPU memory, 0.5 means the process
  ///   allocates ~50% of the available GPU memory.
  public var perProcessGpuMemoryFraction: Double = 0

  ///   The type of GPU allocation strategy to use.
  ///  
  ///   Allowed values:
  ///   "": The empty string (default) uses a system-chosen default
  ///       which may change over time.
  ///  
  ///   "BFC": A "Best-fit with coalescing" algorithm, simplified from a
  ///          version of dlmalloc.
  public var allocatorType: String = ""

  ///   Delay deletion of up to this many bytes to reduce the number of
  ///   interactions with gpu driver code.  If 0, the system chooses
  ///   a reasonable default (several MBs).
  public var deferredDeletionBytes: Int64 = 0

  ///   If true, the allocator does not pre-allocate the entire specified
  ///   GPU memory region, instead starting small and growing as needed.
  public var allowGrowth: Bool = false

  ///   A comma-separated list of GPU ids that determines the 'visible'
  ///   to 'virtual' mapping of GPU devices.  For example, if TensorFlow
  ///   can see 8 GPU devices in the process, and one wanted to map
  ///   visible GPU devices 5 and 3 as "/gpu:0", and "/gpu:1", then one
  ///   would specify this field as "5,3".  This field is similar in
  ///   spirit to the CUDA_VISIBLE_DEVICES environment variable, except
  ///   it applies to the visible GPU devices in the process.
  ///  
  ///   NOTE: The GPU driver provides the process with the visible GPUs
  ///   in an order which is not guaranteed to have any correlation to
  ///   the *physical* GPU id in the machine.  This field is used for
  ///   remapping "visible" to "virtual", which means this operates only
  ///   after the process starts.  Users are required to use vendor
  ///   specific mechanisms (e.g., CUDA_VISIBLE_DEVICES) to control the
  ///   physical to visible device mapping prior to invoking TensorFlow.
  public var visibleDeviceList: String = ""

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeSingularField(fieldType: ProtobufDouble.self, value: &perProcessGpuMemoryFraction)
    case 2: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &allocatorType)
    case 3: handled = try setter.decodeSingularField(fieldType: ProtobufInt64.self, value: &deferredDeletionBytes)
    case 4: handled = try setter.decodeSingularField(fieldType: ProtobufBool.self, value: &allowGrowth)
    case 5: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &visibleDeviceList)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if perProcessGpuMemoryFraction != 0 {
      try visitor.visitSingularField(fieldType: ProtobufDouble.self, value: perProcessGpuMemoryFraction, protoFieldNumber: 1, protoFieldName: "per_process_gpu_memory_fraction", jsonFieldName: "perProcessGpuMemoryFraction", swiftFieldName: "perProcessGpuMemoryFraction")
    }
    if allocatorType != "" {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: allocatorType, protoFieldNumber: 2, protoFieldName: "allocator_type", jsonFieldName: "allocatorType", swiftFieldName: "allocatorType")
    }
    if deferredDeletionBytes != 0 {
      try visitor.visitSingularField(fieldType: ProtobufInt64.self, value: deferredDeletionBytes, protoFieldNumber: 3, protoFieldName: "deferred_deletion_bytes", jsonFieldName: "deferredDeletionBytes", swiftFieldName: "deferredDeletionBytes")
    }
    if allowGrowth != false {
      try visitor.visitSingularField(fieldType: ProtobufBool.self, value: allowGrowth, protoFieldNumber: 4, protoFieldName: "allow_growth", jsonFieldName: "allowGrowth", swiftFieldName: "allowGrowth")
    }
    if visibleDeviceList != "" {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: visibleDeviceList, protoFieldNumber: 5, protoFieldName: "visible_device_list", jsonFieldName: "visibleDeviceList", swiftFieldName: "visibleDeviceList")
    }
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_GPUOptions) -> Bool {
    if perProcessGpuMemoryFraction != other.perProcessGpuMemoryFraction {return false}
    if allocatorType != other.allocatorType {return false}
    if deferredDeletionBytes != other.deferredDeletionBytes {return false}
    if allowGrowth != other.allowGrowth {return false}
    if visibleDeviceList != other.visibleDeviceList {return false}
    return true
  }
}

///   Options passed to the graph optimizer
struct Tensorflow_OptimizerOptions: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_OptimizerOptions"}
  public var protoMessageName: String {return "OptimizerOptions"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "doCommonSubexpressionElimination": 1,
    "doConstantFolding": 2,
    "doFunctionInlining": 4,
    "optLevel": 3,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "do_common_subexpression_elimination": 1,
    "do_constant_folding": 2,
    "do_function_inlining": 4,
    "opt_level": 3,
  ]}

  ///   Optimization level
  enum Level: ProtobufEnum {
    public typealias RawValue = Int

    ///   L1 is the default level.
    ///   Optimization performed at L1 :
    ///   1. Common subexpression elimination
    ///   2. Constant folding
    case l1 // = 0

    ///   No optimizations
    case l0 // = -1
    case UNRECOGNIZED(Int)

    public init() {
      self = .l1
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .l1
      case -1: self = .l0
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public init?(name: String) {
      switch name {
      case "l1": self = .l1
      case "l0": self = .l0
      default: return nil
      }
    }

    public init?(jsonName: String) {
      switch jsonName {
      case "L1": self = .l1
      case "L0": self = .l0
      default: return nil
      }
    }

    public init?(protoName: String) {
      switch protoName {
      case "L1": self = .l1
      case "L0": self = .l0
      default: return nil
      }
    }

    public var rawValue: Int {
      get {
        switch self {
        case .l1: return 0
        case .l0: return -1
        case .UNRECOGNIZED(let i): return i
        }
      }
    }

    public var json: String {
      get {
        switch self {
        case .l1: return "\"L1\""
        case .l0: return "\"L0\""
        case .UNRECOGNIZED(let i): return String(i)
        }
      }
    }

    public var hashValue: Int { return rawValue }

    public var debugDescription: String {
      get {
        switch self {
        case .l1: return ".l1"
        case .l0: return ".l0"
        case .UNRECOGNIZED(let v): return ".UNRECOGNIZED(\(v))"
        }
      }
    }

  }

  ///   If true, optimize the graph using common subexpression elimination.
  public var doCommonSubexpressionElimination: Bool = false

  ///   If true, perform constant folding optimization on the graph.
  public var doConstantFolding: Bool = false

  ///   If true, perform function inlining on the graph.
  public var doFunctionInlining: Bool = false

  public var optLevel: Tensorflow_OptimizerOptions.Level = Tensorflow_OptimizerOptions.Level.l1

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeSingularField(fieldType: ProtobufBool.self, value: &doCommonSubexpressionElimination)
    case 2: handled = try setter.decodeSingularField(fieldType: ProtobufBool.self, value: &doConstantFolding)
    case 4: handled = try setter.decodeSingularField(fieldType: ProtobufBool.self, value: &doFunctionInlining)
    case 3: handled = try setter.decodeSingularField(fieldType: Tensorflow_OptimizerOptions.Level.self, value: &optLevel)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if doCommonSubexpressionElimination != false {
      try visitor.visitSingularField(fieldType: ProtobufBool.self, value: doCommonSubexpressionElimination, protoFieldNumber: 1, protoFieldName: "do_common_subexpression_elimination", jsonFieldName: "doCommonSubexpressionElimination", swiftFieldName: "doCommonSubexpressionElimination")
    }
    if doConstantFolding != false {
      try visitor.visitSingularField(fieldType: ProtobufBool.self, value: doConstantFolding, protoFieldNumber: 2, protoFieldName: "do_constant_folding", jsonFieldName: "doConstantFolding", swiftFieldName: "doConstantFolding")
    }
    if optLevel != Tensorflow_OptimizerOptions.Level.l1 {
      try visitor.visitSingularField(fieldType: Tensorflow_OptimizerOptions.Level.self, value: optLevel, protoFieldNumber: 3, protoFieldName: "opt_level", jsonFieldName: "optLevel", swiftFieldName: "optLevel")
    }
    if doFunctionInlining != false {
      try visitor.visitSingularField(fieldType: ProtobufBool.self, value: doFunctionInlining, protoFieldNumber: 4, protoFieldName: "do_function_inlining", jsonFieldName: "doFunctionInlining", swiftFieldName: "doFunctionInlining")
    }
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_OptimizerOptions) -> Bool {
    if doCommonSubexpressionElimination != other.doCommonSubexpressionElimination {return false}
    if doConstantFolding != other.doConstantFolding {return false}
    if doFunctionInlining != other.doFunctionInlining {return false}
    if optLevel != other.optLevel {return false}
    return true
  }
}

struct Tensorflow_GraphOptions: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_GraphOptions"}
  public var protoMessageName: String {return "GraphOptions"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "enableRecvScheduling": 2,
    "optimizerOptions": 3,
    "buildCostModel": 4,
    "buildCostModelAfter": 9,
    "inferShapes": 5,
    "placePrunedGraph": 6,
    "enableBfloat16Sendrecv": 7,
    "timelineStep": 8,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "enable_recv_scheduling": 2,
    "optimizer_options": 3,
    "build_cost_model": 4,
    "build_cost_model_after": 9,
    "infer_shapes": 5,
    "place_pruned_graph": 6,
    "enable_bfloat16_sendrecv": 7,
    "timeline_step": 8,
  ]}

  private class _StorageClass {
    typealias ProtobufExtendedMessage = Tensorflow_GraphOptions
    var _enableRecvScheduling: Bool = false
    var _optimizerOptions: Tensorflow_OptimizerOptions? = nil
    var _buildCostModel: Int64 = 0
    var _buildCostModelAfter: Int64 = 0
    var _inferShapes: Bool = false
    var _placePrunedGraph: Bool = false
    var _enableBfloat16Sendrecv: Bool = false
    var _timelineStep: Int32 = 0

    init() {}

    func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 2: handled = try setter.decodeSingularField(fieldType: ProtobufBool.self, value: &_enableRecvScheduling)
      case 3: handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_OptimizerOptions.self, value: &_optimizerOptions)
      case 4: handled = try setter.decodeSingularField(fieldType: ProtobufInt64.self, value: &_buildCostModel)
      case 9: handled = try setter.decodeSingularField(fieldType: ProtobufInt64.self, value: &_buildCostModelAfter)
      case 5: handled = try setter.decodeSingularField(fieldType: ProtobufBool.self, value: &_inferShapes)
      case 6: handled = try setter.decodeSingularField(fieldType: ProtobufBool.self, value: &_placePrunedGraph)
      case 7: handled = try setter.decodeSingularField(fieldType: ProtobufBool.self, value: &_enableBfloat16Sendrecv)
      case 8: handled = try setter.decodeSingularField(fieldType: ProtobufInt32.self, value: &_timelineStep)
      default:
        handled = false
      }
      return handled
    }

    func traverse(visitor: inout ProtobufVisitor) throws {
      if _enableRecvScheduling != false {
        try visitor.visitSingularField(fieldType: ProtobufBool.self, value: _enableRecvScheduling, protoFieldNumber: 2, protoFieldName: "enable_recv_scheduling", jsonFieldName: "enableRecvScheduling", swiftFieldName: "enableRecvScheduling")
      }
      if let v = _optimizerOptions {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 3, protoFieldName: "optimizer_options", jsonFieldName: "optimizerOptions", swiftFieldName: "optimizerOptions")
      }
      if _buildCostModel != 0 {
        try visitor.visitSingularField(fieldType: ProtobufInt64.self, value: _buildCostModel, protoFieldNumber: 4, protoFieldName: "build_cost_model", jsonFieldName: "buildCostModel", swiftFieldName: "buildCostModel")
      }
      if _inferShapes != false {
        try visitor.visitSingularField(fieldType: ProtobufBool.self, value: _inferShapes, protoFieldNumber: 5, protoFieldName: "infer_shapes", jsonFieldName: "inferShapes", swiftFieldName: "inferShapes")
      }
      if _placePrunedGraph != false {
        try visitor.visitSingularField(fieldType: ProtobufBool.self, value: _placePrunedGraph, protoFieldNumber: 6, protoFieldName: "place_pruned_graph", jsonFieldName: "placePrunedGraph", swiftFieldName: "placePrunedGraph")
      }
      if _enableBfloat16Sendrecv != false {
        try visitor.visitSingularField(fieldType: ProtobufBool.self, value: _enableBfloat16Sendrecv, protoFieldNumber: 7, protoFieldName: "enable_bfloat16_sendrecv", jsonFieldName: "enableBfloat16Sendrecv", swiftFieldName: "enableBfloat16Sendrecv")
      }
      if _timelineStep != 0 {
        try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: _timelineStep, protoFieldNumber: 8, protoFieldName: "timeline_step", jsonFieldName: "timelineStep", swiftFieldName: "timelineStep")
      }
      if _buildCostModelAfter != 0 {
        try visitor.visitSingularField(fieldType: ProtobufInt64.self, value: _buildCostModelAfter, protoFieldNumber: 9, protoFieldName: "build_cost_model_after", jsonFieldName: "buildCostModelAfter", swiftFieldName: "buildCostModelAfter")
      }
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _enableRecvScheduling != other._enableRecvScheduling {return false}
      if _optimizerOptions != other._optimizerOptions {return false}
      if _buildCostModel != other._buildCostModel {return false}
      if _buildCostModelAfter != other._buildCostModelAfter {return false}
      if _inferShapes != other._inferShapes {return false}
      if _placePrunedGraph != other._placePrunedGraph {return false}
      if _enableBfloat16Sendrecv != other._enableBfloat16Sendrecv {return false}
      if _timelineStep != other._timelineStep {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._enableRecvScheduling = _enableRecvScheduling
      clone._optimizerOptions = _optimizerOptions
      clone._buildCostModel = _buildCostModel
      clone._buildCostModelAfter = _buildCostModelAfter
      clone._inferShapes = _inferShapes
      clone._placePrunedGraph = _placePrunedGraph
      clone._enableBfloat16Sendrecv = _enableBfloat16Sendrecv
      clone._timelineStep = _timelineStep
      return clone
    }
  }

  private var _storage = _StorageClass()

  ///   If true, use control flow to schedule the activation of Recv nodes.
  ///   (Currently ignored.)
  public var enableRecvScheduling: Bool {
    get {return _storage._enableRecvScheduling}
    set {_uniqueStorage()._enableRecvScheduling = newValue}
  }

  ///   Options controlling how graph is optimized.
  public var optimizerOptions: Tensorflow_OptimizerOptions {
    get {return _storage._optimizerOptions ?? Tensorflow_OptimizerOptions()}
    set {_uniqueStorage()._optimizerOptions = newValue}
  }
  public var hasOptimizerOptions: Bool {
    return _storage._optimizerOptions != nil
  }
  public mutating func clearOptimizerOptions() {
    return _storage._optimizerOptions = nil
  }

  ///   The number of steps to run before returning a cost model detailing
  ///   the memory usage and performance of each node of the graph. 0 means
  ///   no cost model.
  public var buildCostModel: Int64 {
    get {return _storage._buildCostModel}
    set {_uniqueStorage()._buildCostModel = newValue}
  }

  ///   The number of steps to skip before collecting statistics for the
  ///   cost model.
  public var buildCostModelAfter: Int64 {
    get {return _storage._buildCostModelAfter}
    set {_uniqueStorage()._buildCostModelAfter = newValue}
  }

  ///   Annotate each Node with Op output shape data, to the extent it can
  ///   be statically inferred.
  public var inferShapes: Bool {
    get {return _storage._inferShapes}
    set {_uniqueStorage()._inferShapes = newValue}
  }

  ///   Only place the subgraphs that are run, rather than the entire graph.
  ///  
  ///   This is useful for interactive graph building, where one might
  ///   produce graphs that cannot be placed during the debugging
  ///   process.  In particular, it allows the client to continue work in
  ///   a session after adding a node to a graph whose placement
  ///   constraints are unsatisfiable.
  public var placePrunedGraph: Bool {
    get {return _storage._placePrunedGraph}
    set {_uniqueStorage()._placePrunedGraph = newValue}
  }

  ///   If true, transfer float values between processes as bfloat16.
  public var enableBfloat16Sendrecv: Bool {
    get {return _storage._enableBfloat16Sendrecv}
    set {_uniqueStorage()._enableBfloat16Sendrecv = newValue}
  }

  ///   If > 0, record a timeline every this many steps.
  ///   EXPERIMENTAL: This currently has no effect in MasterSession.
  public var timelineStep: Int32 {
    get {return _storage._timelineStep}
    set {_uniqueStorage()._timelineStep = newValue}
  }

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    try _storage.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_GraphOptions) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

struct Tensorflow_ThreadPoolOptionProto: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_ThreadPoolOptionProto"}
  public var protoMessageName: String {return "ThreadPoolOptionProto"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "numThreads": 1,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "num_threads": 1,
  ]}

  ///   The number of threads in the pool.
  ///  
  ///   0 means the system picks a value based on where this option proto is used
  ///   (see the declaration of the specific field for more info).
  public var numThreads: Int32 = 0

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeSingularField(fieldType: ProtobufInt32.self, value: &numThreads)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if numThreads != 0 {
      try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: numThreads, protoFieldNumber: 1, protoFieldName: "num_threads", jsonFieldName: "numThreads", swiftFieldName: "numThreads")
    }
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_ThreadPoolOptionProto) -> Bool {
    if numThreads != other.numThreads {return false}
    return true
  }
}

///   Session configuration parameters.
///   The system picks appropriate values for fields that are not set.
struct Tensorflow_ConfigProto: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_ConfigProto"}
  public var protoMessageName: String {return "ConfigProto"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "deviceCount": 1,
    "intraOpParallelismThreads": 2,
    "interOpParallelismThreads": 5,
    "usePerSessionThreads": 9,
    "sessionInterOpThreadPool": 12,
    "placementPeriod": 3,
    "deviceFilters": 4,
    "gpuOptions": 6,
    "allowSoftPlacement": 7,
    "logDevicePlacement": 8,
    "graphOptions": 10,
    "operationTimeoutInMs": 11,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "device_count": 1,
    "intra_op_parallelism_threads": 2,
    "inter_op_parallelism_threads": 5,
    "use_per_session_threads": 9,
    "session_inter_op_thread_pool": 12,
    "placement_period": 3,
    "device_filters": 4,
    "gpu_options": 6,
    "allow_soft_placement": 7,
    "log_device_placement": 8,
    "graph_options": 10,
    "operation_timeout_in_ms": 11,
  ]}

  private class _StorageClass {
    typealias ProtobufExtendedMessage = Tensorflow_ConfigProto
    var _deviceCount: Dictionary<String,Int32> = [:]
    var _intraOpParallelismThreads: Int32 = 0
    var _interOpParallelismThreads: Int32 = 0
    var _usePerSessionThreads: Bool = false
    var _sessionInterOpThreadPool: [Tensorflow_ThreadPoolOptionProto] = []
    var _placementPeriod: Int32 = 0
    var _deviceFilters: [String] = []
    var _gpuOptions: Tensorflow_GPUOptions? = nil
    var _allowSoftPlacement: Bool = false
    var _logDevicePlacement: Bool = false
    var _graphOptions: Tensorflow_GraphOptions? = nil
    var _operationTimeoutInMs: Int64 = 0

    init() {}

    func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodeMapField(fieldType: ProtobufMap<ProtobufString,ProtobufInt32>.self, value: &_deviceCount)
      case 2: handled = try setter.decodeSingularField(fieldType: ProtobufInt32.self, value: &_intraOpParallelismThreads)
      case 5: handled = try setter.decodeSingularField(fieldType: ProtobufInt32.self, value: &_interOpParallelismThreads)
      case 9: handled = try setter.decodeSingularField(fieldType: ProtobufBool.self, value: &_usePerSessionThreads)
      case 12: handled = try setter.decodeRepeatedMessageField(fieldType: Tensorflow_ThreadPoolOptionProto.self, value: &_sessionInterOpThreadPool)
      case 3: handled = try setter.decodeSingularField(fieldType: ProtobufInt32.self, value: &_placementPeriod)
      case 4: handled = try setter.decodeRepeatedField(fieldType: ProtobufString.self, value: &_deviceFilters)
      case 6: handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_GPUOptions.self, value: &_gpuOptions)
      case 7: handled = try setter.decodeSingularField(fieldType: ProtobufBool.self, value: &_allowSoftPlacement)
      case 8: handled = try setter.decodeSingularField(fieldType: ProtobufBool.self, value: &_logDevicePlacement)
      case 10: handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_GraphOptions.self, value: &_graphOptions)
      case 11: handled = try setter.decodeSingularField(fieldType: ProtobufInt64.self, value: &_operationTimeoutInMs)
      default:
        handled = false
      }
      return handled
    }

    func traverse(visitor: inout ProtobufVisitor) throws {
      if !_deviceCount.isEmpty {
        try visitor.visitMapField(fieldType: ProtobufMap<ProtobufString,ProtobufInt32>.self, value: _deviceCount, protoFieldNumber: 1, protoFieldName: "device_count", jsonFieldName: "deviceCount", swiftFieldName: "deviceCount")
      }
      if _intraOpParallelismThreads != 0 {
        try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: _intraOpParallelismThreads, protoFieldNumber: 2, protoFieldName: "intra_op_parallelism_threads", jsonFieldName: "intraOpParallelismThreads", swiftFieldName: "intraOpParallelismThreads")
      }
      if _placementPeriod != 0 {
        try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: _placementPeriod, protoFieldNumber: 3, protoFieldName: "placement_period", jsonFieldName: "placementPeriod", swiftFieldName: "placementPeriod")
      }
      if !_deviceFilters.isEmpty {
        try visitor.visitRepeatedField(fieldType: ProtobufString.self, value: _deviceFilters, protoFieldNumber: 4, protoFieldName: "device_filters", jsonFieldName: "deviceFilters", swiftFieldName: "deviceFilters")
      }
      if _interOpParallelismThreads != 0 {
        try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: _interOpParallelismThreads, protoFieldNumber: 5, protoFieldName: "inter_op_parallelism_threads", jsonFieldName: "interOpParallelismThreads", swiftFieldName: "interOpParallelismThreads")
      }
      if let v = _gpuOptions {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 6, protoFieldName: "gpu_options", jsonFieldName: "gpuOptions", swiftFieldName: "gpuOptions")
      }
      if _allowSoftPlacement != false {
        try visitor.visitSingularField(fieldType: ProtobufBool.self, value: _allowSoftPlacement, protoFieldNumber: 7, protoFieldName: "allow_soft_placement", jsonFieldName: "allowSoftPlacement", swiftFieldName: "allowSoftPlacement")
      }
      if _logDevicePlacement != false {
        try visitor.visitSingularField(fieldType: ProtobufBool.self, value: _logDevicePlacement, protoFieldNumber: 8, protoFieldName: "log_device_placement", jsonFieldName: "logDevicePlacement", swiftFieldName: "logDevicePlacement")
      }
      if _usePerSessionThreads != false {
        try visitor.visitSingularField(fieldType: ProtobufBool.self, value: _usePerSessionThreads, protoFieldNumber: 9, protoFieldName: "use_per_session_threads", jsonFieldName: "usePerSessionThreads", swiftFieldName: "usePerSessionThreads")
      }
      if let v = _graphOptions {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 10, protoFieldName: "graph_options", jsonFieldName: "graphOptions", swiftFieldName: "graphOptions")
      }
      if _operationTimeoutInMs != 0 {
        try visitor.visitSingularField(fieldType: ProtobufInt64.self, value: _operationTimeoutInMs, protoFieldNumber: 11, protoFieldName: "operation_timeout_in_ms", jsonFieldName: "operationTimeoutInMs", swiftFieldName: "operationTimeoutInMs")
      }
      if !_sessionInterOpThreadPool.isEmpty {
        try visitor.visitRepeatedMessageField(value: _sessionInterOpThreadPool, protoFieldNumber: 12, protoFieldName: "session_inter_op_thread_pool", jsonFieldName: "sessionInterOpThreadPool", swiftFieldName: "sessionInterOpThreadPool")
      }
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _deviceCount != other._deviceCount {return false}
      if _intraOpParallelismThreads != other._intraOpParallelismThreads {return false}
      if _interOpParallelismThreads != other._interOpParallelismThreads {return false}
      if _usePerSessionThreads != other._usePerSessionThreads {return false}
      if _sessionInterOpThreadPool != other._sessionInterOpThreadPool {return false}
      if _placementPeriod != other._placementPeriod {return false}
      if _deviceFilters != other._deviceFilters {return false}
      if _gpuOptions != other._gpuOptions {return false}
      if _allowSoftPlacement != other._allowSoftPlacement {return false}
      if _logDevicePlacement != other._logDevicePlacement {return false}
      if _graphOptions != other._graphOptions {return false}
      if _operationTimeoutInMs != other._operationTimeoutInMs {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._deviceCount = _deviceCount
      clone._intraOpParallelismThreads = _intraOpParallelismThreads
      clone._interOpParallelismThreads = _interOpParallelismThreads
      clone._usePerSessionThreads = _usePerSessionThreads
      clone._sessionInterOpThreadPool = _sessionInterOpThreadPool
      clone._placementPeriod = _placementPeriod
      clone._deviceFilters = _deviceFilters
      clone._gpuOptions = _gpuOptions
      clone._allowSoftPlacement = _allowSoftPlacement
      clone._logDevicePlacement = _logDevicePlacement
      clone._graphOptions = _graphOptions
      clone._operationTimeoutInMs = _operationTimeoutInMs
      return clone
    }
  }

  private var _storage = _StorageClass()

  ///   Map from device type name (e.g., "CPU" or "GPU" ) to maximum
  ///   number of devices of that type to use.  If a particular device
  ///   type is not found in the map, the system picks an appropriate
  ///   number.
  public var deviceCount: Dictionary<String,Int32> {
    get {return _storage._deviceCount}
    set {_uniqueStorage()._deviceCount = newValue}
  }

  ///   The execution of an individual op (for some op types) can be
  ///   parallelized on a pool of intra_op_parallelism_threads.
  ///   0 means the system picks an appropriate number.
  public var intraOpParallelismThreads: Int32 {
    get {return _storage._intraOpParallelismThreads}
    set {_uniqueStorage()._intraOpParallelismThreads = newValue}
  }

  ///   Nodes that perform blocking operations are enqueued on a pool of
  ///   inter_op_parallelism_threads available in each process.
  ///  
  ///   0 means the system picks an appropriate number.
  ///  
  ///   Note that the first Session created in the process sets the
  ///   number of threads for all future sessions unless use_per_session_threads is
  ///   true or session_inter_op_thread_pool is configured.
  public var interOpParallelismThreads: Int32 {
    get {return _storage._interOpParallelismThreads}
    set {_uniqueStorage()._interOpParallelismThreads = newValue}
  }

  ///   If true, use a new set of threads for this session rather than the global
  ///   pool of threads. Only supported by direct sessions.
  ///  
  ///   If false, use the global threads created by the first session, or the
  ///   per-session thread pools configured by session_inter_op_thread_pool.
  ///  
  ///   This option is deprecated. The same effect can be achieved by setting
  ///   session_inter_op_thread_pool to have one element, whose num_threads equals
  ///   inter_op_parallelism_threads.
  public var usePerSessionThreads: Bool {
    get {return _storage._usePerSessionThreads}
    set {_uniqueStorage()._usePerSessionThreads = newValue}
  }

  ///   This option is experimental - it may be replaced with a different mechanism
  ///   in the future. The intended use is for when some session invocations need
  ///   to run in a background pool limited to a small number of threads.
  ///  
  ///   Configures session thread pools. If this is configured, then RunOptions for
  ///   a Run call can select the thread pool to use.
  ///  
  ///   If a pool's num_threads is 0, then inter_op_parallelism_threads is used.
  public var sessionInterOpThreadPool: [Tensorflow_ThreadPoolOptionProto] {
    get {return _storage._sessionInterOpThreadPool}
    set {_uniqueStorage()._sessionInterOpThreadPool = newValue}
  }

  ///   Assignment of Nodes to Devices is recomputed every placement_period
  ///   steps until the system warms up (at which point the recomputation
  ///   typically slows down automatically).
  public var placementPeriod: Int32 {
    get {return _storage._placementPeriod}
    set {_uniqueStorage()._placementPeriod = newValue}
  }

  ///   When any filters are present sessions will ignore all devices which do not
  ///   match the filters. Each filter can be partially specified, e.g. "/job:ps"
  ///   "/job:worker/replica:3", etc.
  public var deviceFilters: [String] {
    get {return _storage._deviceFilters}
    set {_uniqueStorage()._deviceFilters = newValue}
  }

  ///   Options that apply to all GPUs.
  public var gpuOptions: Tensorflow_GPUOptions {
    get {return _storage._gpuOptions ?? Tensorflow_GPUOptions()}
    set {_uniqueStorage()._gpuOptions = newValue}
  }
  public var hasGpuOptions: Bool {
    return _storage._gpuOptions != nil
  }
  public mutating func clearGpuOptions() {
    return _storage._gpuOptions = nil
  }

  ///   Whether soft placement is allowed. If allow_soft_placement is true,
  ///   an op will be placed on CPU if
  ///     1. there's no GPU implementation for the OP
  ///   or
  ///     2. no GPU devices are known or registered
  ///   or
  ///     3. need to co-locate with reftype input(s) which are from CPU.
  public var allowSoftPlacement: Bool {
    get {return _storage._allowSoftPlacement}
    set {_uniqueStorage()._allowSoftPlacement = newValue}
  }

  ///   Whether device placements should be logged.
  public var logDevicePlacement: Bool {
    get {return _storage._logDevicePlacement}
    set {_uniqueStorage()._logDevicePlacement = newValue}
  }

  ///   Options that apply to all graphs.
  public var graphOptions: Tensorflow_GraphOptions {
    get {return _storage._graphOptions ?? Tensorflow_GraphOptions()}
    set {_uniqueStorage()._graphOptions = newValue}
  }
  public var hasGraphOptions: Bool {
    return _storage._graphOptions != nil
  }
  public mutating func clearGraphOptions() {
    return _storage._graphOptions = nil
  }

  ///   Global timeout for all blocking operations in this session.  If non-zero,
  ///   and not overridden on a per-operation basis, this value will be used as the
  ///   deadline for all blocking operations.
  public var operationTimeoutInMs: Int64 {
    get {return _storage._operationTimeoutInMs}
    set {_uniqueStorage()._operationTimeoutInMs = newValue}
  }

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    try _storage.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_ConfigProto) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

///   EXPERIMENTAL. Option for watching a node.
struct Tensorflow_DebugTensorWatch: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_DebugTensorWatch"}
  public var protoMessageName: String {return "DebugTensorWatch"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "nodeName": 1,
    "outputSlot": 2,
    "debugOps": 3,
    "debugUrls": 4,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "node_name": 1,
    "output_slot": 2,
    "debug_ops": 3,
    "debug_urls": 4,
  ]}

  ///   Name of the node to watch.
  public var nodeName: String = ""

  ///   Output slot to watch.
  ///   The semantics of output_slot == -1 is that the node is only watched for
  ///   completion, but not for any output tensors. See NodeCompletionCallback
  ///   in debug_gateway.h.
  ///   TODO(cais): Implement this semantics.
  public var outputSlot: Int32 = 0

  ///   Name(s) of the debugging op(s).
  ///   One or more than one probes on a tensor.
  ///   e.g., {"DebugIdentity", "DebugNanCount"}
  public var debugOps: [String] = []

  ///   URL(s) for debug targets(s).
  ///     E.g., "file:///foo/tfdbg_dump", "grpc://localhost:11011"
  ///   Each debug op listed in debug_ops will publish its output tensor (debug
  ///   signal) to all URLs in debug_urls.
  public var debugUrls: [String] = []

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &nodeName)
    case 2: handled = try setter.decodeSingularField(fieldType: ProtobufInt32.self, value: &outputSlot)
    case 3: handled = try setter.decodeRepeatedField(fieldType: ProtobufString.self, value: &debugOps)
    case 4: handled = try setter.decodeRepeatedField(fieldType: ProtobufString.self, value: &debugUrls)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if nodeName != "" {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: nodeName, protoFieldNumber: 1, protoFieldName: "node_name", jsonFieldName: "nodeName", swiftFieldName: "nodeName")
    }
    if outputSlot != 0 {
      try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: outputSlot, protoFieldNumber: 2, protoFieldName: "output_slot", jsonFieldName: "outputSlot", swiftFieldName: "outputSlot")
    }
    if !debugOps.isEmpty {
      try visitor.visitRepeatedField(fieldType: ProtobufString.self, value: debugOps, protoFieldNumber: 3, protoFieldName: "debug_ops", jsonFieldName: "debugOps", swiftFieldName: "debugOps")
    }
    if !debugUrls.isEmpty {
      try visitor.visitRepeatedField(fieldType: ProtobufString.self, value: debugUrls, protoFieldNumber: 4, protoFieldName: "debug_urls", jsonFieldName: "debugUrls", swiftFieldName: "debugUrls")
    }
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_DebugTensorWatch) -> Bool {
    if nodeName != other.nodeName {return false}
    if outputSlot != other.outputSlot {return false}
    if debugOps != other.debugOps {return false}
    if debugUrls != other.debugUrls {return false}
    return true
  }
}

///   EXPERIMENTAL. Options for a single Run() call.
struct Tensorflow_RunOptions: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_RunOptions"}
  public var protoMessageName: String {return "RunOptions"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "traceLevel": 1,
    "timeoutInMs": 2,
    "interOpThreadPool": 3,
    "debugTensorWatchOpts": 4,
    "outputPartitionGraphs": 5,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "trace_level": 1,
    "timeout_in_ms": 2,
    "inter_op_thread_pool": 3,
    "debug_tensor_watch_opts": 4,
    "output_partition_graphs": 5,
  ]}

  ///   TODO(pbar) Turn this into a TraceOptions proto which allows
  ///   tracing to be controlled in a more orthogonal manner?
  enum TraceLevel: ProtobufEnum {
    public typealias RawValue = Int
    case noTrace // = 0
    case softwareTrace // = 1
    case hardwareTrace // = 2
    case fullTrace // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .noTrace
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .noTrace
      case 1: self = .softwareTrace
      case 2: self = .hardwareTrace
      case 3: self = .fullTrace
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public init?(name: String) {
      switch name {
      case "noTrace": self = .noTrace
      case "softwareTrace": self = .softwareTrace
      case "hardwareTrace": self = .hardwareTrace
      case "fullTrace": self = .fullTrace
      default: return nil
      }
    }

    public init?(jsonName: String) {
      switch jsonName {
      case "NO_TRACE": self = .noTrace
      case "SOFTWARE_TRACE": self = .softwareTrace
      case "HARDWARE_TRACE": self = .hardwareTrace
      case "FULL_TRACE": self = .fullTrace
      default: return nil
      }
    }

    public init?(protoName: String) {
      switch protoName {
      case "NO_TRACE": self = .noTrace
      case "SOFTWARE_TRACE": self = .softwareTrace
      case "HARDWARE_TRACE": self = .hardwareTrace
      case "FULL_TRACE": self = .fullTrace
      default: return nil
      }
    }

    public var rawValue: Int {
      get {
        switch self {
        case .noTrace: return 0
        case .softwareTrace: return 1
        case .hardwareTrace: return 2
        case .fullTrace: return 3
        case .UNRECOGNIZED(let i): return i
        }
      }
    }

    public var json: String {
      get {
        switch self {
        case .noTrace: return "\"NO_TRACE\""
        case .softwareTrace: return "\"SOFTWARE_TRACE\""
        case .hardwareTrace: return "\"HARDWARE_TRACE\""
        case .fullTrace: return "\"FULL_TRACE\""
        case .UNRECOGNIZED(let i): return String(i)
        }
      }
    }

    public var hashValue: Int { return rawValue }

    public var debugDescription: String {
      get {
        switch self {
        case .noTrace: return ".noTrace"
        case .softwareTrace: return ".softwareTrace"
        case .hardwareTrace: return ".hardwareTrace"
        case .fullTrace: return ".fullTrace"
        case .UNRECOGNIZED(let v): return ".UNRECOGNIZED(\(v))"
        }
      }
    }

  }

  public var traceLevel: Tensorflow_RunOptions.TraceLevel = Tensorflow_RunOptions.TraceLevel.noTrace

  ///   Time to wait for operation to complete in milliseconds.
  public var timeoutInMs: Int64 = 0

  ///   The thread pool to use, if session_inter_op_thread_pool is configured.
  public var interOpThreadPool: Int32 = 0

  ///   Debugging options
  public var debugTensorWatchOpts: [Tensorflow_DebugTensorWatch] = []

  ///   Whether the partition graph(s) executed by the executor(s) should be
  ///   outputted via RunMetadata.
  public var outputPartitionGraphs: Bool = false

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeSingularField(fieldType: Tensorflow_RunOptions.TraceLevel.self, value: &traceLevel)
    case 2: handled = try setter.decodeSingularField(fieldType: ProtobufInt64.self, value: &timeoutInMs)
    case 3: handled = try setter.decodeSingularField(fieldType: ProtobufInt32.self, value: &interOpThreadPool)
    case 4: handled = try setter.decodeRepeatedMessageField(fieldType: Tensorflow_DebugTensorWatch.self, value: &debugTensorWatchOpts)
    case 5: handled = try setter.decodeSingularField(fieldType: ProtobufBool.self, value: &outputPartitionGraphs)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if traceLevel != Tensorflow_RunOptions.TraceLevel.noTrace {
      try visitor.visitSingularField(fieldType: Tensorflow_RunOptions.TraceLevel.self, value: traceLevel, protoFieldNumber: 1, protoFieldName: "trace_level", jsonFieldName: "traceLevel", swiftFieldName: "traceLevel")
    }
    if timeoutInMs != 0 {
      try visitor.visitSingularField(fieldType: ProtobufInt64.self, value: timeoutInMs, protoFieldNumber: 2, protoFieldName: "timeout_in_ms", jsonFieldName: "timeoutInMs", swiftFieldName: "timeoutInMs")
    }
    if interOpThreadPool != 0 {
      try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: interOpThreadPool, protoFieldNumber: 3, protoFieldName: "inter_op_thread_pool", jsonFieldName: "interOpThreadPool", swiftFieldName: "interOpThreadPool")
    }
    if !debugTensorWatchOpts.isEmpty {
      try visitor.visitRepeatedMessageField(value: debugTensorWatchOpts, protoFieldNumber: 4, protoFieldName: "debug_tensor_watch_opts", jsonFieldName: "debugTensorWatchOpts", swiftFieldName: "debugTensorWatchOpts")
    }
    if outputPartitionGraphs != false {
      try visitor.visitSingularField(fieldType: ProtobufBool.self, value: outputPartitionGraphs, protoFieldNumber: 5, protoFieldName: "output_partition_graphs", jsonFieldName: "outputPartitionGraphs", swiftFieldName: "outputPartitionGraphs")
    }
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_RunOptions) -> Bool {
    if traceLevel != other.traceLevel {return false}
    if timeoutInMs != other.timeoutInMs {return false}
    if interOpThreadPool != other.interOpThreadPool {return false}
    if debugTensorWatchOpts != other.debugTensorWatchOpts {return false}
    if outputPartitionGraphs != other.outputPartitionGraphs {return false}
    return true
  }
}

///   EXPERIMENTAL. Metadata output (i.e., non-Tensor) for a single Run() call.
struct Tensorflow_RunMetadata: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_RunMetadata"}
  public var protoMessageName: String {return "RunMetadata"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "stepStats": 1,
    "costGraph": 2,
    "partitionGraphs": 3,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "step_stats": 1,
    "cost_graph": 2,
    "partition_graphs": 3,
  ]}

  private class _StorageClass {
    typealias ProtobufExtendedMessage = Tensorflow_RunMetadata
    var _stepStats: Tensorflow_StepStats? = nil
    var _costGraph: Tensorflow_CostGraphDef? = nil
    var _partitionGraphs: [Tensorflow_GraphDef] = []

    init() {}

    func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_StepStats.self, value: &_stepStats)
      case 2: handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_CostGraphDef.self, value: &_costGraph)
      case 3: handled = try setter.decodeRepeatedMessageField(fieldType: Tensorflow_GraphDef.self, value: &_partitionGraphs)
      default:
        handled = false
      }
      return handled
    }

    func traverse(visitor: inout ProtobufVisitor) throws {
      if let v = _stepStats {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 1, protoFieldName: "step_stats", jsonFieldName: "stepStats", swiftFieldName: "stepStats")
      }
      if let v = _costGraph {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 2, protoFieldName: "cost_graph", jsonFieldName: "costGraph", swiftFieldName: "costGraph")
      }
      if !_partitionGraphs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _partitionGraphs, protoFieldNumber: 3, protoFieldName: "partition_graphs", jsonFieldName: "partitionGraphs", swiftFieldName: "partitionGraphs")
      }
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _stepStats != other._stepStats {return false}
      if _costGraph != other._costGraph {return false}
      if _partitionGraphs != other._partitionGraphs {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._stepStats = _stepStats
      clone._costGraph = _costGraph
      clone._partitionGraphs = _partitionGraphs
      return clone
    }
  }

  private var _storage = _StorageClass()

  ///   Statistics traced for this step. Populated if tracing is turned on via the
  ///   "RunOptions" proto.
  ///   EXPERIMENTAL: The format and set of events may change in future versions.
  public var stepStats: Tensorflow_StepStats {
    get {return _storage._stepStats ?? Tensorflow_StepStats()}
    set {_uniqueStorage()._stepStats = newValue}
  }
  public var hasStepStats: Bool {
    return _storage._stepStats != nil
  }
  public mutating func clearStepStats() {
    return _storage._stepStats = nil
  }

  ///   The cost graph for the computation defined by the run call.
  public var costGraph: Tensorflow_CostGraphDef {
    get {return _storage._costGraph ?? Tensorflow_CostGraphDef()}
    set {_uniqueStorage()._costGraph = newValue}
  }
  public var hasCostGraph: Bool {
    return _storage._costGraph != nil
  }
  public mutating func clearCostGraph() {
    return _storage._costGraph = nil
  }

  ///   Graphs of the partitions executed by executors.
  public var partitionGraphs: [Tensorflow_GraphDef] {
    get {return _storage._partitionGraphs}
    set {_uniqueStorage()._partitionGraphs = newValue}
  }

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    try _storage.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_RunMetadata) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}
