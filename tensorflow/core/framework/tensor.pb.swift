/*
 * DO NOT EDIT.
 *
 * Generated by the protocol buffer compiler.
 * Source: tensorflow/core/framework/tensor.proto
 *
 */

import Foundation
import SwiftProtobuf


///   Protocol buffer representing a tensor.
struct Tensorflow_TensorProto: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_TensorProto"}
  public var protoMessageName: String {return "TensorProto"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "dtype": 1,
    "tensorShape": 2,
    "versionNumber": 3,
    "tensorContent": 4,
    "halfVal": 13,
    "floatVal": 5,
    "doubleVal": 6,
    "intVal": 7,
    "stringVal": 8,
    "scomplexVal": 9,
    "int64Val": 10,
    "boolVal": 11,
    "dcomplexVal": 12,
    "resourceHandleVal": 14,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "dtype": 1,
    "tensor_shape": 2,
    "version_number": 3,
    "tensor_content": 4,
    "half_val": 13,
    "float_val": 5,
    "double_val": 6,
    "int_val": 7,
    "string_val": 8,
    "scomplex_val": 9,
    "int64_val": 10,
    "bool_val": 11,
    "dcomplex_val": 12,
    "resource_handle_val": 14,
  ]}

  private class _StorageClass {
    typealias ProtobufExtendedMessage = Tensorflow_TensorProto
    var _dtype: Tensorflow_DataType = Tensorflow_DataType.dtInvalid
    var _tensorShape: Tensorflow_TensorShapeProto? = nil
    var _versionNumber: Int32 = 0
    var _tensorContent: Data = Data()
    var _halfVal: [Int32] = []
    var _floatVal: [Float] = []
    var _doubleVal: [Double] = []
    var _intVal: [Int32] = []
    var _stringVal: [Data] = []
    var _scomplexVal: [Float] = []
    var _int64Val: [Int64] = []
    var _boolVal: [Bool] = []
    var _dcomplexVal: [Double] = []
    var _resourceHandleVal: [Tensorflow_ResourceHandle] = []

    init() {}

    func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodeSingularField(fieldType: Tensorflow_DataType.self, value: &_dtype)
      case 2: handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_TensorShapeProto.self, value: &_tensorShape)
      case 3: handled = try setter.decodeSingularField(fieldType: ProtobufInt32.self, value: &_versionNumber)
      case 4: handled = try setter.decodeSingularField(fieldType: ProtobufBytes.self, value: &_tensorContent)
      case 13: handled = try setter.decodePackedField(fieldType: ProtobufInt32.self, value: &_halfVal)
      case 5: handled = try setter.decodePackedField(fieldType: ProtobufFloat.self, value: &_floatVal)
      case 6: handled = try setter.decodePackedField(fieldType: ProtobufDouble.self, value: &_doubleVal)
      case 7: handled = try setter.decodePackedField(fieldType: ProtobufInt32.self, value: &_intVal)
      case 8: handled = try setter.decodeRepeatedField(fieldType: ProtobufBytes.self, value: &_stringVal)
      case 9: handled = try setter.decodePackedField(fieldType: ProtobufFloat.self, value: &_scomplexVal)
      case 10: handled = try setter.decodePackedField(fieldType: ProtobufInt64.self, value: &_int64Val)
      case 11: handled = try setter.decodePackedField(fieldType: ProtobufBool.self, value: &_boolVal)
      case 12: handled = try setter.decodePackedField(fieldType: ProtobufDouble.self, value: &_dcomplexVal)
      case 14: handled = try setter.decodeRepeatedMessageField(fieldType: Tensorflow_ResourceHandle.self, value: &_resourceHandleVal)
      default:
        handled = false
      }
      return handled
    }

    func traverse(visitor: inout ProtobufVisitor) throws {
      if _dtype != Tensorflow_DataType.dtInvalid {
        try visitor.visitSingularField(fieldType: Tensorflow_DataType.self, value: _dtype, protoFieldNumber: 1, protoFieldName: "dtype", jsonFieldName: "dtype", swiftFieldName: "dtype")
      }
      if let v = _tensorShape {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 2, protoFieldName: "tensor_shape", jsonFieldName: "tensorShape", swiftFieldName: "tensorShape")
      }
      if _versionNumber != 0 {
        try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: _versionNumber, protoFieldNumber: 3, protoFieldName: "version_number", jsonFieldName: "versionNumber", swiftFieldName: "versionNumber")
      }
      if _tensorContent != Data() {
        try visitor.visitSingularField(fieldType: ProtobufBytes.self, value: _tensorContent, protoFieldNumber: 4, protoFieldName: "tensor_content", jsonFieldName: "tensorContent", swiftFieldName: "tensorContent")
      }
      if !_floatVal.isEmpty {
        try visitor.visitPackedField(fieldType: ProtobufFloat.self, value: _floatVal, protoFieldNumber: 5, protoFieldName: "float_val", jsonFieldName: "floatVal", swiftFieldName: "floatVal")
      }
      if !_doubleVal.isEmpty {
        try visitor.visitPackedField(fieldType: ProtobufDouble.self, value: _doubleVal, protoFieldNumber: 6, protoFieldName: "double_val", jsonFieldName: "doubleVal", swiftFieldName: "doubleVal")
      }
      if !_intVal.isEmpty {
        try visitor.visitPackedField(fieldType: ProtobufInt32.self, value: _intVal, protoFieldNumber: 7, protoFieldName: "int_val", jsonFieldName: "intVal", swiftFieldName: "intVal")
      }
      if !_stringVal.isEmpty {
        try visitor.visitRepeatedField(fieldType: ProtobufBytes.self, value: _stringVal, protoFieldNumber: 8, protoFieldName: "string_val", jsonFieldName: "stringVal", swiftFieldName: "stringVal")
      }
      if !_scomplexVal.isEmpty {
        try visitor.visitPackedField(fieldType: ProtobufFloat.self, value: _scomplexVal, protoFieldNumber: 9, protoFieldName: "scomplex_val", jsonFieldName: "scomplexVal", swiftFieldName: "scomplexVal")
      }
      if !_int64Val.isEmpty {
        try visitor.visitPackedField(fieldType: ProtobufInt64.self, value: _int64Val, protoFieldNumber: 10, protoFieldName: "int64_val", jsonFieldName: "int64Val", swiftFieldName: "int64Val")
      }
      if !_boolVal.isEmpty {
        try visitor.visitPackedField(fieldType: ProtobufBool.self, value: _boolVal, protoFieldNumber: 11, protoFieldName: "bool_val", jsonFieldName: "boolVal", swiftFieldName: "boolVal")
      }
      if !_dcomplexVal.isEmpty {
        try visitor.visitPackedField(fieldType: ProtobufDouble.self, value: _dcomplexVal, protoFieldNumber: 12, protoFieldName: "dcomplex_val", jsonFieldName: "dcomplexVal", swiftFieldName: "dcomplexVal")
      }
      if !_halfVal.isEmpty {
        try visitor.visitPackedField(fieldType: ProtobufInt32.self, value: _halfVal, protoFieldNumber: 13, protoFieldName: "half_val", jsonFieldName: "halfVal", swiftFieldName: "halfVal")
      }
      if !_resourceHandleVal.isEmpty {
        try visitor.visitRepeatedMessageField(value: _resourceHandleVal, protoFieldNumber: 14, protoFieldName: "resource_handle_val", jsonFieldName: "resourceHandleVal", swiftFieldName: "resourceHandleVal")
      }
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _dtype != other._dtype {return false}
      if _tensorShape != other._tensorShape {return false}
      if _versionNumber != other._versionNumber {return false}
      if _tensorContent != other._tensorContent {return false}
      if _halfVal != other._halfVal {return false}
      if _floatVal != other._floatVal {return false}
      if _doubleVal != other._doubleVal {return false}
      if _intVal != other._intVal {return false}
      if _stringVal != other._stringVal {return false}
      if _scomplexVal != other._scomplexVal {return false}
      if _int64Val != other._int64Val {return false}
      if _boolVal != other._boolVal {return false}
      if _dcomplexVal != other._dcomplexVal {return false}
      if _resourceHandleVal != other._resourceHandleVal {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._dtype = _dtype
      clone._tensorShape = _tensorShape
      clone._versionNumber = _versionNumber
      clone._tensorContent = _tensorContent
      clone._halfVal = _halfVal
      clone._floatVal = _floatVal
      clone._doubleVal = _doubleVal
      clone._intVal = _intVal
      clone._stringVal = _stringVal
      clone._scomplexVal = _scomplexVal
      clone._int64Val = _int64Val
      clone._boolVal = _boolVal
      clone._dcomplexVal = _dcomplexVal
      clone._resourceHandleVal = _resourceHandleVal
      return clone
    }
  }

  private var _storage = _StorageClass()

  public var dtype: Tensorflow_DataType {
    get {return _storage._dtype}
    set {_uniqueStorage()._dtype = newValue}
  }

  ///   Shape of the tensor.  TODO(touts): sort out the 0-rank issues.
  public var tensorShape: Tensorflow_TensorShapeProto {
    get {return _storage._tensorShape ?? Tensorflow_TensorShapeProto()}
    set {_uniqueStorage()._tensorShape = newValue}
  }
  public var hasTensorShape: Bool {
    return _storage._tensorShape != nil
  }
  public mutating func clearTensorShape() {
    return _storage._tensorShape = nil
  }

  //  Only one of the representations below is set, one of "tensor_contents" and
  //  the "xxx_val" attributes.  We are not using oneof because as oneofs cannot
  //  contain repeated fields it would require another extra set of messages.

  ///   Version number.
  ///  
  ///   In version 0, if the "repeated xxx" representations contain only one
  ///   element, that element is repeated to fill the shape.  This makes it easy
  ///   to represent a constant Tensor with a single value.
  public var versionNumber: Int32 {
    get {return _storage._versionNumber}
    set {_uniqueStorage()._versionNumber = newValue}
  }

  ///   Serialized content from Tensor::AsProtoTensorContent(). This representation
  ///   can be used for all tensor types.
  public var tensorContent: Data {
    get {return _storage._tensorContent}
    set {_uniqueStorage()._tensorContent = newValue}
  }

  //  Type specific representations that make it easy to create tensor protos in
  //  all languages.  Only the representation corresponding to "dtype" can
  //  be set.  The values hold the flattened representation of the tensor in
  //  row major order.

  ///   DT_HALF. Note that since protobuf has no int16 type, we'll have some
  ///   pointless zero padding for each value here.
  public var halfVal: [Int32] {
    get {return _storage._halfVal}
    set {_uniqueStorage()._halfVal = newValue}
  }

  ///   DT_FLOAT.
  public var floatVal: [Float] {
    get {return _storage._floatVal}
    set {_uniqueStorage()._floatVal = newValue}
  }

  ///   DT_DOUBLE.
  public var doubleVal: [Double] {
    get {return _storage._doubleVal}
    set {_uniqueStorage()._doubleVal = newValue}
  }

  ///   DT_INT32, DT_INT16, DT_INT8, DT_UINT8.
  public var intVal: [Int32] {
    get {return _storage._intVal}
    set {_uniqueStorage()._intVal = newValue}
  }

  ///   DT_STRING
  public var stringVal: [Data] {
    get {return _storage._stringVal}
    set {_uniqueStorage()._stringVal = newValue}
  }

  ///   DT_COMPLEX64. scomplex_val(2*i) and scomplex_val(2*i+1) are real
  ///   and imaginary parts of i-th single precision complex.
  public var scomplexVal: [Float] {
    get {return _storage._scomplexVal}
    set {_uniqueStorage()._scomplexVal = newValue}
  }

  ///   DT_INT64
  public var int64Val: [Int64] {
    get {return _storage._int64Val}
    set {_uniqueStorage()._int64Val = newValue}
  }

  ///   DT_BOOL
  public var boolVal: [Bool] {
    get {return _storage._boolVal}
    set {_uniqueStorage()._boolVal = newValue}
  }

  ///   DT_COMPLEX128. dcomplex_val(2*i) and dcomplex_val(2*i+1) are real
  ///   and imaginary parts of i-th double precision complex.
  public var dcomplexVal: [Double] {
    get {return _storage._dcomplexVal}
    set {_uniqueStorage()._dcomplexVal = newValue}
  }

  ///   DT_RESOURCE
  public var resourceHandleVal: [Tensorflow_ResourceHandle] {
    get {return _storage._resourceHandleVal}
    set {_uniqueStorage()._resourceHandleVal = newValue}
  }

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    try _storage.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_TensorProto) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}
