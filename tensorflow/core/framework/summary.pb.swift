/*
 * DO NOT EDIT.
 *
 * Generated by the protocol buffer compiler.
 * Source: tensorflow/core/framework/summary.proto
 *
 */

import Foundation
import SwiftProtobuf


///   Metadata associated with a series of Summary data
struct Tensorflow_SummaryDescription: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_SummaryDescription"}
  public var protoMessageName: String {return "SummaryDescription"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "typeHint": 1,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "type_hint": 1,
  ]}

  ///   Hint on how plugins should process the data in this series.
  ///   Supported values include "scalar", "histogram", "image", "audio"
  public var typeHint: String = ""

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &typeHint)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if typeHint != "" {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: typeHint, protoFieldNumber: 1, protoFieldName: "type_hint", jsonFieldName: "typeHint", swiftFieldName: "typeHint")
    }
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_SummaryDescription) -> Bool {
    if typeHint != other.typeHint {return false}
    return true
  }
}

///   Serialization format for histogram module in
///   core/lib/histogram/histogram.h
struct Tensorflow_HistogramProto: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_HistogramProto"}
  public var protoMessageName: String {return "HistogramProto"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "min": 1,
    "max": 2,
    "num": 3,
    "sum": 4,
    "sumSquares": 5,
    "bucketLimit": 6,
    "bucket": 7,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "min": 1,
    "max": 2,
    "num": 3,
    "sum": 4,
    "sum_squares": 5,
    "bucket_limit": 6,
    "bucket": 7,
  ]}

  public var min: Double = 0

  public var max: Double = 0

  public var num: Double = 0

  public var sum: Double = 0

  public var sumSquares: Double = 0

  ///   Parallel arrays encoding the bucket boundaries and the bucket values.
  ///   bucket(i) is the count for the bucket i.  The range for
  ///   a bucket is:
  ///     i == 0:  -DBL_MAX .. bucket_limit(0)
  ///     i != 0:  bucket_limit(i-1) .. bucket_limit(i)
  public var bucketLimit: [Double] = []

  public var bucket: [Double] = []

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeSingularField(fieldType: ProtobufDouble.self, value: &min)
    case 2: handled = try setter.decodeSingularField(fieldType: ProtobufDouble.self, value: &max)
    case 3: handled = try setter.decodeSingularField(fieldType: ProtobufDouble.self, value: &num)
    case 4: handled = try setter.decodeSingularField(fieldType: ProtobufDouble.self, value: &sum)
    case 5: handled = try setter.decodeSingularField(fieldType: ProtobufDouble.self, value: &sumSquares)
    case 6: handled = try setter.decodePackedField(fieldType: ProtobufDouble.self, value: &bucketLimit)
    case 7: handled = try setter.decodePackedField(fieldType: ProtobufDouble.self, value: &bucket)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if min != 0 {
      try visitor.visitSingularField(fieldType: ProtobufDouble.self, value: min, protoFieldNumber: 1, protoFieldName: "min", jsonFieldName: "min", swiftFieldName: "min")
    }
    if max != 0 {
      try visitor.visitSingularField(fieldType: ProtobufDouble.self, value: max, protoFieldNumber: 2, protoFieldName: "max", jsonFieldName: "max", swiftFieldName: "max")
    }
    if num != 0 {
      try visitor.visitSingularField(fieldType: ProtobufDouble.self, value: num, protoFieldNumber: 3, protoFieldName: "num", jsonFieldName: "num", swiftFieldName: "num")
    }
    if sum != 0 {
      try visitor.visitSingularField(fieldType: ProtobufDouble.self, value: sum, protoFieldNumber: 4, protoFieldName: "sum", jsonFieldName: "sum", swiftFieldName: "sum")
    }
    if sumSquares != 0 {
      try visitor.visitSingularField(fieldType: ProtobufDouble.self, value: sumSquares, protoFieldNumber: 5, protoFieldName: "sum_squares", jsonFieldName: "sumSquares", swiftFieldName: "sumSquares")
    }
    if !bucketLimit.isEmpty {
      try visitor.visitPackedField(fieldType: ProtobufDouble.self, value: bucketLimit, protoFieldNumber: 6, protoFieldName: "bucket_limit", jsonFieldName: "bucketLimit", swiftFieldName: "bucketLimit")
    }
    if !bucket.isEmpty {
      try visitor.visitPackedField(fieldType: ProtobufDouble.self, value: bucket, protoFieldNumber: 7, protoFieldName: "bucket", jsonFieldName: "bucket", swiftFieldName: "bucket")
    }
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_HistogramProto) -> Bool {
    if min != other.min {return false}
    if max != other.max {return false}
    if num != other.num {return false}
    if sum != other.sum {return false}
    if sumSquares != other.sumSquares {return false}
    if bucketLimit != other.bucketLimit {return false}
    if bucket != other.bucket {return false}
    return true
  }
}

///   A Summary is a set of named values to be displayed by the
///   visualizer.
///  
///   Summaries are produced regularly during training, as controlled by
///   the "summary_interval_secs" attribute of the training operation.
///   Summaries are also produced at the end of an evaluation.
struct Tensorflow_Summary: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_Summary"}
  public var protoMessageName: String {return "Summary"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "value": 1,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "value": 1,
  ]}

  struct Image: ProtobufGeneratedMessage {
    public var swiftClassName: String {return "Tensorflow_Summary.Image"}
    public var protoMessageName: String {return "Image"}
    public var protoPackageName: String {return "tensorflow"}
    public var jsonFieldNames: [String: Int] {return [
      "height": 1,
      "width": 2,
      "colorspace": 3,
      "encodedImageString": 4,
    ]}
    public var protoFieldNames: [String: Int] {return [
      "height": 1,
      "width": 2,
      "colorspace": 3,
      "encoded_image_string": 4,
    ]}

    ///   Dimensions of the image.
    public var height: Int32 = 0

    public var width: Int32 = 0

    ///   Valid colorspace values are
    ///     1 - grayscale
    ///     2 - grayscale + alpha
    ///     3 - RGB
    ///     4 - RGBA
    ///     5 - DIGITAL_YUV
    ///     6 - BGRA
    public var colorspace: Int32 = 0

    ///   Image data in encoded format.  All image formats supported by
    ///   image_codec::CoderUtil can be stored here.
    public var encodedImageString: Data = Data()

    public init() {}

    public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodeSingularField(fieldType: ProtobufInt32.self, value: &height)
      case 2: handled = try setter.decodeSingularField(fieldType: ProtobufInt32.self, value: &width)
      case 3: handled = try setter.decodeSingularField(fieldType: ProtobufInt32.self, value: &colorspace)
      case 4: handled = try setter.decodeSingularField(fieldType: ProtobufBytes.self, value: &encodedImageString)
      default:
        handled = false
      }
      return handled
    }

    public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
      if height != 0 {
        try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: height, protoFieldNumber: 1, protoFieldName: "height", jsonFieldName: "height", swiftFieldName: "height")
      }
      if width != 0 {
        try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: width, protoFieldNumber: 2, protoFieldName: "width", jsonFieldName: "width", swiftFieldName: "width")
      }
      if colorspace != 0 {
        try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: colorspace, protoFieldNumber: 3, protoFieldName: "colorspace", jsonFieldName: "colorspace", swiftFieldName: "colorspace")
      }
      if encodedImageString != Data() {
        try visitor.visitSingularField(fieldType: ProtobufBytes.self, value: encodedImageString, protoFieldNumber: 4, protoFieldName: "encoded_image_string", jsonFieldName: "encodedImageString", swiftFieldName: "encodedImageString")
      }
    }

    public func _protoc_generated_isEqualTo(other: Tensorflow_Summary.Image) -> Bool {
      if height != other.height {return false}
      if width != other.width {return false}
      if colorspace != other.colorspace {return false}
      if encodedImageString != other.encodedImageString {return false}
      return true
    }
  }

  struct Audio: ProtobufGeneratedMessage {
    public var swiftClassName: String {return "Tensorflow_Summary.Audio"}
    public var protoMessageName: String {return "Audio"}
    public var protoPackageName: String {return "tensorflow"}
    public var jsonFieldNames: [String: Int] {return [
      "sampleRate": 1,
      "numChannels": 2,
      "lengthFrames": 3,
      "encodedAudioString": 4,
      "contentType": 5,
    ]}
    public var protoFieldNames: [String: Int] {return [
      "sample_rate": 1,
      "num_channels": 2,
      "length_frames": 3,
      "encoded_audio_string": 4,
      "content_type": 5,
    ]}

    ///   Sample rate of the audio in Hz.
    public var sampleRate: Float = 0

    ///   Number of channels of audio.
    public var numChannels: Int64 = 0

    ///   Length of the audio in frames (samples per channel).
    public var lengthFrames: Int64 = 0

    ///   Encoded audio data and its associated RFC 2045 content type (e.g.
    ///   "audio/wav").
    public var encodedAudioString: Data = Data()

    public var contentType: String = ""

    public init() {}

    public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodeSingularField(fieldType: ProtobufFloat.self, value: &sampleRate)
      case 2: handled = try setter.decodeSingularField(fieldType: ProtobufInt64.self, value: &numChannels)
      case 3: handled = try setter.decodeSingularField(fieldType: ProtobufInt64.self, value: &lengthFrames)
      case 4: handled = try setter.decodeSingularField(fieldType: ProtobufBytes.self, value: &encodedAudioString)
      case 5: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &contentType)
      default:
        handled = false
      }
      return handled
    }

    public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
      if sampleRate != 0 {
        try visitor.visitSingularField(fieldType: ProtobufFloat.self, value: sampleRate, protoFieldNumber: 1, protoFieldName: "sample_rate", jsonFieldName: "sampleRate", swiftFieldName: "sampleRate")
      }
      if numChannels != 0 {
        try visitor.visitSingularField(fieldType: ProtobufInt64.self, value: numChannels, protoFieldNumber: 2, protoFieldName: "num_channels", jsonFieldName: "numChannels", swiftFieldName: "numChannels")
      }
      if lengthFrames != 0 {
        try visitor.visitSingularField(fieldType: ProtobufInt64.self, value: lengthFrames, protoFieldNumber: 3, protoFieldName: "length_frames", jsonFieldName: "lengthFrames", swiftFieldName: "lengthFrames")
      }
      if encodedAudioString != Data() {
        try visitor.visitSingularField(fieldType: ProtobufBytes.self, value: encodedAudioString, protoFieldNumber: 4, protoFieldName: "encoded_audio_string", jsonFieldName: "encodedAudioString", swiftFieldName: "encodedAudioString")
      }
      if contentType != "" {
        try visitor.visitSingularField(fieldType: ProtobufString.self, value: contentType, protoFieldNumber: 5, protoFieldName: "content_type", jsonFieldName: "contentType", swiftFieldName: "contentType")
      }
    }

    public func _protoc_generated_isEqualTo(other: Tensorflow_Summary.Audio) -> Bool {
      if sampleRate != other.sampleRate {return false}
      if numChannels != other.numChannels {return false}
      if lengthFrames != other.lengthFrames {return false}
      if encodedAudioString != other.encodedAudioString {return false}
      if contentType != other.contentType {return false}
      return true
    }
  }

  struct Value: ProtobufGeneratedMessage {
    public var swiftClassName: String {return "Tensorflow_Summary.Value"}
    public var protoMessageName: String {return "Value"}
    public var protoPackageName: String {return "tensorflow"}
    public var jsonFieldNames: [String: Int] {return [
      "nodeName": 7,
      "tag": 1,
      "simpleValue": 2,
      "obsoleteOldStyleHistogram": 3,
      "image": 4,
      "histo": 5,
      "audio": 6,
      "tensor": 8,
    ]}
    public var protoFieldNames: [String: Int] {return [
      "node_name": 7,
      "tag": 1,
      "simple_value": 2,
      "obsolete_old_style_histogram": 3,
      "image": 4,
      "histo": 5,
      "audio": 6,
      "tensor": 8,
    ]}

    private class _StorageClass {
      typealias ProtobufExtendedMessage = Tensorflow_Summary.Value
      var _nodeName: String = ""
      var _tag: String = ""
      var _value = Tensorflow_Summary.Value.OneOf_Value()

      init() {}

      func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
        let handled: Bool
        switch protoFieldNumber {
        case 7: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &_nodeName)
        case 1: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &_tag)
        case 2, 3, 4, 5, 6, 8:
          handled = try _value.decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
        default:
          handled = false
        }
        return handled
      }

      func traverse(visitor: inout ProtobufVisitor) throws {
        if _tag != "" {
          try visitor.visitSingularField(fieldType: ProtobufString.self, value: _tag, protoFieldNumber: 1, protoFieldName: "tag", jsonFieldName: "tag", swiftFieldName: "tag")
        }
        try _value.traverse(visitor: &visitor, start: 2, end: 7)
        if _nodeName != "" {
          try visitor.visitSingularField(fieldType: ProtobufString.self, value: _nodeName, protoFieldNumber: 7, protoFieldName: "node_name", jsonFieldName: "nodeName", swiftFieldName: "nodeName")
        }
        try _value.traverse(visitor: &visitor, start: 8, end: 9)
      }

      func isEqualTo(other: _StorageClass) -> Bool {
        if _nodeName != other._nodeName {return false}
        if _tag != other._tag {return false}
        if _value != other._value {return false}
        return true
      }

      func copy() -> _StorageClass {
        let clone = _StorageClass()
        clone._nodeName = _nodeName
        clone._tag = _tag
        clone._value = _value
        return clone
      }
    }

    private var _storage = _StorageClass()

    enum OneOf_Value: ExpressibleByNilLiteral, ProtobufOneofEnum {
      case simpleValue(Float)
      case obsoleteOldStyleHistogram(Data)
      case image(Tensorflow_Summary.Image)
      case histo(Tensorflow_HistogramProto)
      case audio(Tensorflow_Summary.Audio)
      case tensor(Tensorflow_TensorProto)
      case None

      public init(nilLiteral: ()) {
        self = .None
      }

      public init() {
        self = .None
      }

      public mutating func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
        if self != .None && setter.rejectConflictingOneof {
          throw ProtobufDecodingError.duplicatedOneOf
        }
        let handled: Bool
        switch protoFieldNumber {
        case 2:
          var value = Float()
          handled = try setter.decodeSingularField(fieldType: ProtobufFloat.self, value: &value)
          self = .simpleValue(value)
        case 3:
          var value = Data()
          handled = try setter.decodeSingularField(fieldType: ProtobufBytes.self, value: &value)
          self = .obsoleteOldStyleHistogram(value)
        case 4:
          var value: Tensorflow_Summary.Image?
          handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_Summary.Image.self, value: &value)
          if let value = value, handled {
            self = .image(value)
          }
        case 5:
          var value: Tensorflow_HistogramProto?
          handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_HistogramProto.self, value: &value)
          if let value = value, handled {
            self = .histo(value)
          }
        case 6:
          var value: Tensorflow_Summary.Audio?
          handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_Summary.Audio.self, value: &value)
          if let value = value, handled {
            self = .audio(value)
          }
        case 8:
          var value: Tensorflow_TensorProto?
          handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_TensorProto.self, value: &value)
          if let value = value, handled {
            self = .tensor(value)
          }
        default:
          handled = false
          self = .None
        }
        return handled
      }

      public func traverse(visitor: inout ProtobufVisitor, start: Int, end: Int) throws {
        switch self {
        case .simpleValue(let v):
          if start <= 2 && 2 < end {
            try visitor.visitSingularField(fieldType: ProtobufFloat.self, value: v, protoFieldNumber: 2, protoFieldName: "simple_value", jsonFieldName: "simpleValue", swiftFieldName: "simpleValue")
          }
        case .obsoleteOldStyleHistogram(let v):
          if start <= 3 && 3 < end {
            try visitor.visitSingularField(fieldType: ProtobufBytes.self, value: v, protoFieldNumber: 3, protoFieldName: "obsolete_old_style_histogram", jsonFieldName: "obsoleteOldStyleHistogram", swiftFieldName: "obsoleteOldStyleHistogram")
          }
        case .image(let v):
          if start <= 4 && 4 < end {
            try visitor.visitSingularMessageField(value: v, protoFieldNumber: 4, protoFieldName: "image", jsonFieldName: "image", swiftFieldName: "image")
          }
        case .histo(let v):
          if start <= 5 && 5 < end {
            try visitor.visitSingularMessageField(value: v, protoFieldNumber: 5, protoFieldName: "histo", jsonFieldName: "histo", swiftFieldName: "histo")
          }
        case .audio(let v):
          if start <= 6 && 6 < end {
            try visitor.visitSingularMessageField(value: v, protoFieldNumber: 6, protoFieldName: "audio", jsonFieldName: "audio", swiftFieldName: "audio")
          }
        case .tensor(let v):
          if start <= 8 && 8 < end {
            try visitor.visitSingularMessageField(value: v, protoFieldNumber: 8, protoFieldName: "tensor", jsonFieldName: "tensor", swiftFieldName: "tensor")
          }
        case .None:
          break
        }
      }
    }

    ///   Name of the node that output this summary; in general, the name of a
    ///   TensorSummary node. If the node in question has multiple outputs, then
    ///   a ":\d+" suffix will be appended, like "some_op:13".
    ///   Might not be set for legacy summaries (i.e. those not using the tensor
    ///   value field)
    public var nodeName: String {
      get {return _storage._nodeName}
      set {_uniqueStorage()._nodeName = newValue}
    }

    ///   Tag name for the data.  Will only be used by legacy summaries
    ///   (ie. those not using the tensor value field)
    ///   For legacy summaries, will be used as the title of the graph
    ///   in the visualizer.
    ///  
    ///   Tag is usually "op_name:value_name", where "op_name" itself can have
    ///   structure to indicate grouping.
    public var tag: String {
      get {return _storage._tag}
      set {_uniqueStorage()._tag = newValue}
    }

    public var simpleValue: Float {
      get {
        if case .simpleValue(let v) = _storage._value {
          return v
        }
        return 0
      }
      set {
        _uniqueStorage()._value = .simpleValue(newValue)
      }
    }

    public var obsoleteOldStyleHistogram: Data {
      get {
        if case .obsoleteOldStyleHistogram(let v) = _storage._value {
          return v
        }
        return Data()
      }
      set {
        _uniqueStorage()._value = .obsoleteOldStyleHistogram(newValue)
      }
    }

    public var image: Tensorflow_Summary.Image {
      get {
        if case .image(let v) = _storage._value {
          return v
        }
        return Tensorflow_Summary.Image()
      }
      set {
        _uniqueStorage()._value = .image(newValue)
      }
    }

    public var histo: Tensorflow_HistogramProto {
      get {
        if case .histo(let v) = _storage._value {
          return v
        }
        return Tensorflow_HistogramProto()
      }
      set {
        _uniqueStorage()._value = .histo(newValue)
      }
    }

    public var audio: Tensorflow_Summary.Audio {
      get {
        if case .audio(let v) = _storage._value {
          return v
        }
        return Tensorflow_Summary.Audio()
      }
      set {
        _uniqueStorage()._value = .audio(newValue)
      }
    }

    public var tensor: Tensorflow_TensorProto {
      get {
        if case .tensor(let v) = _storage._value {
          return v
        }
        return Tensorflow_TensorProto()
      }
      set {
        _uniqueStorage()._value = .tensor(newValue)
      }
    }

    public var value: OneOf_Value {
      get {return _storage._value}
      set {
        _uniqueStorage()._value = newValue
      }
    }

    public init() {}

    public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
    }

    public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
      try _storage.traverse(visitor: &visitor)
    }

    public func _protoc_generated_isEqualTo(other: Tensorflow_Summary.Value) -> Bool {
      return _storage === other._storage || _storage.isEqualTo(other: other._storage)
    }

    private mutating func _uniqueStorage() -> _StorageClass {
      if !isKnownUniquelyReferenced(&_storage) {
        _storage = _storage.copy()
      }
      return _storage
    }
  }

  ///   Set of values for the summary.
  public var value: [Tensorflow_Summary.Value] = []

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeRepeatedMessageField(fieldType: Tensorflow_Summary.Value.self, value: &value)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if !value.isEmpty {
      try visitor.visitRepeatedMessageField(value: value, protoFieldNumber: 1, protoFieldName: "value", jsonFieldName: "value", swiftFieldName: "value")
    }
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_Summary) -> Bool {
    if value != other.value {return false}
    return true
  }
}

func ==(lhs: Tensorflow_Summary.Value.OneOf_Value, rhs: Tensorflow_Summary.Value.OneOf_Value) -> Bool {
  switch (lhs, rhs) {
  case (.simpleValue(let l), .simpleValue(let r)): return l == r
  case (.obsoleteOldStyleHistogram(let l), .obsoleteOldStyleHistogram(let r)): return l == r
  case (.image(let l), .image(let r)): return l == r
  case (.histo(let l), .histo(let r)): return l == r
  case (.audio(let l), .audio(let r)): return l == r
  case (.tensor(let l), .tensor(let r)): return l == r
  case (.None, .None): return true
  default: return false
  }
}
