/*
 * DO NOT EDIT.
 *
 * Generated by the protocol buffer compiler.
 * Source: tensorflow/core/util/saved_tensor_slice.proto
 *
 */

//  Protocol buffers for saved tensor slices. It's used for the brain tensor
//  ops checkpoints and the V3 checkpoints in dist_belief.

//  A checkpoint file is an sstable. The value for each record is a serialized
//  SavedTensorSlices message (defined below).
// 
//  Each checkpoint file has a record with the empty key (""), which corresponds
//  to a SavedTensorSlices message that contains a "meta", that serves as a
//  table of contents on all the tensor slices saved in this file. Since the key
//  is "", it's always the first record in each file.
// 
//  Each of the rest of the records in a checkpoint stores the raw data of a
//  particular tensor slice, in SavedSlice format. The corresponding key is an
//  ordered code that encodes the name of the tensor and the slice
//  information. The name is also stored in the SaveSlice message for ease of
//  debugging and manual examination.

import Foundation
import SwiftProtobuf


///   Metadata describing the set of slices of the same tensor saved in a
///   checkpoint file.
struct Tensorflow_SavedSliceMeta: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_SavedSliceMeta"}
  public var protoMessageName: String {return "SavedSliceMeta"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "name": 1,
    "shape": 2,
    "type": 3,
    "slice": 4,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "name": 1,
    "shape": 2,
    "type": 3,
    "slice": 4,
  ]}

  private class _StorageClass {
    typealias ProtobufExtendedMessage = Tensorflow_SavedSliceMeta
    var _name: String = ""
    var _shape: Tensorflow_TensorShapeProto? = nil
    var _type: Tensorflow_DataType = Tensorflow_DataType.dtInvalid
    var _slice: [Tensorflow_TensorSliceProto] = []

    init() {}

    func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &_name)
      case 2: handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_TensorShapeProto.self, value: &_shape)
      case 3: handled = try setter.decodeSingularField(fieldType: Tensorflow_DataType.self, value: &_type)
      case 4: handled = try setter.decodeRepeatedMessageField(fieldType: Tensorflow_TensorSliceProto.self, value: &_slice)
      default:
        handled = false
      }
      return handled
    }

    func traverse(visitor: inout ProtobufVisitor) throws {
      if _name != "" {
        try visitor.visitSingularField(fieldType: ProtobufString.self, value: _name, protoFieldNumber: 1, protoFieldName: "name", jsonFieldName: "name", swiftFieldName: "name")
      }
      if let v = _shape {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 2, protoFieldName: "shape", jsonFieldName: "shape", swiftFieldName: "shape")
      }
      if _type != Tensorflow_DataType.dtInvalid {
        try visitor.visitSingularField(fieldType: Tensorflow_DataType.self, value: _type, protoFieldNumber: 3, protoFieldName: "type", jsonFieldName: "type", swiftFieldName: "type")
      }
      if !_slice.isEmpty {
        try visitor.visitRepeatedMessageField(value: _slice, protoFieldNumber: 4, protoFieldName: "slice", jsonFieldName: "slice", swiftFieldName: "slice")
      }
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _name != other._name {return false}
      if _shape != other._shape {return false}
      if _type != other._type {return false}
      if _slice != other._slice {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._name = _name
      clone._shape = _shape
      clone._type = _type
      clone._slice = _slice
      return clone
    }
  }

  private var _storage = _StorageClass()

  ///   Name of the tensor.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  ///   Shape of the tensor
  public var shape: Tensorflow_TensorShapeProto {
    get {return _storage._shape ?? Tensorflow_TensorShapeProto()}
    set {_uniqueStorage()._shape = newValue}
  }
  public var hasShape: Bool {
    return _storage._shape != nil
  }
  public mutating func clearShape() {
    return _storage._shape = nil
  }

  ///   Type of the tensor
  public var type: Tensorflow_DataType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  ///   Explicit list of slices saved in the checkpoint file.
  public var slice: [Tensorflow_TensorSliceProto] {
    get {return _storage._slice}
    set {_uniqueStorage()._slice = newValue}
  }

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    try _storage.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_SavedSliceMeta) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

///   Metadata describing the set of tensor slices saved in a checkpoint file.
///   It is always stored at the beginning of each checkpoint file.
struct Tensorflow_SavedTensorSliceMeta: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_SavedTensorSliceMeta"}
  public var protoMessageName: String {return "SavedTensorSliceMeta"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "tensor": 1,
    "versions": 2,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "tensor": 1,
    "versions": 2,
  ]}

  private class _StorageClass {
    typealias ProtobufExtendedMessage = Tensorflow_SavedTensorSliceMeta
    var _tensor: [Tensorflow_SavedSliceMeta] = []
    var _versions: Tensorflow_VersionDef? = nil

    init() {}

    func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodeRepeatedMessageField(fieldType: Tensorflow_SavedSliceMeta.self, value: &_tensor)
      case 2: handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_VersionDef.self, value: &_versions)
      default:
        handled = false
      }
      return handled
    }

    func traverse(visitor: inout ProtobufVisitor) throws {
      if !_tensor.isEmpty {
        try visitor.visitRepeatedMessageField(value: _tensor, protoFieldNumber: 1, protoFieldName: "tensor", jsonFieldName: "tensor", swiftFieldName: "tensor")
      }
      if let v = _versions {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 2, protoFieldName: "versions", jsonFieldName: "versions", swiftFieldName: "versions")
      }
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _tensor != other._tensor {return false}
      if _versions != other._versions {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._tensor = _tensor
      clone._versions = _versions
      return clone
    }
  }

  private var _storage = _StorageClass()

  ///   Each SavedSliceMeta describes the slices for one tensor.
  public var tensor: [Tensorflow_SavedSliceMeta] {
    get {return _storage._tensor}
    set {_uniqueStorage()._tensor = newValue}
  }

  ///   Compatibility version of this checkpoint.  See core/public/version.h
  ///   for version history.
  public var versions: Tensorflow_VersionDef {
    get {return _storage._versions ?? Tensorflow_VersionDef()}
    set {_uniqueStorage()._versions = newValue}
  }
  public var hasVersions: Bool {
    return _storage._versions != nil
  }
  public mutating func clearVersions() {
    return _storage._versions = nil
  }

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    try _storage.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_SavedTensorSliceMeta) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

///   Saved tensor slice: it stores the name of the tensors, the slice, and the
///   raw data.
struct Tensorflow_SavedSlice: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_SavedSlice"}
  public var protoMessageName: String {return "SavedSlice"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "name": 1,
    "slice": 2,
    "data": 3,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "name": 1,
    "slice": 2,
    "data": 3,
  ]}

  private class _StorageClass {
    typealias ProtobufExtendedMessage = Tensorflow_SavedSlice
    var _name: String = ""
    var _slice: Tensorflow_TensorSliceProto? = nil
    var _data: Tensorflow_TensorProto? = nil

    init() {}

    func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &_name)
      case 2: handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_TensorSliceProto.self, value: &_slice)
      case 3: handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_TensorProto.self, value: &_data)
      default:
        handled = false
      }
      return handled
    }

    func traverse(visitor: inout ProtobufVisitor) throws {
      if _name != "" {
        try visitor.visitSingularField(fieldType: ProtobufString.self, value: _name, protoFieldNumber: 1, protoFieldName: "name", jsonFieldName: "name", swiftFieldName: "name")
      }
      if let v = _slice {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 2, protoFieldName: "slice", jsonFieldName: "slice", swiftFieldName: "slice")
      }
      if let v = _data {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 3, protoFieldName: "data", jsonFieldName: "data", swiftFieldName: "data")
      }
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _name != other._name {return false}
      if _slice != other._slice {return false}
      if _data != other._data {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._name = _name
      clone._slice = _slice
      clone._data = _data
      return clone
    }
  }

  private var _storage = _StorageClass()

  ///   Name of the tensor that this slice belongs to. This must be identical to
  ///   the name used to encode the key for this record.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  ///   Extent of the slice.  Must have one entry for each of the dimension of the
  ///   tensor that this slice belongs to.
  public var slice: Tensorflow_TensorSliceProto {
    get {return _storage._slice ?? Tensorflow_TensorSliceProto()}
    set {_uniqueStorage()._slice = newValue}
  }
  public var hasSlice: Bool {
    return _storage._slice != nil
  }
  public mutating func clearSlice() {
    return _storage._slice = nil
  }

  ///   The raw data of the slice is stored as a TensorProto. Only raw data are
  ///   stored (we don't fill in fields such as dtype or tensor_shape).
  public var data: Tensorflow_TensorProto {
    get {return _storage._data ?? Tensorflow_TensorProto()}
    set {_uniqueStorage()._data = newValue}
  }
  public var hasData: Bool {
    return _storage._data != nil
  }
  public mutating func clearData() {
    return _storage._data = nil
  }

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    try _storage.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_SavedSlice) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

///   Each record in a v3 checkpoint file is a serialized SavedTensorSlices
///   message.
struct Tensorflow_SavedTensorSlices: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_SavedTensorSlices"}
  public var protoMessageName: String {return "SavedTensorSlices"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "meta": 1,
    "data": 2,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "meta": 1,
    "data": 2,
  ]}

  private class _StorageClass {
    typealias ProtobufExtendedMessage = Tensorflow_SavedTensorSlices
    var _meta: Tensorflow_SavedTensorSliceMeta? = nil
    var _data: Tensorflow_SavedSlice? = nil

    init() {}

    func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_SavedTensorSliceMeta.self, value: &_meta)
      case 2: handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_SavedSlice.self, value: &_data)
      default:
        handled = false
      }
      return handled
    }

    func traverse(visitor: inout ProtobufVisitor) throws {
      if let v = _meta {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 1, protoFieldName: "meta", jsonFieldName: "meta", swiftFieldName: "meta")
      }
      if let v = _data {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 2, protoFieldName: "data", jsonFieldName: "data", swiftFieldName: "data")
      }
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _meta != other._meta {return false}
      if _data != other._data {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._meta = _meta
      clone._data = _data
      return clone
    }
  }

  private var _storage = _StorageClass()

  ///   This is only present at the first item of each checkpoint file and serves
  ///   as a table of contents, listing all the tensor slices saved in this file.
  public var meta: Tensorflow_SavedTensorSliceMeta {
    get {return _storage._meta ?? Tensorflow_SavedTensorSliceMeta()}
    set {_uniqueStorage()._meta = newValue}
  }
  public var hasMeta: Bool {
    return _storage._meta != nil
  }
  public mutating func clearMeta() {
    return _storage._meta = nil
  }

  ///   This exists in all but the first item of each checkpoint file.
  public var data: Tensorflow_SavedSlice {
    get {return _storage._data ?? Tensorflow_SavedSlice()}
    set {_uniqueStorage()._data = newValue}
  }
  public var hasData: Bool {
    return _storage._data != nil
  }
  public mutating func clearData() {
    return _storage._data = nil
  }

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    try _storage.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_SavedTensorSlices) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}
