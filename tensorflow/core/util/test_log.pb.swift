/*
 * DO NOT EDIT.
 *
 * Generated by the protocol buffer compiler.
 * Source: tensorflow/core/util/test_log.proto
 *
 */

///   Protocol messages for describing the results of benchmarks and unit tests.

import Foundation
import SwiftProtobuf


struct Tensorflow_EntryValue: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_EntryValue"}
  public var protoMessageName: String {return "EntryValue"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "doubleValue": 1,
    "stringValue": 2,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "double_value": 1,
    "string_value": 2,
  ]}

  enum OneOf_Kind: ExpressibleByNilLiteral, ProtobufOneofEnum {
    case doubleValue(Double)
    case stringValue(String)
    case None

    public init(nilLiteral: ()) {
      self = .None
    }

    public init() {
      self = .None
    }

    public mutating func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      if self != .None && setter.rejectConflictingOneof {
        throw ProtobufDecodingError.duplicatedOneOf
      }
      let handled: Bool
      switch protoFieldNumber {
      case 1:
        var value = Double()
        handled = try setter.decodeSingularField(fieldType: ProtobufDouble.self, value: &value)
        self = .doubleValue(value)
      case 2:
        var value = String()
        handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &value)
        self = .stringValue(value)
      default:
        handled = false
        self = .None
      }
      return handled
    }

    public func traverse(visitor: inout ProtobufVisitor, start: Int, end: Int) throws {
      switch self {
      case .doubleValue(let v):
        if start <= 1 && 1 < end {
          try visitor.visitSingularField(fieldType: ProtobufDouble.self, value: v, protoFieldNumber: 1, protoFieldName: "double_value", jsonFieldName: "doubleValue", swiftFieldName: "doubleValue")
        }
      case .stringValue(let v):
        if start <= 2 && 2 < end {
          try visitor.visitSingularField(fieldType: ProtobufString.self, value: v, protoFieldNumber: 2, protoFieldName: "string_value", jsonFieldName: "stringValue", swiftFieldName: "stringValue")
        }
      case .None:
        break
      }
    }
  }

  public var doubleValue: Double {
    get {
      if case .doubleValue(let v) = kind {
        return v
      }
      return 0
    }
    set {
      kind = .doubleValue(newValue)
    }
  }

  public var kind: Tensorflow_EntryValue.OneOf_Kind = .None

  public var stringValue: String {
    get {
      if case .stringValue(let v) = kind {
        return v
      }
      return ""
    }
    set {
      kind = .stringValue(newValue)
    }
  }

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1, 2:
      handled = try kind.decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    try kind.traverse(visitor: &visitor, start: 1, end: 3)
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_EntryValue) -> Bool {
    if kind != other.kind {return false}
    return true
  }
}

///   Each unit test or benchmark in a test or benchmark run provides
///   some set of information.  Here we provide some reasonable keys
///   one would expect to see, with optional key/value pairs for things
///   we haven't considered.
///  
///   This BenchmarkEntry should be emitted by each unit test or benchmark
///   reporter.
struct Tensorflow_BenchmarkEntry: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_BenchmarkEntry"}
  public var protoMessageName: String {return "BenchmarkEntry"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "name": 1,
    "iters": 2,
    "cpuTime": 3,
    "wallTime": 4,
    "throughput": 5,
    "extras": 6,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "name": 1,
    "iters": 2,
    "cpu_time": 3,
    "wall_time": 4,
    "throughput": 5,
    "extras": 6,
  ]}

  ///   The name of the specific benchmark or test
  ///   (e.g. BM_AdjustContrast_gpu_B_W_H)
  public var name: String = ""

  ///   If a benchmark, how many iterations it was run for
  public var iters: Int64 = 0

  ///   Total cpu time used for all iterations (in seconds)
  public var cpuTime: Double = 0

  ///   Total wall time used for all iterations (in seconds)
  public var wallTime: Double = 0

  ///   Throughput (in MB/s)
  public var throughput: Double = 0

  ///   Generic map from result key to value.
  public var extras: Dictionary<String,Tensorflow_EntryValue> = [:]

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &name)
    case 2: handled = try setter.decodeSingularField(fieldType: ProtobufInt64.self, value: &iters)
    case 3: handled = try setter.decodeSingularField(fieldType: ProtobufDouble.self, value: &cpuTime)
    case 4: handled = try setter.decodeSingularField(fieldType: ProtobufDouble.self, value: &wallTime)
    case 5: handled = try setter.decodeSingularField(fieldType: ProtobufDouble.self, value: &throughput)
    case 6: handled = try setter.decodeMapField(fieldType: ProtobufMap<ProtobufString,Tensorflow_EntryValue>.self, value: &extras)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if name != "" {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: name, protoFieldNumber: 1, protoFieldName: "name", jsonFieldName: "name", swiftFieldName: "name")
    }
    if iters != 0 {
      try visitor.visitSingularField(fieldType: ProtobufInt64.self, value: iters, protoFieldNumber: 2, protoFieldName: "iters", jsonFieldName: "iters", swiftFieldName: "iters")
    }
    if cpuTime != 0 {
      try visitor.visitSingularField(fieldType: ProtobufDouble.self, value: cpuTime, protoFieldNumber: 3, protoFieldName: "cpu_time", jsonFieldName: "cpuTime", swiftFieldName: "cpuTime")
    }
    if wallTime != 0 {
      try visitor.visitSingularField(fieldType: ProtobufDouble.self, value: wallTime, protoFieldNumber: 4, protoFieldName: "wall_time", jsonFieldName: "wallTime", swiftFieldName: "wallTime")
    }
    if throughput != 0 {
      try visitor.visitSingularField(fieldType: ProtobufDouble.self, value: throughput, protoFieldNumber: 5, protoFieldName: "throughput", jsonFieldName: "throughput", swiftFieldName: "throughput")
    }
    if !extras.isEmpty {
      try visitor.visitMapField(fieldType: ProtobufMap<ProtobufString,Tensorflow_EntryValue>.self, value: extras, protoFieldNumber: 6, protoFieldName: "extras", jsonFieldName: "extras", swiftFieldName: "extras")
    }
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_BenchmarkEntry) -> Bool {
    if name != other.name {return false}
    if iters != other.iters {return false}
    if cpuTime != other.cpuTime {return false}
    if wallTime != other.wallTime {return false}
    if throughput != other.throughput {return false}
    if extras != other.extras {return false}
    return true
  }
}

struct Tensorflow_BenchmarkEntries: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_BenchmarkEntries"}
  public var protoMessageName: String {return "BenchmarkEntries"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "entry": 1,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "entry": 1,
  ]}

  public var entry: [Tensorflow_BenchmarkEntry] = []

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeRepeatedMessageField(fieldType: Tensorflow_BenchmarkEntry.self, value: &entry)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if !entry.isEmpty {
      try visitor.visitRepeatedMessageField(value: entry, protoFieldNumber: 1, protoFieldName: "entry", jsonFieldName: "entry", swiftFieldName: "entry")
    }
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_BenchmarkEntries) -> Bool {
    if entry != other.entry {return false}
    return true
  }
}

struct Tensorflow_BuildConfiguration: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_BuildConfiguration"}
  public var protoMessageName: String {return "BuildConfiguration"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "mode": 1,
    "ccFlags": 2,
    "opts": 3,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "mode": 1,
    "cc_flags": 2,
    "opts": 3,
  ]}

  ///   opt, dbg, etc
  public var mode: String = ""

  ///   CC compiler flags, if known
  public var ccFlags: [String] = []

  ///   Bazel compilation options, if known
  public var opts: [String] = []

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &mode)
    case 2: handled = try setter.decodeRepeatedField(fieldType: ProtobufString.self, value: &ccFlags)
    case 3: handled = try setter.decodeRepeatedField(fieldType: ProtobufString.self, value: &opts)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if mode != "" {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: mode, protoFieldNumber: 1, protoFieldName: "mode", jsonFieldName: "mode", swiftFieldName: "mode")
    }
    if !ccFlags.isEmpty {
      try visitor.visitRepeatedField(fieldType: ProtobufString.self, value: ccFlags, protoFieldNumber: 2, protoFieldName: "cc_flags", jsonFieldName: "ccFlags", swiftFieldName: "ccFlags")
    }
    if !opts.isEmpty {
      try visitor.visitRepeatedField(fieldType: ProtobufString.self, value: opts, protoFieldNumber: 3, protoFieldName: "opts", jsonFieldName: "opts", swiftFieldName: "opts")
    }
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_BuildConfiguration) -> Bool {
    if mode != other.mode {return false}
    if ccFlags != other.ccFlags {return false}
    if opts != other.opts {return false}
    return true
  }
}

struct Tensorflow_CommitId: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_CommitId"}
  public var protoMessageName: String {return "CommitId"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "changelist": 1,
    "hash": 2,
    "snapshot": 3,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "changelist": 1,
    "hash": 2,
    "snapshot": 3,
  ]}

  enum OneOf_Kind: ExpressibleByNilLiteral, ProtobufOneofEnum {
    case changelist(Int64)
    case hash(String)
    case None

    public init(nilLiteral: ()) {
      self = .None
    }

    public init() {
      self = .None
    }

    public mutating func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      if self != .None && setter.rejectConflictingOneof {
        throw ProtobufDecodingError.duplicatedOneOf
      }
      let handled: Bool
      switch protoFieldNumber {
      case 1:
        var value = Int64()
        handled = try setter.decodeSingularField(fieldType: ProtobufInt64.self, value: &value)
        self = .changelist(value)
      case 2:
        var value = String()
        handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &value)
        self = .hash(value)
      default:
        handled = false
        self = .None
      }
      return handled
    }

    public func traverse(visitor: inout ProtobufVisitor, start: Int, end: Int) throws {
      switch self {
      case .changelist(let v):
        if start <= 1 && 1 < end {
          try visitor.visitSingularField(fieldType: ProtobufInt64.self, value: v, protoFieldNumber: 1, protoFieldName: "changelist", jsonFieldName: "changelist", swiftFieldName: "changelist")
        }
      case .hash(let v):
        if start <= 2 && 2 < end {
          try visitor.visitSingularField(fieldType: ProtobufString.self, value: v, protoFieldNumber: 2, protoFieldName: "hash", jsonFieldName: "hash", swiftFieldName: "hash")
        }
      case .None:
        break
      }
    }
  }

  public var changelist: Int64 {
    get {
      if case .changelist(let v) = kind {
        return v
      }
      return 0
    }
    set {
      kind = .changelist(newValue)
    }
  }

  public var kind: Tensorflow_CommitId.OneOf_Kind = .None

  public var hash: String {
    get {
      if case .hash(let v) = kind {
        return v
      }
      return ""
    }
    set {
      kind = .hash(newValue)
    }
  }

  ///   Hash of intermediate change between hash/changelist and what was tested.
  ///   Not used if the build is from a commit without modifications.
  public var snapshot: String = ""

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1, 2:
      handled = try kind.decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
    case 3: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &snapshot)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    try kind.traverse(visitor: &visitor, start: 1, end: 3)
    if snapshot != "" {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: snapshot, protoFieldNumber: 3, protoFieldName: "snapshot", jsonFieldName: "snapshot", swiftFieldName: "snapshot")
    }
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_CommitId) -> Bool {
    if kind != other.kind {return false}
    if snapshot != other.snapshot {return false}
    return true
  }
}

struct Tensorflow_CPUInfo: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_CPUInfo"}
  public var protoMessageName: String {return "CPUInfo"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "numCores": 1,
    "numCoresAllowed": 2,
    "mhzPerCpu": 3,
    "cpuInfo": 4,
    "cpuGovernor": 5,
    "cacheSize": 6,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "num_cores": 1,
    "num_cores_allowed": 2,
    "mhz_per_cpu": 3,
    "cpu_info": 4,
    "cpu_governor": 5,
    "cache_size": 6,
  ]}

  public var numCores: Int64 = 0

  public var numCoresAllowed: Int64 = 0

  ///   How fast are these cpus?
  public var mhzPerCpu: Double = 0

  ///   Additional cpu information. For example,
  ///   Intel Ivybridge with HyperThreading (24 cores) dL1:32KB dL2:256KB dL3:30MB
  public var cpuInfo: String = ""

  ///   What kind of cpu scaling is enabled on the host.
  ///   Examples include "performance", "ondemand", "conservative", "mixed".
  public var cpuGovernor: String = ""

  ///   Cache sizes (in bytes), e.g. "L2": 262144 (for 256KB)
  public var cacheSize: Dictionary<String,Int64> = [:]

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeSingularField(fieldType: ProtobufInt64.self, value: &numCores)
    case 2: handled = try setter.decodeSingularField(fieldType: ProtobufInt64.self, value: &numCoresAllowed)
    case 3: handled = try setter.decodeSingularField(fieldType: ProtobufDouble.self, value: &mhzPerCpu)
    case 4: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &cpuInfo)
    case 5: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &cpuGovernor)
    case 6: handled = try setter.decodeMapField(fieldType: ProtobufMap<ProtobufString,ProtobufInt64>.self, value: &cacheSize)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if numCores != 0 {
      try visitor.visitSingularField(fieldType: ProtobufInt64.self, value: numCores, protoFieldNumber: 1, protoFieldName: "num_cores", jsonFieldName: "numCores", swiftFieldName: "numCores")
    }
    if numCoresAllowed != 0 {
      try visitor.visitSingularField(fieldType: ProtobufInt64.self, value: numCoresAllowed, protoFieldNumber: 2, protoFieldName: "num_cores_allowed", jsonFieldName: "numCoresAllowed", swiftFieldName: "numCoresAllowed")
    }
    if mhzPerCpu != 0 {
      try visitor.visitSingularField(fieldType: ProtobufDouble.self, value: mhzPerCpu, protoFieldNumber: 3, protoFieldName: "mhz_per_cpu", jsonFieldName: "mhzPerCpu", swiftFieldName: "mhzPerCpu")
    }
    if cpuInfo != "" {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: cpuInfo, protoFieldNumber: 4, protoFieldName: "cpu_info", jsonFieldName: "cpuInfo", swiftFieldName: "cpuInfo")
    }
    if cpuGovernor != "" {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: cpuGovernor, protoFieldNumber: 5, protoFieldName: "cpu_governor", jsonFieldName: "cpuGovernor", swiftFieldName: "cpuGovernor")
    }
    if !cacheSize.isEmpty {
      try visitor.visitMapField(fieldType: ProtobufMap<ProtobufString,ProtobufInt64>.self, value: cacheSize, protoFieldNumber: 6, protoFieldName: "cache_size", jsonFieldName: "cacheSize", swiftFieldName: "cacheSize")
    }
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_CPUInfo) -> Bool {
    if numCores != other.numCores {return false}
    if numCoresAllowed != other.numCoresAllowed {return false}
    if mhzPerCpu != other.mhzPerCpu {return false}
    if cpuInfo != other.cpuInfo {return false}
    if cpuGovernor != other.cpuGovernor {return false}
    if cacheSize != other.cacheSize {return false}
    return true
  }
}

struct Tensorflow_MemoryInfo: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_MemoryInfo"}
  public var protoMessageName: String {return "MemoryInfo"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "total": 1,
    "available": 2,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "total": 1,
    "available": 2,
  ]}

  ///   Total virtual memory in bytes
  public var total: Int64 = 0

  ///   Immediately available memory in bytes
  public var available: Int64 = 0

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeSingularField(fieldType: ProtobufInt64.self, value: &total)
    case 2: handled = try setter.decodeSingularField(fieldType: ProtobufInt64.self, value: &available)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if total != 0 {
      try visitor.visitSingularField(fieldType: ProtobufInt64.self, value: total, protoFieldNumber: 1, protoFieldName: "total", jsonFieldName: "total", swiftFieldName: "total")
    }
    if available != 0 {
      try visitor.visitSingularField(fieldType: ProtobufInt64.self, value: available, protoFieldNumber: 2, protoFieldName: "available", jsonFieldName: "available", swiftFieldName: "available")
    }
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_MemoryInfo) -> Bool {
    if total != other.total {return false}
    if available != other.available {return false}
    return true
  }
}

struct Tensorflow_GPUInfo: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_GPUInfo"}
  public var protoMessageName: String {return "GPUInfo"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "model": 1,
    "uuid": 2,
    "busId": 3,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "model": 1,
    "uuid": 2,
    "bus_id": 3,
  ]}

  ///   e.g. "Tesla K40c"
  public var model: String = ""

  ///   Final entry in output of "nvidia-smi -L"
  public var uuid: String = ""

  ///   e.g. "0000:04:00.0"
  public var busId: String = ""

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &model)
    case 2: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &uuid)
    case 3: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &busId)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if model != "" {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: model, protoFieldNumber: 1, protoFieldName: "model", jsonFieldName: "model", swiftFieldName: "model")
    }
    if uuid != "" {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: uuid, protoFieldNumber: 2, protoFieldName: "uuid", jsonFieldName: "uuid", swiftFieldName: "uuid")
    }
    if busId != "" {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: busId, protoFieldNumber: 3, protoFieldName: "bus_id", jsonFieldName: "busId", swiftFieldName: "busId")
    }
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_GPUInfo) -> Bool {
    if model != other.model {return false}
    if uuid != other.uuid {return false}
    if busId != other.busId {return false}
    return true
  }
}

struct Tensorflow_PlatformInfo: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_PlatformInfo"}
  public var protoMessageName: String {return "PlatformInfo"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "bits": 1,
    "linkage": 2,
    "machine": 3,
    "release": 4,
    "system": 5,
    "version": 6,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "bits": 1,
    "linkage": 2,
    "machine": 3,
    "release": 4,
    "system": 5,
    "version": 6,
  ]}

  ///   e.g. '64bit'
  public var bits: String = ""

  ///   e.g. 'ELF'
  public var linkage: String = ""

  ///   e.g. 'i386'
  public var machine: String = ""

  ///   e.g. '3.13.0-76-generic'
  public var release: String = ""

  ///   e.g. 'Linux'
  public var system: String = ""

  ///   e.g. '#120-Ubuntu SMP Mon Jan 18 15:59:10 UTC 2016'
  public var version: String = ""

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &bits)
    case 2: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &linkage)
    case 3: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &machine)
    case 4: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &release)
    case 5: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &system)
    case 6: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &version)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if bits != "" {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: bits, protoFieldNumber: 1, protoFieldName: "bits", jsonFieldName: "bits", swiftFieldName: "bits")
    }
    if linkage != "" {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: linkage, protoFieldNumber: 2, protoFieldName: "linkage", jsonFieldName: "linkage", swiftFieldName: "linkage")
    }
    if machine != "" {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: machine, protoFieldNumber: 3, protoFieldName: "machine", jsonFieldName: "machine", swiftFieldName: "machine")
    }
    if release != "" {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: release, protoFieldNumber: 4, protoFieldName: "release", jsonFieldName: "release", swiftFieldName: "release")
    }
    if system != "" {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: system, protoFieldNumber: 5, protoFieldName: "system", jsonFieldName: "system", swiftFieldName: "system")
    }
    if version != "" {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: version, protoFieldNumber: 6, protoFieldName: "version", jsonFieldName: "version", swiftFieldName: "version")
    }
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_PlatformInfo) -> Bool {
    if bits != other.bits {return false}
    if linkage != other.linkage {return false}
    if machine != other.machine {return false}
    if release != other.release {return false}
    if system != other.system {return false}
    if version != other.version {return false}
    return true
  }
}

///   Matches DeviceAttributes
struct Tensorflow_AvailableDeviceInfo: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_AvailableDeviceInfo"}
  public var protoMessageName: String {return "AvailableDeviceInfo"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "name": 1,
    "type": 2,
    "memoryLimit": 3,
    "physicalDescription": 4,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "name": 1,
    "type": 2,
    "memory_limit": 3,
    "physical_description": 4,
  ]}

  ///   Device name.
  public var name: String = ""

  ///   Device type, e.g. 'CPU' or 'GPU'.
  public var type: String = ""

  ///   Memory capacity in bytes.
  public var memoryLimit: Int64 = 0

  ///   The physical description of this device.
  public var physicalDescription: String = ""

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &name)
    case 2: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &type)
    case 3: handled = try setter.decodeSingularField(fieldType: ProtobufInt64.self, value: &memoryLimit)
    case 4: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &physicalDescription)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if name != "" {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: name, protoFieldNumber: 1, protoFieldName: "name", jsonFieldName: "name", swiftFieldName: "name")
    }
    if type != "" {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: type, protoFieldNumber: 2, protoFieldName: "type", jsonFieldName: "type", swiftFieldName: "type")
    }
    if memoryLimit != 0 {
      try visitor.visitSingularField(fieldType: ProtobufInt64.self, value: memoryLimit, protoFieldNumber: 3, protoFieldName: "memory_limit", jsonFieldName: "memoryLimit", swiftFieldName: "memoryLimit")
    }
    if physicalDescription != "" {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: physicalDescription, protoFieldNumber: 4, protoFieldName: "physical_description", jsonFieldName: "physicalDescription", swiftFieldName: "physicalDescription")
    }
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_AvailableDeviceInfo) -> Bool {
    if name != other.name {return false}
    if type != other.type {return false}
    if memoryLimit != other.memoryLimit {return false}
    if physicalDescription != other.physicalDescription {return false}
    return true
  }
}

struct Tensorflow_MachineConfiguration: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_MachineConfiguration"}
  public var protoMessageName: String {return "MachineConfiguration"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "hostname": 1,
    "serialIdentifier": 7,
    "platformInfo": 2,
    "cpuInfo": 3,
    "deviceInfo": 4,
    "availableDeviceInfo": 5,
    "memoryInfo": 6,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "hostname": 1,
    "serial_identifier": 7,
    "platform_info": 2,
    "cpu_info": 3,
    "device_info": 4,
    "available_device_info": 5,
    "memory_info": 6,
  ]}

  private class _StorageClass {
    typealias ProtobufExtendedMessage = Tensorflow_MachineConfiguration
    var _hostname: String = ""
    var _serialIdentifier: String = ""
    var _platformInfo: Tensorflow_PlatformInfo? = nil
    var _cpuInfo: Tensorflow_CPUInfo? = nil
    var _deviceInfo: [Google_Protobuf_Any] = []
    var _availableDeviceInfo: [Tensorflow_AvailableDeviceInfo] = []
    var _memoryInfo: Tensorflow_MemoryInfo? = nil

    init() {}

    func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &_hostname)
      case 7: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &_serialIdentifier)
      case 2: handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_PlatformInfo.self, value: &_platformInfo)
      case 3: handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_CPUInfo.self, value: &_cpuInfo)
      case 4: handled = try setter.decodeRepeatedMessageField(fieldType: Google_Protobuf_Any.self, value: &_deviceInfo)
      case 5: handled = try setter.decodeRepeatedMessageField(fieldType: Tensorflow_AvailableDeviceInfo.self, value: &_availableDeviceInfo)
      case 6: handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_MemoryInfo.self, value: &_memoryInfo)
      default:
        handled = false
      }
      return handled
    }

    func traverse(visitor: inout ProtobufVisitor) throws {
      if _hostname != "" {
        try visitor.visitSingularField(fieldType: ProtobufString.self, value: _hostname, protoFieldNumber: 1, protoFieldName: "hostname", jsonFieldName: "hostname", swiftFieldName: "hostname")
      }
      if let v = _platformInfo {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 2, protoFieldName: "platform_info", jsonFieldName: "platformInfo", swiftFieldName: "platformInfo")
      }
      if let v = _cpuInfo {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 3, protoFieldName: "cpu_info", jsonFieldName: "cpuInfo", swiftFieldName: "cpuInfo")
      }
      if !_deviceInfo.isEmpty {
        try visitor.visitRepeatedMessageField(value: _deviceInfo, protoFieldNumber: 4, protoFieldName: "device_info", jsonFieldName: "deviceInfo", swiftFieldName: "deviceInfo")
      }
      if !_availableDeviceInfo.isEmpty {
        try visitor.visitRepeatedMessageField(value: _availableDeviceInfo, protoFieldNumber: 5, protoFieldName: "available_device_info", jsonFieldName: "availableDeviceInfo", swiftFieldName: "availableDeviceInfo")
      }
      if let v = _memoryInfo {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 6, protoFieldName: "memory_info", jsonFieldName: "memoryInfo", swiftFieldName: "memoryInfo")
      }
      if _serialIdentifier != "" {
        try visitor.visitSingularField(fieldType: ProtobufString.self, value: _serialIdentifier, protoFieldNumber: 7, protoFieldName: "serial_identifier", jsonFieldName: "serialIdentifier", swiftFieldName: "serialIdentifier")
      }
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _hostname != other._hostname {return false}
      if _serialIdentifier != other._serialIdentifier {return false}
      if _platformInfo != other._platformInfo {return false}
      if _cpuInfo != other._cpuInfo {return false}
      if _deviceInfo != other._deviceInfo {return false}
      if _availableDeviceInfo != other._availableDeviceInfo {return false}
      if _memoryInfo != other._memoryInfo {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._hostname = _hostname
      clone._serialIdentifier = _serialIdentifier
      clone._platformInfo = _platformInfo
      clone._cpuInfo = _cpuInfo
      clone._deviceInfo = _deviceInfo
      clone._availableDeviceInfo = _availableDeviceInfo
      clone._memoryInfo = _memoryInfo
      return clone
    }
  }

  private var _storage = _StorageClass()

  ///   Host name of machine that ran the benchmark.
  public var hostname: String {
    get {return _storage._hostname}
    set {_uniqueStorage()._hostname = newValue}
  }

  ///   Unique serial number of the machine.
  public var serialIdentifier: String {
    get {return _storage._serialIdentifier}
    set {_uniqueStorage()._serialIdentifier = newValue}
  }

  ///   Additional platform information.
  public var platformInfo: Tensorflow_PlatformInfo {
    get {return _storage._platformInfo ?? Tensorflow_PlatformInfo()}
    set {_uniqueStorage()._platformInfo = newValue}
  }
  public var hasPlatformInfo: Bool {
    return _storage._platformInfo != nil
  }
  public mutating func clearPlatformInfo() {
    return _storage._platformInfo = nil
  }

  ///   CPU Information.
  public var cpuInfo: Tensorflow_CPUInfo {
    get {return _storage._cpuInfo ?? Tensorflow_CPUInfo()}
    set {_uniqueStorage()._cpuInfo = newValue}
  }
  public var hasCpuInfo: Bool {
    return _storage._cpuInfo != nil
  }
  public mutating func clearCpuInfo() {
    return _storage._cpuInfo = nil
  }

  ///   Other devices that are attached and relevant (e.g. GPUInfo).
  public var deviceInfo: [Google_Protobuf_Any] {
    get {return _storage._deviceInfo}
    set {_uniqueStorage()._deviceInfo = newValue}
  }

  ///   Devices accessible to the test (e.g. as given by list_local_devices).
  public var availableDeviceInfo: [Tensorflow_AvailableDeviceInfo] {
    get {return _storage._availableDeviceInfo}
    set {_uniqueStorage()._availableDeviceInfo = newValue}
  }

  public var memoryInfo: Tensorflow_MemoryInfo {
    get {return _storage._memoryInfo ?? Tensorflow_MemoryInfo()}
    set {_uniqueStorage()._memoryInfo = newValue}
  }
  public var hasMemoryInfo: Bool {
    return _storage._memoryInfo != nil
  }
  public mutating func clearMemoryInfo() {
    return _storage._memoryInfo = nil
  }

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    try _storage.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_MachineConfiguration) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

///   Run-specific items such as arguments to the test / benchmark.
struct Tensorflow_RunConfiguration: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_RunConfiguration"}
  public var protoMessageName: String {return "RunConfiguration"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "argument": 1,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "argument": 1,
  ]}

  public var argument: [String] = []

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeRepeatedField(fieldType: ProtobufString.self, value: &argument)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if !argument.isEmpty {
      try visitor.visitRepeatedField(fieldType: ProtobufString.self, value: argument, protoFieldNumber: 1, protoFieldName: "argument", jsonFieldName: "argument", swiftFieldName: "argument")
    }
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_RunConfiguration) -> Bool {
    if argument != other.argument {return false}
    return true
  }
}

///   The output of one benchmark / test run.  Each run contains a list of
///   tests or benchmarks, stored as BenchmarkEntry messages.
///  
///   This message should be emitted by the reporter (which runs the
///   test / BM in a subprocess and then reads the emitted BenchmarkEntry messages;
///   usually from a serialized json file, finally collecting them along
///   with additional information about the test run.
struct Tensorflow_TestResults: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_TestResults"}
  public var protoMessageName: String {return "TestResults"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "target": 1,
    "entries": 2,
    "buildConfiguration": 3,
    "commitId": 4,
    "startTime": 5,
    "runTime": 6,
    "machineConfiguration": 7,
    "runConfiguration": 8,
    "name": 9,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "target": 1,
    "entries": 2,
    "build_configuration": 3,
    "commit_id": 4,
    "start_time": 5,
    "run_time": 6,
    "machine_configuration": 7,
    "run_configuration": 8,
    "name": 9,
  ]}

  private class _StorageClass {
    typealias ProtobufExtendedMessage = Tensorflow_TestResults
    var _target: String = ""
    var _entries: Tensorflow_BenchmarkEntries? = nil
    var _buildConfiguration: Tensorflow_BuildConfiguration? = nil
    var _commitId: Tensorflow_CommitId? = nil
    var _startTime: Int64 = 0
    var _runTime: Double = 0
    var _machineConfiguration: Tensorflow_MachineConfiguration? = nil
    var _runConfiguration: Tensorflow_RunConfiguration? = nil
    var _name: String = ""

    init() {}

    func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &_target)
      case 2: handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_BenchmarkEntries.self, value: &_entries)
      case 3: handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_BuildConfiguration.self, value: &_buildConfiguration)
      case 4: handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_CommitId.self, value: &_commitId)
      case 5: handled = try setter.decodeSingularField(fieldType: ProtobufInt64.self, value: &_startTime)
      case 6: handled = try setter.decodeSingularField(fieldType: ProtobufDouble.self, value: &_runTime)
      case 7: handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_MachineConfiguration.self, value: &_machineConfiguration)
      case 8: handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_RunConfiguration.self, value: &_runConfiguration)
      case 9: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &_name)
      default:
        handled = false
      }
      return handled
    }

    func traverse(visitor: inout ProtobufVisitor) throws {
      if _target != "" {
        try visitor.visitSingularField(fieldType: ProtobufString.self, value: _target, protoFieldNumber: 1, protoFieldName: "target", jsonFieldName: "target", swiftFieldName: "target")
      }
      if let v = _entries {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 2, protoFieldName: "entries", jsonFieldName: "entries", swiftFieldName: "entries")
      }
      if let v = _buildConfiguration {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 3, protoFieldName: "build_configuration", jsonFieldName: "buildConfiguration", swiftFieldName: "buildConfiguration")
      }
      if let v = _commitId {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 4, protoFieldName: "commit_id", jsonFieldName: "commitId", swiftFieldName: "commitId")
      }
      if _startTime != 0 {
        try visitor.visitSingularField(fieldType: ProtobufInt64.self, value: _startTime, protoFieldNumber: 5, protoFieldName: "start_time", jsonFieldName: "startTime", swiftFieldName: "startTime")
      }
      if _runTime != 0 {
        try visitor.visitSingularField(fieldType: ProtobufDouble.self, value: _runTime, protoFieldNumber: 6, protoFieldName: "run_time", jsonFieldName: "runTime", swiftFieldName: "runTime")
      }
      if let v = _machineConfiguration {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 7, protoFieldName: "machine_configuration", jsonFieldName: "machineConfiguration", swiftFieldName: "machineConfiguration")
      }
      if let v = _runConfiguration {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 8, protoFieldName: "run_configuration", jsonFieldName: "runConfiguration", swiftFieldName: "runConfiguration")
      }
      if _name != "" {
        try visitor.visitSingularField(fieldType: ProtobufString.self, value: _name, protoFieldNumber: 9, protoFieldName: "name", jsonFieldName: "name", swiftFieldName: "name")
      }
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _target != other._target {return false}
      if _entries != other._entries {return false}
      if _buildConfiguration != other._buildConfiguration {return false}
      if _commitId != other._commitId {return false}
      if _startTime != other._startTime {return false}
      if _runTime != other._runTime {return false}
      if _machineConfiguration != other._machineConfiguration {return false}
      if _runConfiguration != other._runConfiguration {return false}
      if _name != other._name {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._target = _target
      clone._entries = _entries
      clone._buildConfiguration = _buildConfiguration
      clone._commitId = _commitId
      clone._startTime = _startTime
      clone._runTime = _runTime
      clone._machineConfiguration = _machineConfiguration
      clone._runConfiguration = _runConfiguration
      clone._name = _name
      return clone
    }
  }

  private var _storage = _StorageClass()

  ///   The target of the run, e.g.:
  ///    //tensorflow/core:kernels_adjust_contrast_op_benchmark_test
  public var target: String {
    get {return _storage._target}
    set {_uniqueStorage()._target = newValue}
  }

  ///   The list of tests or benchmarks in this run.
  public var entries: Tensorflow_BenchmarkEntries {
    get {return _storage._entries ?? Tensorflow_BenchmarkEntries()}
    set {_uniqueStorage()._entries = newValue}
  }
  public var hasEntries: Bool {
    return _storage._entries != nil
  }
  public mutating func clearEntries() {
    return _storage._entries = nil
  }

  ///   The configuration of the build (compiled opt? with cuda? any copts?)
  public var buildConfiguration: Tensorflow_BuildConfiguration {
    get {return _storage._buildConfiguration ?? Tensorflow_BuildConfiguration()}
    set {_uniqueStorage()._buildConfiguration = newValue}
  }
  public var hasBuildConfiguration: Bool {
    return _storage._buildConfiguration != nil
  }
  public mutating func clearBuildConfiguration() {
    return _storage._buildConfiguration = nil
  }

  ///   The commit id (git hash or changelist)
  public var commitId: Tensorflow_CommitId {
    get {return _storage._commitId ?? Tensorflow_CommitId()}
    set {_uniqueStorage()._commitId = newValue}
  }
  public var hasCommitId: Bool {
    return _storage._commitId != nil
  }
  public mutating func clearCommitId() {
    return _storage._commitId = nil
  }

  ///   The time the run started (in seconds of UTC time since Unix epoch)
  public var startTime: Int64 {
    get {return _storage._startTime}
    set {_uniqueStorage()._startTime = newValue}
  }

  ///   The amount of time the total run took (wall time in seconds)
  public var runTime: Double {
    get {return _storage._runTime}
    set {_uniqueStorage()._runTime = newValue}
  }

  ///   Machine-specific parameters (Platform and CPU info)
  public var machineConfiguration: Tensorflow_MachineConfiguration {
    get {return _storage._machineConfiguration ?? Tensorflow_MachineConfiguration()}
    set {_uniqueStorage()._machineConfiguration = newValue}
  }
  public var hasMachineConfiguration: Bool {
    return _storage._machineConfiguration != nil
  }
  public mutating func clearMachineConfiguration() {
    return _storage._machineConfiguration = nil
  }

  ///   Run-specific parameters (arguments, etc)
  public var runConfiguration: Tensorflow_RunConfiguration {
    get {return _storage._runConfiguration ?? Tensorflow_RunConfiguration()}
    set {_uniqueStorage()._runConfiguration = newValue}
  }
  public var hasRunConfiguration: Bool {
    return _storage._runConfiguration != nil
  }
  public mutating func clearRunConfiguration() {
    return _storage._runConfiguration = nil
  }

  ///   Benchmark target identifier.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    try _storage.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_TestResults) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

func ==(lhs: Tensorflow_EntryValue.OneOf_Kind, rhs: Tensorflow_EntryValue.OneOf_Kind) -> Bool {
  switch (lhs, rhs) {
  case (.doubleValue(let l), .doubleValue(let r)): return l == r
  case (.stringValue(let l), .stringValue(let r)): return l == r
  case (.None, .None): return true
  default: return false
  }
}

func ==(lhs: Tensorflow_CommitId.OneOf_Kind, rhs: Tensorflow_CommitId.OneOf_Kind) -> Bool {
  switch (lhs, rhs) {
  case (.changelist(let l), .changelist(let r)): return l == r
  case (.hash(let l), .hash(let r)): return l == r
  case (.None, .None): return true
  default: return false
  }
}
