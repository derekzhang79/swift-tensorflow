/*
 * DO NOT EDIT.
 *
 * Generated by the protocol buffer compiler.
 * Source: tensorflow/contrib/tensorboard/plugins/projector/projector_config.proto
 *
 */

//  Copyright 2016 The TensorFlow Authors. All Rights Reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ==============================================================================

import Foundation
import SwiftProtobuf


struct Tensorflow_SpriteMetadata: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_SpriteMetadata"}
  public var protoMessageName: String {return "SpriteMetadata"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "imagePath": 1,
    "singleImageDim": 2,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "image_path": 1,
    "single_image_dim": 2,
  ]}

  public var imagePath: String = ""

  ///   [width, height] of a single image in the sprite.
  public var singleImageDim: [UInt32] = []

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &imagePath)
    case 2: handled = try setter.decodePackedField(fieldType: ProtobufUInt32.self, value: &singleImageDim)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if imagePath != "" {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: imagePath, protoFieldNumber: 1, protoFieldName: "image_path", jsonFieldName: "imagePath", swiftFieldName: "imagePath")
    }
    if !singleImageDim.isEmpty {
      try visitor.visitPackedField(fieldType: ProtobufUInt32.self, value: singleImageDim, protoFieldNumber: 2, protoFieldName: "single_image_dim", jsonFieldName: "singleImageDim", swiftFieldName: "singleImageDim")
    }
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_SpriteMetadata) -> Bool {
    if imagePath != other.imagePath {return false}
    if singleImageDim != other.singleImageDim {return false}
    return true
  }
}

struct Tensorflow_EmbeddingInfo: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_EmbeddingInfo"}
  public var protoMessageName: String {return "EmbeddingInfo"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "tensorName": 1,
    "metadataPath": 2,
    "bookmarksPath": 3,
    "tensorShape": 4,
    "sprite": 5,
    "tensorPath": 6,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "tensor_name": 1,
    "metadata_path": 2,
    "bookmarks_path": 3,
    "tensor_shape": 4,
    "sprite": 5,
    "tensor_path": 6,
  ]}

  private class _StorageClass {
    typealias ProtobufExtendedMessage = Tensorflow_EmbeddingInfo
    var _tensorName: String = ""
    var _metadataPath: String = ""
    var _bookmarksPath: String = ""
    var _tensorShape: [UInt32] = []
    var _sprite: Tensorflow_SpriteMetadata? = nil
    var _tensorPath: String = ""

    init() {}

    func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &_tensorName)
      case 2: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &_metadataPath)
      case 3: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &_bookmarksPath)
      case 4: handled = try setter.decodePackedField(fieldType: ProtobufUInt32.self, value: &_tensorShape)
      case 5: handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_SpriteMetadata.self, value: &_sprite)
      case 6: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &_tensorPath)
      default:
        handled = false
      }
      return handled
    }

    func traverse(visitor: inout ProtobufVisitor) throws {
      if _tensorName != "" {
        try visitor.visitSingularField(fieldType: ProtobufString.self, value: _tensorName, protoFieldNumber: 1, protoFieldName: "tensor_name", jsonFieldName: "tensorName", swiftFieldName: "tensorName")
      }
      if _metadataPath != "" {
        try visitor.visitSingularField(fieldType: ProtobufString.self, value: _metadataPath, protoFieldNumber: 2, protoFieldName: "metadata_path", jsonFieldName: "metadataPath", swiftFieldName: "metadataPath")
      }
      if _bookmarksPath != "" {
        try visitor.visitSingularField(fieldType: ProtobufString.self, value: _bookmarksPath, protoFieldNumber: 3, protoFieldName: "bookmarks_path", jsonFieldName: "bookmarksPath", swiftFieldName: "bookmarksPath")
      }
      if !_tensorShape.isEmpty {
        try visitor.visitPackedField(fieldType: ProtobufUInt32.self, value: _tensorShape, protoFieldNumber: 4, protoFieldName: "tensor_shape", jsonFieldName: "tensorShape", swiftFieldName: "tensorShape")
      }
      if let v = _sprite {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 5, protoFieldName: "sprite", jsonFieldName: "sprite", swiftFieldName: "sprite")
      }
      if _tensorPath != "" {
        try visitor.visitSingularField(fieldType: ProtobufString.self, value: _tensorPath, protoFieldNumber: 6, protoFieldName: "tensor_path", jsonFieldName: "tensorPath", swiftFieldName: "tensorPath")
      }
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _tensorName != other._tensorName {return false}
      if _metadataPath != other._metadataPath {return false}
      if _bookmarksPath != other._bookmarksPath {return false}
      if _tensorShape != other._tensorShape {return false}
      if _sprite != other._sprite {return false}
      if _tensorPath != other._tensorPath {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._tensorName = _tensorName
      clone._metadataPath = _metadataPath
      clone._bookmarksPath = _bookmarksPath
      clone._tensorShape = _tensorShape
      clone._sprite = _sprite
      clone._tensorPath = _tensorPath
      return clone
    }
  }

  private var _storage = _StorageClass()

  public var tensorName: String {
    get {return _storage._tensorName}
    set {_uniqueStorage()._tensorName = newValue}
  }

  public var metadataPath: String {
    get {return _storage._metadataPath}
    set {_uniqueStorage()._metadataPath = newValue}
  }

  public var bookmarksPath: String {
    get {return _storage._bookmarksPath}
    set {_uniqueStorage()._bookmarksPath = newValue}
  }

  ///   Shape of the 2D tensor [N x D]. If missing, it will be inferred from the
  ///   model checkpoint.
  public var tensorShape: [UInt32] {
    get {return _storage._tensorShape}
    set {_uniqueStorage()._tensorShape = newValue}
  }

  public var sprite: Tensorflow_SpriteMetadata {
    get {return _storage._sprite ?? Tensorflow_SpriteMetadata()}
    set {_uniqueStorage()._sprite = newValue}
  }
  public var hasSprite: Bool {
    return _storage._sprite != nil
  }
  public mutating func clearSprite() {
    return _storage._sprite = nil
  }

  ///   Path to the TSV file holding the tensor values. If missing, the tensor
  ///   is assumed to be stored in the model checkpoint.
  public var tensorPath: String {
    get {return _storage._tensorPath}
    set {_uniqueStorage()._tensorPath = newValue}
  }

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    try _storage.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_EmbeddingInfo) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

struct Tensorflow_ProjectorConfig: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_ProjectorConfig"}
  public var protoMessageName: String {return "ProjectorConfig"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "modelCheckpointPath": 1,
    "embeddings": 2,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "model_checkpoint_path": 1,
    "embeddings": 2,
  ]}

  public var modelCheckpointPath: String = ""

  public var embeddings: [Tensorflow_EmbeddingInfo] = []

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &modelCheckpointPath)
    case 2: handled = try setter.decodeRepeatedMessageField(fieldType: Tensorflow_EmbeddingInfo.self, value: &embeddings)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if modelCheckpointPath != "" {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: modelCheckpointPath, protoFieldNumber: 1, protoFieldName: "model_checkpoint_path", jsonFieldName: "modelCheckpointPath", swiftFieldName: "modelCheckpointPath")
    }
    if !embeddings.isEmpty {
      try visitor.visitRepeatedMessageField(value: embeddings, protoFieldNumber: 2, protoFieldName: "embeddings", jsonFieldName: "embeddings", swiftFieldName: "embeddings")
    }
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_ProjectorConfig) -> Bool {
    if modelCheckpointPath != other.modelCheckpointPath {return false}
    if embeddings != other.embeddings {return false}
    return true
  }
}
