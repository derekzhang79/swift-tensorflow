/*
 * DO NOT EDIT.
 *
 * Generated by the protocol buffer compiler.
 * Source: tensorflow/core/example/example_parser_configuration.proto
 *
 */

//  Protocol messages for describing the configuration of the ExampleParserOp.

import Foundation
import SwiftProtobuf


struct Tensorflow_VarLenFeatureProto: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_VarLenFeatureProto"}
  public var protoMessageName: String {return "VarLenFeatureProto"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "dtype": 1,
    "valuesOutputTensorName": 2,
    "indicesOutputTensorName": 3,
    "shapesOutputTensorName": 4,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "dtype": 1,
    "values_output_tensor_name": 2,
    "indices_output_tensor_name": 3,
    "shapes_output_tensor_name": 4,
  ]}

  public var dtype: Tensorflow_DataType = Tensorflow_DataType.dtInvalid

  public var valuesOutputTensorName: String = ""

  public var indicesOutputTensorName: String = ""

  public var shapesOutputTensorName: String = ""

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeSingularField(fieldType: Tensorflow_DataType.self, value: &dtype)
    case 2: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &valuesOutputTensorName)
    case 3: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &indicesOutputTensorName)
    case 4: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &shapesOutputTensorName)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if dtype != Tensorflow_DataType.dtInvalid {
      try visitor.visitSingularField(fieldType: Tensorflow_DataType.self, value: dtype, protoFieldNumber: 1, protoFieldName: "dtype", jsonFieldName: "dtype", swiftFieldName: "dtype")
    }
    if valuesOutputTensorName != "" {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: valuesOutputTensorName, protoFieldNumber: 2, protoFieldName: "values_output_tensor_name", jsonFieldName: "valuesOutputTensorName", swiftFieldName: "valuesOutputTensorName")
    }
    if indicesOutputTensorName != "" {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: indicesOutputTensorName, protoFieldNumber: 3, protoFieldName: "indices_output_tensor_name", jsonFieldName: "indicesOutputTensorName", swiftFieldName: "indicesOutputTensorName")
    }
    if shapesOutputTensorName != "" {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: shapesOutputTensorName, protoFieldNumber: 4, protoFieldName: "shapes_output_tensor_name", jsonFieldName: "shapesOutputTensorName", swiftFieldName: "shapesOutputTensorName")
    }
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_VarLenFeatureProto) -> Bool {
    if dtype != other.dtype {return false}
    if valuesOutputTensorName != other.valuesOutputTensorName {return false}
    if indicesOutputTensorName != other.indicesOutputTensorName {return false}
    if shapesOutputTensorName != other.shapesOutputTensorName {return false}
    return true
  }
}

struct Tensorflow_FixedLenFeatureProto: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_FixedLenFeatureProto"}
  public var protoMessageName: String {return "FixedLenFeatureProto"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "dtype": 1,
    "shape": 2,
    "defaultValue": 3,
    "valuesOutputTensorName": 4,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "dtype": 1,
    "shape": 2,
    "default_value": 3,
    "values_output_tensor_name": 4,
  ]}

  private class _StorageClass {
    typealias ProtobufExtendedMessage = Tensorflow_FixedLenFeatureProto
    var _dtype: Tensorflow_DataType = Tensorflow_DataType.dtInvalid
    var _shape: Tensorflow_TensorShapeProto? = nil
    var _defaultValue: Tensorflow_TensorProto? = nil
    var _valuesOutputTensorName: String = ""

    init() {}

    func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodeSingularField(fieldType: Tensorflow_DataType.self, value: &_dtype)
      case 2: handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_TensorShapeProto.self, value: &_shape)
      case 3: handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_TensorProto.self, value: &_defaultValue)
      case 4: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &_valuesOutputTensorName)
      default:
        handled = false
      }
      return handled
    }

    func traverse(visitor: inout ProtobufVisitor) throws {
      if _dtype != Tensorflow_DataType.dtInvalid {
        try visitor.visitSingularField(fieldType: Tensorflow_DataType.self, value: _dtype, protoFieldNumber: 1, protoFieldName: "dtype", jsonFieldName: "dtype", swiftFieldName: "dtype")
      }
      if let v = _shape {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 2, protoFieldName: "shape", jsonFieldName: "shape", swiftFieldName: "shape")
      }
      if let v = _defaultValue {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 3, protoFieldName: "default_value", jsonFieldName: "defaultValue", swiftFieldName: "defaultValue")
      }
      if _valuesOutputTensorName != "" {
        try visitor.visitSingularField(fieldType: ProtobufString.self, value: _valuesOutputTensorName, protoFieldNumber: 4, protoFieldName: "values_output_tensor_name", jsonFieldName: "valuesOutputTensorName", swiftFieldName: "valuesOutputTensorName")
      }
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _dtype != other._dtype {return false}
      if _shape != other._shape {return false}
      if _defaultValue != other._defaultValue {return false}
      if _valuesOutputTensorName != other._valuesOutputTensorName {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._dtype = _dtype
      clone._shape = _shape
      clone._defaultValue = _defaultValue
      clone._valuesOutputTensorName = _valuesOutputTensorName
      return clone
    }
  }

  private var _storage = _StorageClass()

  public var dtype: Tensorflow_DataType {
    get {return _storage._dtype}
    set {_uniqueStorage()._dtype = newValue}
  }

  public var shape: Tensorflow_TensorShapeProto {
    get {return _storage._shape ?? Tensorflow_TensorShapeProto()}
    set {_uniqueStorage()._shape = newValue}
  }
  public var hasShape: Bool {
    return _storage._shape != nil
  }
  public mutating func clearShape() {
    return _storage._shape = nil
  }

  public var defaultValue: Tensorflow_TensorProto {
    get {return _storage._defaultValue ?? Tensorflow_TensorProto()}
    set {_uniqueStorage()._defaultValue = newValue}
  }
  public var hasDefaultValue: Bool {
    return _storage._defaultValue != nil
  }
  public mutating func clearDefaultValue() {
    return _storage._defaultValue = nil
  }

  public var valuesOutputTensorName: String {
    get {return _storage._valuesOutputTensorName}
    set {_uniqueStorage()._valuesOutputTensorName = newValue}
  }

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    try _storage.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_FixedLenFeatureProto) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

struct Tensorflow_FeatureConfiguration: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_FeatureConfiguration"}
  public var protoMessageName: String {return "FeatureConfiguration"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "fixedLenFeature": 1,
    "varLenFeature": 2,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "fixed_len_feature": 1,
    "var_len_feature": 2,
  ]}

  private class _StorageClass {
    typealias ProtobufExtendedMessage = Tensorflow_FeatureConfiguration
    var _config = Tensorflow_FeatureConfiguration.OneOf_Config()

    init() {}

    func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1, 2:
        handled = try _config.decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
      default:
        handled = false
      }
      return handled
    }

    func traverse(visitor: inout ProtobufVisitor) throws {
      try _config.traverse(visitor: &visitor, start: 1, end: 3)
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _config != other._config {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._config = _config
      return clone
    }
  }

  private var _storage = _StorageClass()

  enum OneOf_Config: ExpressibleByNilLiteral, ProtobufOneofEnum {
    case fixedLenFeature(Tensorflow_FixedLenFeatureProto)
    case varLenFeature(Tensorflow_VarLenFeatureProto)
    case None

    public init(nilLiteral: ()) {
      self = .None
    }

    public init() {
      self = .None
    }

    public mutating func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      if self != .None && setter.rejectConflictingOneof {
        throw ProtobufDecodingError.duplicatedOneOf
      }
      let handled: Bool
      switch protoFieldNumber {
      case 1:
        var value: Tensorflow_FixedLenFeatureProto?
        handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_FixedLenFeatureProto.self, value: &value)
        if let value = value, handled {
          self = .fixedLenFeature(value)
        }
      case 2:
        var value: Tensorflow_VarLenFeatureProto?
        handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_VarLenFeatureProto.self, value: &value)
        if let value = value, handled {
          self = .varLenFeature(value)
        }
      default:
        handled = false
        self = .None
      }
      return handled
    }

    public func traverse(visitor: inout ProtobufVisitor, start: Int, end: Int) throws {
      switch self {
      case .fixedLenFeature(let v):
        if start <= 1 && 1 < end {
          try visitor.visitSingularMessageField(value: v, protoFieldNumber: 1, protoFieldName: "fixed_len_feature", jsonFieldName: "fixedLenFeature", swiftFieldName: "fixedLenFeature")
        }
      case .varLenFeature(let v):
        if start <= 2 && 2 < end {
          try visitor.visitSingularMessageField(value: v, protoFieldNumber: 2, protoFieldName: "var_len_feature", jsonFieldName: "varLenFeature", swiftFieldName: "varLenFeature")
        }
      case .None:
        break
      }
    }
  }

  public var fixedLenFeature: Tensorflow_FixedLenFeatureProto {
    get {
      if case .fixedLenFeature(let v) = _storage._config {
        return v
      }
      return Tensorflow_FixedLenFeatureProto()
    }
    set {
      _uniqueStorage()._config = .fixedLenFeature(newValue)
    }
  }

  public var varLenFeature: Tensorflow_VarLenFeatureProto {
    get {
      if case .varLenFeature(let v) = _storage._config {
        return v
      }
      return Tensorflow_VarLenFeatureProto()
    }
    set {
      _uniqueStorage()._config = .varLenFeature(newValue)
    }
  }

  public var config: OneOf_Config {
    get {return _storage._config}
    set {
      _uniqueStorage()._config = newValue
    }
  }

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    try _storage.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_FeatureConfiguration) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

struct Tensorflow_ExampleParserConfiguration: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_ExampleParserConfiguration"}
  public var protoMessageName: String {return "ExampleParserConfiguration"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "featureMap": 1,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "feature_map": 1,
  ]}

  public var featureMap: Dictionary<String,Tensorflow_FeatureConfiguration> = [:]

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeMapField(fieldType: ProtobufMap<ProtobufString,Tensorflow_FeatureConfiguration>.self, value: &featureMap)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if !featureMap.isEmpty {
      try visitor.visitMapField(fieldType: ProtobufMap<ProtobufString,Tensorflow_FeatureConfiguration>.self, value: featureMap, protoFieldNumber: 1, protoFieldName: "feature_map", jsonFieldName: "featureMap", swiftFieldName: "featureMap")
    }
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_ExampleParserConfiguration) -> Bool {
    if featureMap != other.featureMap {return false}
    return true
  }
}

func ==(lhs: Tensorflow_FeatureConfiguration.OneOf_Config, rhs: Tensorflow_FeatureConfiguration.OneOf_Config) -> Bool {
  switch (lhs, rhs) {
  case (.fixedLenFeature(let l), .fixedLenFeature(let r)): return l == r
  case (.varLenFeature(let l), .varLenFeature(let r)): return l == r
  case (.None, .None): return true
  default: return false
  }
}
