/*
 * DO NOT EDIT.
 *
 * Generated by the protocol buffer compiler.
 * Source: tensorflow/core/example/feature.proto
 *
 */

//  Protocol messages for describing features for machine learning model
//  training or inference.
// 
//  There are three base Feature types:
//    - bytes
//    - float
//    - int64
// 
//  A Feature contains Lists which may hold zero or more values.  These
//  lists are the base values BytesList, FloatList, Int64List.
// 
//  Features are organized into categories by name.  The Features message
//  contains the mapping from name to Feature.
// 
//  Example Features for a movie recommendation application:
//    feature {
//      key: "age"
//      value { float_list {
//        value: 29.0
//      }}
//    }
//    feature {
//      key: "movie"
//      value { bytes_list {
//        value: "The Shawshank Redemption"
//        value: "Fight Club"
//      }}
//    }
//    feature {
//      key: "movie_ratings"
//      value { float_list {
//        value: 9.0
//        value: 9.7
//      }}
//    }
//    feature {
//      key: "suggestion"
//      value { bytes_list {
//        value: "Inception"
//      }}
//    }
//    feature {
//      key: "suggestion_purchased"
//      value { int64_list {
//        value: 1
//      }}
//    }
//    feature {
//      key: "purchase_price"
//      value { float_list {
//        value: 9.99
//      }}
//    }

import Foundation
import SwiftProtobuf


///   Containers to hold repeated fundamental values.
struct Tensorflow_BytesList: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_BytesList"}
  public var protoMessageName: String {return "BytesList"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "value": 1,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "value": 1,
  ]}

  public var value: [Data] = []

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeRepeatedField(fieldType: ProtobufBytes.self, value: &value)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if !value.isEmpty {
      try visitor.visitRepeatedField(fieldType: ProtobufBytes.self, value: value, protoFieldNumber: 1, protoFieldName: "value", jsonFieldName: "value", swiftFieldName: "value")
    }
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_BytesList) -> Bool {
    if value != other.value {return false}
    return true
  }
}

struct Tensorflow_FloatList: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_FloatList"}
  public var protoMessageName: String {return "FloatList"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "value": 1,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "value": 1,
  ]}

  public var value: [Float] = []

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodePackedField(fieldType: ProtobufFloat.self, value: &value)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if !value.isEmpty {
      try visitor.visitPackedField(fieldType: ProtobufFloat.self, value: value, protoFieldNumber: 1, protoFieldName: "value", jsonFieldName: "value", swiftFieldName: "value")
    }
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_FloatList) -> Bool {
    if value != other.value {return false}
    return true
  }
}

struct Tensorflow_Int64List: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_Int64List"}
  public var protoMessageName: String {return "Int64List"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "value": 1,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "value": 1,
  ]}

  public var value: [Int64] = []

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodePackedField(fieldType: ProtobufInt64.self, value: &value)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if !value.isEmpty {
      try visitor.visitPackedField(fieldType: ProtobufInt64.self, value: value, protoFieldNumber: 1, protoFieldName: "value", jsonFieldName: "value", swiftFieldName: "value")
    }
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_Int64List) -> Bool {
    if value != other.value {return false}
    return true
  }
}

///   Containers for non-sequential data.
struct Tensorflow_Feature: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_Feature"}
  public var protoMessageName: String {return "Feature"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "bytesList": 1,
    "floatList": 2,
    "int64List": 3,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "bytes_list": 1,
    "float_list": 2,
    "int64_list": 3,
  ]}

  private class _StorageClass {
    typealias ProtobufExtendedMessage = Tensorflow_Feature
    var _kind = Tensorflow_Feature.OneOf_Kind()

    init() {}

    func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1, 2, 3:
        handled = try _kind.decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
      default:
        handled = false
      }
      return handled
    }

    func traverse(visitor: inout ProtobufVisitor) throws {
      try _kind.traverse(visitor: &visitor, start: 1, end: 4)
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _kind != other._kind {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._kind = _kind
      return clone
    }
  }

  private var _storage = _StorageClass()

  enum OneOf_Kind: ExpressibleByNilLiteral, ProtobufOneofEnum {
    case bytesList(Tensorflow_BytesList)
    case floatList(Tensorflow_FloatList)
    case int64List(Tensorflow_Int64List)
    case None

    public init(nilLiteral: ()) {
      self = .None
    }

    public init() {
      self = .None
    }

    public mutating func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      if self != .None && setter.rejectConflictingOneof {
        throw ProtobufDecodingError.duplicatedOneOf
      }
      let handled: Bool
      switch protoFieldNumber {
      case 1:
        var value: Tensorflow_BytesList?
        handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_BytesList.self, value: &value)
        if let value = value, handled {
          self = .bytesList(value)
        }
      case 2:
        var value: Tensorflow_FloatList?
        handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_FloatList.self, value: &value)
        if let value = value, handled {
          self = .floatList(value)
        }
      case 3:
        var value: Tensorflow_Int64List?
        handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_Int64List.self, value: &value)
        if let value = value, handled {
          self = .int64List(value)
        }
      default:
        handled = false
        self = .None
      }
      return handled
    }

    public func traverse(visitor: inout ProtobufVisitor, start: Int, end: Int) throws {
      switch self {
      case .bytesList(let v):
        if start <= 1 && 1 < end {
          try visitor.visitSingularMessageField(value: v, protoFieldNumber: 1, protoFieldName: "bytes_list", jsonFieldName: "bytesList", swiftFieldName: "bytesList")
        }
      case .floatList(let v):
        if start <= 2 && 2 < end {
          try visitor.visitSingularMessageField(value: v, protoFieldNumber: 2, protoFieldName: "float_list", jsonFieldName: "floatList", swiftFieldName: "floatList")
        }
      case .int64List(let v):
        if start <= 3 && 3 < end {
          try visitor.visitSingularMessageField(value: v, protoFieldNumber: 3, protoFieldName: "int64_list", jsonFieldName: "int64List", swiftFieldName: "int64List")
        }
      case .None:
        break
      }
    }
  }

  public var bytesList: Tensorflow_BytesList {
    get {
      if case .bytesList(let v) = _storage._kind {
        return v
      }
      return Tensorflow_BytesList()
    }
    set {
      _uniqueStorage()._kind = .bytesList(newValue)
    }
  }

  public var floatList: Tensorflow_FloatList {
    get {
      if case .floatList(let v) = _storage._kind {
        return v
      }
      return Tensorflow_FloatList()
    }
    set {
      _uniqueStorage()._kind = .floatList(newValue)
    }
  }

  public var int64List: Tensorflow_Int64List {
    get {
      if case .int64List(let v) = _storage._kind {
        return v
      }
      return Tensorflow_Int64List()
    }
    set {
      _uniqueStorage()._kind = .int64List(newValue)
    }
  }

  public var kind: OneOf_Kind {
    get {return _storage._kind}
    set {
      _uniqueStorage()._kind = newValue
    }
  }

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    try _storage.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_Feature) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

struct Tensorflow_Features: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_Features"}
  public var protoMessageName: String {return "Features"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "feature": 1,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "feature": 1,
  ]}

  ///   Map from feature name to feature.
  public var feature: Dictionary<String,Tensorflow_Feature> = [:]

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeMapField(fieldType: ProtobufMap<ProtobufString,Tensorflow_Feature>.self, value: &feature)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if !feature.isEmpty {
      try visitor.visitMapField(fieldType: ProtobufMap<ProtobufString,Tensorflow_Feature>.self, value: feature, protoFieldNumber: 1, protoFieldName: "feature", jsonFieldName: "feature", swiftFieldName: "feature")
    }
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_Features) -> Bool {
    if feature != other.feature {return false}
    return true
  }
}

///   Containers for sequential data.
///  
///   A FeatureList contains lists of Features.  These may hold zero or more
///   Feature values.
///  
///   FeatureLists are organized into categories by name.  The FeatureLists message
///   contains the mapping from name to FeatureList.
struct Tensorflow_FeatureList: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_FeatureList"}
  public var protoMessageName: String {return "FeatureList"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "feature": 1,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "feature": 1,
  ]}

  public var feature: [Tensorflow_Feature] = []

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeRepeatedMessageField(fieldType: Tensorflow_Feature.self, value: &feature)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if !feature.isEmpty {
      try visitor.visitRepeatedMessageField(value: feature, protoFieldNumber: 1, protoFieldName: "feature", jsonFieldName: "feature", swiftFieldName: "feature")
    }
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_FeatureList) -> Bool {
    if feature != other.feature {return false}
    return true
  }
}

struct Tensorflow_FeatureLists: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_FeatureLists"}
  public var protoMessageName: String {return "FeatureLists"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "featureList": 1,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "feature_list": 1,
  ]}

  ///   Map from feature name to feature list.
  public var featureList: Dictionary<String,Tensorflow_FeatureList> = [:]

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeMapField(fieldType: ProtobufMap<ProtobufString,Tensorflow_FeatureList>.self, value: &featureList)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if !featureList.isEmpty {
      try visitor.visitMapField(fieldType: ProtobufMap<ProtobufString,Tensorflow_FeatureList>.self, value: featureList, protoFieldNumber: 1, protoFieldName: "feature_list", jsonFieldName: "featureList", swiftFieldName: "featureList")
    }
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_FeatureLists) -> Bool {
    if featureList != other.featureList {return false}
    return true
  }
}

func ==(lhs: Tensorflow_Feature.OneOf_Kind, rhs: Tensorflow_Feature.OneOf_Kind) -> Bool {
  switch (lhs, rhs) {
  case (.bytesList(let l), .bytesList(let r)): return l == r
  case (.floatList(let l), .floatList(let r)): return l == r
  case (.int64List(let l), .int64List(let r)): return l == r
  case (.None, .None): return true
  default: return false
  }
}
