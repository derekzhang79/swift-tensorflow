/*
 * DO NOT EDIT.
 *
 * Generated by the protocol buffer compiler.
 * Source: tensorflow/core/framework/step_stats.proto
 *
 */

import Foundation
import SwiftProtobuf


//  TODO(tucker): The next 4 message defs are very similar to
//  the *LogEntry messages in profile.proto.  They should be
//  unified in one place.

struct Tensorflow_AllocatorMemoryUsed: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_AllocatorMemoryUsed"}
  public var protoMessageName: String {return "AllocatorMemoryUsed"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "allocatorName": 1,
    "totalBytes": 2,
    "peakBytes": 3,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "allocator_name": 1,
    "total_bytes": 2,
    "peak_bytes": 3,
  ]}

  public var allocatorName: String = ""

  public var totalBytes: Int64 = 0

  public var peakBytes: Int64 = 0

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &allocatorName)
    case 2: handled = try setter.decodeSingularField(fieldType: ProtobufInt64.self, value: &totalBytes)
    case 3: handled = try setter.decodeSingularField(fieldType: ProtobufInt64.self, value: &peakBytes)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if allocatorName != "" {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: allocatorName, protoFieldNumber: 1, protoFieldName: "allocator_name", jsonFieldName: "allocatorName", swiftFieldName: "allocatorName")
    }
    if totalBytes != 0 {
      try visitor.visitSingularField(fieldType: ProtobufInt64.self, value: totalBytes, protoFieldNumber: 2, protoFieldName: "total_bytes", jsonFieldName: "totalBytes", swiftFieldName: "totalBytes")
    }
    if peakBytes != 0 {
      try visitor.visitSingularField(fieldType: ProtobufInt64.self, value: peakBytes, protoFieldNumber: 3, protoFieldName: "peak_bytes", jsonFieldName: "peakBytes", swiftFieldName: "peakBytes")
    }
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_AllocatorMemoryUsed) -> Bool {
    if allocatorName != other.allocatorName {return false}
    if totalBytes != other.totalBytes {return false}
    if peakBytes != other.peakBytes {return false}
    return true
  }
}

///   Output sizes recorded for a single execution of a graph node.
struct Tensorflow_NodeOutput: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_NodeOutput"}
  public var protoMessageName: String {return "NodeOutput"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "slot": 1,
    "tensorDescription": 3,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "slot": 1,
    "tensor_description": 3,
  ]}

  private class _StorageClass {
    typealias ProtobufExtendedMessage = Tensorflow_NodeOutput
    var _slot: Int32 = 0
    var _tensorDescription: Tensorflow_TensorDescription? = nil

    init() {}

    func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodeSingularField(fieldType: ProtobufInt32.self, value: &_slot)
      case 3: handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_TensorDescription.self, value: &_tensorDescription)
      default:
        handled = false
      }
      return handled
    }

    func traverse(visitor: inout ProtobufVisitor) throws {
      if _slot != 0 {
        try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: _slot, protoFieldNumber: 1, protoFieldName: "slot", jsonFieldName: "slot", swiftFieldName: "slot")
      }
      if let v = _tensorDescription {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 3, protoFieldName: "tensor_description", jsonFieldName: "tensorDescription", swiftFieldName: "tensorDescription")
      }
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _slot != other._slot {return false}
      if _tensorDescription != other._tensorDescription {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._slot = _slot
      clone._tensorDescription = _tensorDescription
      return clone
    }
  }

  private var _storage = _StorageClass()

  public var slot: Int32 {
    get {return _storage._slot}
    set {_uniqueStorage()._slot = newValue}
  }

  public var tensorDescription: Tensorflow_TensorDescription {
    get {return _storage._tensorDescription ?? Tensorflow_TensorDescription()}
    set {_uniqueStorage()._tensorDescription = newValue}
  }
  public var hasTensorDescription: Bool {
    return _storage._tensorDescription != nil
  }
  public mutating func clearTensorDescription() {
    return _storage._tensorDescription = nil
  }

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    try _storage.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_NodeOutput) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

///   Time/size stats recorded for a single execution of a graph node.
struct Tensorflow_NodeExecStats: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_NodeExecStats"}
  public var protoMessageName: String {return "NodeExecStats"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "nodeName": 1,
    "allStartMicros": 2,
    "opStartRelMicros": 3,
    "opEndRelMicros": 4,
    "allEndRelMicros": 5,
    "memory": 6,
    "output": 7,
    "timelineLabel": 8,
    "scheduledMicros": 9,
    "threadId": 10,
    "referencedTensor": 11,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "node_name": 1,
    "all_start_micros": 2,
    "op_start_rel_micros": 3,
    "op_end_rel_micros": 4,
    "all_end_rel_micros": 5,
    "memory": 6,
    "output": 7,
    "timeline_label": 8,
    "scheduled_micros": 9,
    "thread_id": 10,
    "referenced_tensor": 11,
  ]}

  ///   TODO(tucker): Use some more compact form of node identity than
  ///   the full string name.  Either all processes should agree on a
  ///   global id (cost_id?) for each node, or we should use a hash of
  ///   the name.
  public var nodeName: String = ""

  public var allStartMicros: Int64 = 0

  public var opStartRelMicros: Int64 = 0

  public var opEndRelMicros: Int64 = 0

  public var allEndRelMicros: Int64 = 0

  public var memory: [Tensorflow_AllocatorMemoryUsed] = []

  public var output: [Tensorflow_NodeOutput] = []

  public var timelineLabel: String = ""

  public var scheduledMicros: Int64 = 0

  public var threadId: UInt32 = 0

  public var referencedTensor: [Tensorflow_AllocationDescription] = []

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &nodeName)
    case 2: handled = try setter.decodeSingularField(fieldType: ProtobufInt64.self, value: &allStartMicros)
    case 3: handled = try setter.decodeSingularField(fieldType: ProtobufInt64.self, value: &opStartRelMicros)
    case 4: handled = try setter.decodeSingularField(fieldType: ProtobufInt64.self, value: &opEndRelMicros)
    case 5: handled = try setter.decodeSingularField(fieldType: ProtobufInt64.self, value: &allEndRelMicros)
    case 6: handled = try setter.decodeRepeatedMessageField(fieldType: Tensorflow_AllocatorMemoryUsed.self, value: &memory)
    case 7: handled = try setter.decodeRepeatedMessageField(fieldType: Tensorflow_NodeOutput.self, value: &output)
    case 8: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &timelineLabel)
    case 9: handled = try setter.decodeSingularField(fieldType: ProtobufInt64.self, value: &scheduledMicros)
    case 10: handled = try setter.decodeSingularField(fieldType: ProtobufUInt32.self, value: &threadId)
    case 11: handled = try setter.decodeRepeatedMessageField(fieldType: Tensorflow_AllocationDescription.self, value: &referencedTensor)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if nodeName != "" {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: nodeName, protoFieldNumber: 1, protoFieldName: "node_name", jsonFieldName: "nodeName", swiftFieldName: "nodeName")
    }
    if allStartMicros != 0 {
      try visitor.visitSingularField(fieldType: ProtobufInt64.self, value: allStartMicros, protoFieldNumber: 2, protoFieldName: "all_start_micros", jsonFieldName: "allStartMicros", swiftFieldName: "allStartMicros")
    }
    if opStartRelMicros != 0 {
      try visitor.visitSingularField(fieldType: ProtobufInt64.self, value: opStartRelMicros, protoFieldNumber: 3, protoFieldName: "op_start_rel_micros", jsonFieldName: "opStartRelMicros", swiftFieldName: "opStartRelMicros")
    }
    if opEndRelMicros != 0 {
      try visitor.visitSingularField(fieldType: ProtobufInt64.self, value: opEndRelMicros, protoFieldNumber: 4, protoFieldName: "op_end_rel_micros", jsonFieldName: "opEndRelMicros", swiftFieldName: "opEndRelMicros")
    }
    if allEndRelMicros != 0 {
      try visitor.visitSingularField(fieldType: ProtobufInt64.self, value: allEndRelMicros, protoFieldNumber: 5, protoFieldName: "all_end_rel_micros", jsonFieldName: "allEndRelMicros", swiftFieldName: "allEndRelMicros")
    }
    if !memory.isEmpty {
      try visitor.visitRepeatedMessageField(value: memory, protoFieldNumber: 6, protoFieldName: "memory", jsonFieldName: "memory", swiftFieldName: "memory")
    }
    if !output.isEmpty {
      try visitor.visitRepeatedMessageField(value: output, protoFieldNumber: 7, protoFieldName: "output", jsonFieldName: "output", swiftFieldName: "output")
    }
    if timelineLabel != "" {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: timelineLabel, protoFieldNumber: 8, protoFieldName: "timeline_label", jsonFieldName: "timelineLabel", swiftFieldName: "timelineLabel")
    }
    if scheduledMicros != 0 {
      try visitor.visitSingularField(fieldType: ProtobufInt64.self, value: scheduledMicros, protoFieldNumber: 9, protoFieldName: "scheduled_micros", jsonFieldName: "scheduledMicros", swiftFieldName: "scheduledMicros")
    }
    if threadId != 0 {
      try visitor.visitSingularField(fieldType: ProtobufUInt32.self, value: threadId, protoFieldNumber: 10, protoFieldName: "thread_id", jsonFieldName: "threadId", swiftFieldName: "threadId")
    }
    if !referencedTensor.isEmpty {
      try visitor.visitRepeatedMessageField(value: referencedTensor, protoFieldNumber: 11, protoFieldName: "referenced_tensor", jsonFieldName: "referencedTensor", swiftFieldName: "referencedTensor")
    }
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_NodeExecStats) -> Bool {
    if nodeName != other.nodeName {return false}
    if allStartMicros != other.allStartMicros {return false}
    if opStartRelMicros != other.opStartRelMicros {return false}
    if opEndRelMicros != other.opEndRelMicros {return false}
    if allEndRelMicros != other.allEndRelMicros {return false}
    if memory != other.memory {return false}
    if output != other.output {return false}
    if timelineLabel != other.timelineLabel {return false}
    if scheduledMicros != other.scheduledMicros {return false}
    if threadId != other.threadId {return false}
    if referencedTensor != other.referencedTensor {return false}
    return true
  }
}

struct Tensorflow_DeviceStepStats: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_DeviceStepStats"}
  public var protoMessageName: String {return "DeviceStepStats"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "device": 1,
    "nodeStats": 2,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "device": 1,
    "node_stats": 2,
  ]}

  public var device: String = ""

  public var nodeStats: [Tensorflow_NodeExecStats] = []

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &device)
    case 2: handled = try setter.decodeRepeatedMessageField(fieldType: Tensorflow_NodeExecStats.self, value: &nodeStats)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if device != "" {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: device, protoFieldNumber: 1, protoFieldName: "device", jsonFieldName: "device", swiftFieldName: "device")
    }
    if !nodeStats.isEmpty {
      try visitor.visitRepeatedMessageField(value: nodeStats, protoFieldNumber: 2, protoFieldName: "node_stats", jsonFieldName: "nodeStats", swiftFieldName: "nodeStats")
    }
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_DeviceStepStats) -> Bool {
    if device != other.device {return false}
    if nodeStats != other.nodeStats {return false}
    return true
  }
}

struct Tensorflow_StepStats: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_StepStats"}
  public var protoMessageName: String {return "StepStats"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "devStats": 1,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "dev_stats": 1,
  ]}

  public var devStats: [Tensorflow_DeviceStepStats] = []

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeRepeatedMessageField(fieldType: Tensorflow_DeviceStepStats.self, value: &devStats)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if !devStats.isEmpty {
      try visitor.visitRepeatedMessageField(value: devStats, protoFieldNumber: 1, protoFieldName: "dev_stats", jsonFieldName: "devStats", swiftFieldName: "devStats")
    }
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_StepStats) -> Bool {
    if devStats != other.devStats {return false}
    return true
  }
}
