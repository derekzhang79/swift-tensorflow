/*
 * DO NOT EDIT.
 *
 * Generated by the protocol buffer compiler.
 * Source: tensorflow/core/framework/cost_graph.proto
 *
 */

import Foundation
import SwiftProtobuf


struct Tensorflow_CostGraphDef: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_CostGraphDef"}
  public var protoMessageName: String {return "CostGraphDef"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "node": 1,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "node": 1,
  ]}

  struct Node: ProtobufGeneratedMessage {
    public var swiftClassName: String {return "Tensorflow_CostGraphDef.Node"}
    public var protoMessageName: String {return "Node"}
    public var protoPackageName: String {return "tensorflow"}
    public var jsonFieldNames: [String: Int] {return [
      "name": 1,
      "device": 2,
      "id": 3,
      "inputInfo": 4,
      "outputInfo": 5,
      "temporaryMemorySize": 6,
      "computeCost": 9,
      "isFinal": 7,
      "controlInput": 8,
    ]}
    public var protoFieldNames: [String: Int] {return [
      "name": 1,
      "device": 2,
      "id": 3,
      "input_info": 4,
      "output_info": 5,
      "temporary_memory_size": 6,
      "compute_cost": 9,
      "is_final": 7,
      "control_input": 8,
    ]}

    ///   Inputs of this node. They must be executed before this node can be
    ///   executed. An input is a particular output of another node, specified
    ///   by the node id and the output index.
    struct InputInfo: ProtobufGeneratedMessage {
      public var swiftClassName: String {return "Tensorflow_CostGraphDef.Node.InputInfo"}
      public var protoMessageName: String {return "InputInfo"}
      public var protoPackageName: String {return "tensorflow"}
      public var jsonFieldNames: [String: Int] {return [
        "precedingNode": 1,
        "precedingPort": 2,
      ]}
      public var protoFieldNames: [String: Int] {return [
        "preceding_node": 1,
        "preceding_port": 2,
      ]}

      public var precedingNode: Int32 = 0

      public var precedingPort: Int32 = 0

      public init() {}

      public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
        let handled: Bool
        switch protoFieldNumber {
        case 1: handled = try setter.decodeSingularField(fieldType: ProtobufInt32.self, value: &precedingNode)
        case 2: handled = try setter.decodeSingularField(fieldType: ProtobufInt32.self, value: &precedingPort)
        default:
          handled = false
        }
        return handled
      }

      public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
        if precedingNode != 0 {
          try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: precedingNode, protoFieldNumber: 1, protoFieldName: "preceding_node", jsonFieldName: "precedingNode", swiftFieldName: "precedingNode")
        }
        if precedingPort != 0 {
          try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: precedingPort, protoFieldNumber: 2, protoFieldName: "preceding_port", jsonFieldName: "precedingPort", swiftFieldName: "precedingPort")
        }
      }

      public func _protoc_generated_isEqualTo(other: Tensorflow_CostGraphDef.Node.InputInfo) -> Bool {
        if precedingNode != other.precedingNode {return false}
        if precedingPort != other.precedingPort {return false}
        return true
      }
    }

    ///   Outputs of this node.
    struct OutputInfo: ProtobufGeneratedMessage {
      public var swiftClassName: String {return "Tensorflow_CostGraphDef.Node.OutputInfo"}
      public var protoMessageName: String {return "OutputInfo"}
      public var protoPackageName: String {return "tensorflow"}
      public var jsonFieldNames: [String: Int] {return [
        "size": 1,
        "aliasInputPort": 2,
        "shape": 3,
        "dtype": 4,
      ]}
      public var protoFieldNames: [String: Int] {return [
        "size": 1,
        "alias_input_port": 2,
        "shape": 3,
        "dtype": 4,
      ]}

      private class _StorageClass {
        typealias ProtobufExtendedMessage = Tensorflow_CostGraphDef.Node.OutputInfo
        var _size: Int64 = 0
        var _aliasInputPort: Int64 = 0
        var _shape: Tensorflow_TensorShapeProto? = nil
        var _dtype: Tensorflow_DataType = Tensorflow_DataType.dtInvalid

        init() {}

        func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
          let handled: Bool
          switch protoFieldNumber {
          case 1: handled = try setter.decodeSingularField(fieldType: ProtobufInt64.self, value: &_size)
          case 2: handled = try setter.decodeSingularField(fieldType: ProtobufInt64.self, value: &_aliasInputPort)
          case 3: handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_TensorShapeProto.self, value: &_shape)
          case 4: handled = try setter.decodeSingularField(fieldType: Tensorflow_DataType.self, value: &_dtype)
          default:
            handled = false
          }
          return handled
        }

        func traverse(visitor: inout ProtobufVisitor) throws {
          if _size != 0 {
            try visitor.visitSingularField(fieldType: ProtobufInt64.self, value: _size, protoFieldNumber: 1, protoFieldName: "size", jsonFieldName: "size", swiftFieldName: "size")
          }
          if _aliasInputPort != 0 {
            try visitor.visitSingularField(fieldType: ProtobufInt64.self, value: _aliasInputPort, protoFieldNumber: 2, protoFieldName: "alias_input_port", jsonFieldName: "aliasInputPort", swiftFieldName: "aliasInputPort")
          }
          if let v = _shape {
            try visitor.visitSingularMessageField(value: v, protoFieldNumber: 3, protoFieldName: "shape", jsonFieldName: "shape", swiftFieldName: "shape")
          }
          if _dtype != Tensorflow_DataType.dtInvalid {
            try visitor.visitSingularField(fieldType: Tensorflow_DataType.self, value: _dtype, protoFieldNumber: 4, protoFieldName: "dtype", jsonFieldName: "dtype", swiftFieldName: "dtype")
          }
        }

        func isEqualTo(other: _StorageClass) -> Bool {
          if _size != other._size {return false}
          if _aliasInputPort != other._aliasInputPort {return false}
          if _shape != other._shape {return false}
          if _dtype != other._dtype {return false}
          return true
        }

        func copy() -> _StorageClass {
          let clone = _StorageClass()
          clone._size = _size
          clone._aliasInputPort = _aliasInputPort
          clone._shape = _shape
          clone._dtype = _dtype
          return clone
        }
      }

      private var _storage = _StorageClass()

      public var size: Int64 {
        get {return _storage._size}
        set {_uniqueStorage()._size = newValue}
      }

      ///   If >= 0, the output is an alias of an input. Note that an alias input
      ///   may itself be an alias. The algorithm will therefore need to follow
      ///   those pointers.
      public var aliasInputPort: Int64 {
        get {return _storage._aliasInputPort}
        set {_uniqueStorage()._aliasInputPort = newValue}
      }

      public var shape: Tensorflow_TensorShapeProto {
        get {return _storage._shape ?? Tensorflow_TensorShapeProto()}
        set {_uniqueStorage()._shape = newValue}
      }
      public var hasShape: Bool {
        return _storage._shape != nil
      }
      public mutating func clearShape() {
        return _storage._shape = nil
      }

      public var dtype: Tensorflow_DataType {
        get {return _storage._dtype}
        set {_uniqueStorage()._dtype = newValue}
      }

      public init() {}

      public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
        return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
      }

      public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
        try _storage.traverse(visitor: &visitor)
      }

      public func _protoc_generated_isEqualTo(other: Tensorflow_CostGraphDef.Node.OutputInfo) -> Bool {
        return _storage === other._storage || _storage.isEqualTo(other: other._storage)
      }

      private mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
          _storage = _storage.copy()
        }
        return _storage
      }
    }

    ///   The name of the node. Names are globally unique.
    public var name: String = ""

    ///   The device of the node. Can be empty if the node is mapped to the
    ///   default partition or partitioning hasn't been run yet.
    public var device: String = ""

    ///   The id of the node. Node ids are only unique inside a partition.
    public var id: Int32 = 0

    public var inputInfo: [Tensorflow_CostGraphDef.Node.InputInfo] = []

    public var outputInfo: [Tensorflow_CostGraphDef.Node.OutputInfo] = []

    ///   Temporary memory used by this node.
    public var temporaryMemorySize: Int64 = 0

    ///   Estimate of the computational cost of this node.
    public var computeCost: Int64 = 0

    ///   If true, the output is permanent: it can't be discarded, because this
    ///   node is part of the "final output". Nodes may depend on final nodes.
    public var isFinal: Bool = false

    ///   Ids of the control inputs for this node.
    public var controlInput: [Int32] = []

    public init() {}

    public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &name)
      case 2: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &device)
      case 3: handled = try setter.decodeSingularField(fieldType: ProtobufInt32.self, value: &id)
      case 4: handled = try setter.decodeRepeatedMessageField(fieldType: Tensorflow_CostGraphDef.Node.InputInfo.self, value: &inputInfo)
      case 5: handled = try setter.decodeRepeatedMessageField(fieldType: Tensorflow_CostGraphDef.Node.OutputInfo.self, value: &outputInfo)
      case 6: handled = try setter.decodeSingularField(fieldType: ProtobufInt64.self, value: &temporaryMemorySize)
      case 9: handled = try setter.decodeSingularField(fieldType: ProtobufInt64.self, value: &computeCost)
      case 7: handled = try setter.decodeSingularField(fieldType: ProtobufBool.self, value: &isFinal)
      case 8: handled = try setter.decodePackedField(fieldType: ProtobufInt32.self, value: &controlInput)
      default:
        handled = false
      }
      return handled
    }

    public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
      if name != "" {
        try visitor.visitSingularField(fieldType: ProtobufString.self, value: name, protoFieldNumber: 1, protoFieldName: "name", jsonFieldName: "name", swiftFieldName: "name")
      }
      if device != "" {
        try visitor.visitSingularField(fieldType: ProtobufString.self, value: device, protoFieldNumber: 2, protoFieldName: "device", jsonFieldName: "device", swiftFieldName: "device")
      }
      if id != 0 {
        try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: id, protoFieldNumber: 3, protoFieldName: "id", jsonFieldName: "id", swiftFieldName: "id")
      }
      if !inputInfo.isEmpty {
        try visitor.visitRepeatedMessageField(value: inputInfo, protoFieldNumber: 4, protoFieldName: "input_info", jsonFieldName: "inputInfo", swiftFieldName: "inputInfo")
      }
      if !outputInfo.isEmpty {
        try visitor.visitRepeatedMessageField(value: outputInfo, protoFieldNumber: 5, protoFieldName: "output_info", jsonFieldName: "outputInfo", swiftFieldName: "outputInfo")
      }
      if temporaryMemorySize != 0 {
        try visitor.visitSingularField(fieldType: ProtobufInt64.self, value: temporaryMemorySize, protoFieldNumber: 6, protoFieldName: "temporary_memory_size", jsonFieldName: "temporaryMemorySize", swiftFieldName: "temporaryMemorySize")
      }
      if isFinal != false {
        try visitor.visitSingularField(fieldType: ProtobufBool.self, value: isFinal, protoFieldNumber: 7, protoFieldName: "is_final", jsonFieldName: "isFinal", swiftFieldName: "isFinal")
      }
      if !controlInput.isEmpty {
        try visitor.visitPackedField(fieldType: ProtobufInt32.self, value: controlInput, protoFieldNumber: 8, protoFieldName: "control_input", jsonFieldName: "controlInput", swiftFieldName: "controlInput")
      }
      if computeCost != 0 {
        try visitor.visitSingularField(fieldType: ProtobufInt64.self, value: computeCost, protoFieldNumber: 9, protoFieldName: "compute_cost", jsonFieldName: "computeCost", swiftFieldName: "computeCost")
      }
    }

    public func _protoc_generated_isEqualTo(other: Tensorflow_CostGraphDef.Node) -> Bool {
      if name != other.name {return false}
      if device != other.device {return false}
      if id != other.id {return false}
      if inputInfo != other.inputInfo {return false}
      if outputInfo != other.outputInfo {return false}
      if temporaryMemorySize != other.temporaryMemorySize {return false}
      if computeCost != other.computeCost {return false}
      if isFinal != other.isFinal {return false}
      if controlInput != other.controlInput {return false}
      return true
    }
  }

  public var node: [Tensorflow_CostGraphDef.Node] = []

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeRepeatedMessageField(fieldType: Tensorflow_CostGraphDef.Node.self, value: &node)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if !node.isEmpty {
      try visitor.visitRepeatedMessageField(value: node, protoFieldNumber: 1, protoFieldName: "node", jsonFieldName: "node", swiftFieldName: "node")
    }
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_CostGraphDef) -> Bool {
    if node != other.node {return false}
    return true
  }
}
