/*
 * DO NOT EDIT.
 *
 * Generated by the protocol buffer compiler.
 * Source: tensorflow/python/framework/cpp_shape_inference.proto
 *
 */

import Foundation
import SwiftProtobuf


struct Tensorflow_CppShapeInferenceResult: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_CppShapeInferenceResult"}
  public var protoMessageName: String {return "CppShapeInferenceResult"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "shape": 1,
    "handleShape": 2,
    "handleDtype": 3,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "shape": 1,
    "handle_shape": 2,
    "handle_dtype": 3,
  ]}

  private class _StorageClass {
    typealias ProtobufExtendedMessage = Tensorflow_CppShapeInferenceResult
    var _shape: Tensorflow_TensorShapeProto? = nil
    var _handleShape: Tensorflow_TensorShapeProto? = nil
    var _handleDtype: Tensorflow_DataType = Tensorflow_DataType.dtInvalid

    init() {}

    func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_TensorShapeProto.self, value: &_shape)
      case 2: handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_TensorShapeProto.self, value: &_handleShape)
      case 3: handled = try setter.decodeSingularField(fieldType: Tensorflow_DataType.self, value: &_handleDtype)
      default:
        handled = false
      }
      return handled
    }

    func traverse(visitor: inout ProtobufVisitor) throws {
      if let v = _shape {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 1, protoFieldName: "shape", jsonFieldName: "shape", swiftFieldName: "shape")
      }
      if let v = _handleShape {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 2, protoFieldName: "handle_shape", jsonFieldName: "handleShape", swiftFieldName: "handleShape")
      }
      if _handleDtype != Tensorflow_DataType.dtInvalid {
        try visitor.visitSingularField(fieldType: Tensorflow_DataType.self, value: _handleDtype, protoFieldNumber: 3, protoFieldName: "handle_dtype", jsonFieldName: "handleDtype", swiftFieldName: "handleDtype")
      }
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _shape != other._shape {return false}
      if _handleShape != other._handleShape {return false}
      if _handleDtype != other._handleDtype {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._shape = _shape
      clone._handleShape = _handleShape
      clone._handleDtype = _handleDtype
      return clone
    }
  }

  private var _storage = _StorageClass()

  public var shape: Tensorflow_TensorShapeProto {
    get {return _storage._shape ?? Tensorflow_TensorShapeProto()}
    set {_uniqueStorage()._shape = newValue}
  }
  public var hasShape: Bool {
    return _storage._shape != nil
  }
  public mutating func clearShape() {
    return _storage._shape = nil
  }

  public var handleShape: Tensorflow_TensorShapeProto {
    get {return _storage._handleShape ?? Tensorflow_TensorShapeProto()}
    set {_uniqueStorage()._handleShape = newValue}
  }
  public var hasHandleShape: Bool {
    return _storage._handleShape != nil
  }
  public mutating func clearHandleShape() {
    return _storage._handleShape = nil
  }

  public var handleDtype: Tensorflow_DataType {
    get {return _storage._handleDtype}
    set {_uniqueStorage()._handleDtype = newValue}
  }

  public init() {}

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    try _storage.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_CppShapeInferenceResult) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}
