/*
 * DO NOT EDIT.
 *
 * Generated by the protocol buffer compiler.
 * Source: tensorflow/core/framework/tensor.proto
 *
 */

import Foundation
import SwiftProtobuf


///   Protocol buffer representing a tensor.
public struct Tensorflow_TensorProto: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_TensorProto"}
  public var protoMessageName: String {return "TensorProto"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "dtype": 1,
    "tensorShape": 2,
    "versionNumber": 3,
    "tensorContent": 4,
    "halfVal": 13,
    "floatVal": 5,
    "doubleVal": 6,
    "intVal": 7,
    "stringVal": 8,
    "scomplexVal": 9,
    "int64Val": 10,
    "boolVal": 11,
    "dcomplexVal": 12,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "dtype": 1,
    "tensor_shape": 2,
    "version_number": 3,
    "tensor_content": 4,
    "half_val": 13,
    "float_val": 5,
    "double_val": 6,
    "int_val": 7,
    "string_val": 8,
    "scomplex_val": 9,
    "int64_val": 10,
    "bool_val": 11,
    "dcomplex_val": 12,
  ]}

  private class _StorageClass {
    typealias ProtobufExtendedMessage = Tensorflow_TensorProto
    var _dtype: Tensorflow_DataType = Tensorflow_DataType.dtInvalid
    var _tensorShape: Tensorflow_TensorShapeProto? = nil
    var _versionNumber: Int32 = 0
    var _tensorContent: Data = Data()
    var _halfVal: [Int32] = []
    var _floatVal: [Float] = []
    var _doubleVal: [Double] = []
    var _intVal: [Int32] = []
    var _stringVal: [Data] = []
    var _scomplexVal: [Float] = []
    var _int64Val: [Int64] = []
    var _boolVal: [Bool] = []
    var _dcomplexVal: [Double] = []

    init() {}

    func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodeSingularField(fieldType: Tensorflow_DataType.self, value: &_dtype)
      case 2: handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_TensorShapeProto.self, value: &_tensorShape)
      case 3: handled = try setter.decodeSingularField(fieldType: ProtobufInt32.self, value: &_versionNumber)
      case 4: handled = try setter.decodeSingularField(fieldType: ProtobufBytes.self, value: &_tensorContent)
      case 13: handled = try setter.decodePackedField(fieldType: ProtobufInt32.self, value: &_halfVal)
      case 5: handled = try setter.decodePackedField(fieldType: ProtobufFloat.self, value: &_floatVal)
      case 6: handled = try setter.decodePackedField(fieldType: ProtobufDouble.self, value: &_doubleVal)
      case 7: handled = try setter.decodePackedField(fieldType: ProtobufInt32.self, value: &_intVal)
      case 8: handled = try setter.decodeRepeatedField(fieldType: ProtobufBytes.self, value: &_stringVal)
      case 9: handled = try setter.decodePackedField(fieldType: ProtobufFloat.self, value: &_scomplexVal)
      case 10: handled = try setter.decodePackedField(fieldType: ProtobufInt64.self, value: &_int64Val)
      case 11: handled = try setter.decodePackedField(fieldType: ProtobufBool.self, value: &_boolVal)
      case 12: handled = try setter.decodePackedField(fieldType: ProtobufDouble.self, value: &_dcomplexVal)
      default:
        handled = false
      }
      return handled
    }

    func traverse(visitor: inout ProtobufVisitor) throws {
      if _dtype != Tensorflow_DataType.dtInvalid {
        try visitor.visitSingularField(fieldType: Tensorflow_DataType.self, value: _dtype, protoFieldNumber: 1, protoFieldName: "dtype", jsonFieldName: "dtype", swiftFieldName: "dtype")
      }
      if let v = _tensorShape {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 2, protoFieldName: "tensor_shape", jsonFieldName: "tensorShape", swiftFieldName: "tensorShape")
      }
      if _versionNumber != 0 {
        try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: _versionNumber, protoFieldNumber: 3, protoFieldName: "version_number", jsonFieldName: "versionNumber", swiftFieldName: "versionNumber")
      }
      if _tensorContent != Data() {
        try visitor.visitSingularField(fieldType: ProtobufBytes.self, value: _tensorContent, protoFieldNumber: 4, protoFieldName: "tensor_content", jsonFieldName: "tensorContent", swiftFieldName: "tensorContent")
      }
      if !_floatVal.isEmpty {
        try visitor.visitPackedField(fieldType: ProtobufFloat.self, value: _floatVal, protoFieldNumber: 5, protoFieldName: "float_val", jsonFieldName: "floatVal", swiftFieldName: "floatVal")
      }
      if !_doubleVal.isEmpty {
        try visitor.visitPackedField(fieldType: ProtobufDouble.self, value: _doubleVal, protoFieldNumber: 6, protoFieldName: "double_val", jsonFieldName: "doubleVal", swiftFieldName: "doubleVal")
      }
      if !_intVal.isEmpty {
        try visitor.visitPackedField(fieldType: ProtobufInt32.self, value: _intVal, protoFieldNumber: 7, protoFieldName: "int_val", jsonFieldName: "intVal", swiftFieldName: "intVal")
      }
      if !_stringVal.isEmpty {
        try visitor.visitRepeatedField(fieldType: ProtobufBytes.self, value: _stringVal, protoFieldNumber: 8, protoFieldName: "string_val", jsonFieldName: "stringVal", swiftFieldName: "stringVal")
      }
      if !_scomplexVal.isEmpty {
        try visitor.visitPackedField(fieldType: ProtobufFloat.self, value: _scomplexVal, protoFieldNumber: 9, protoFieldName: "scomplex_val", jsonFieldName: "scomplexVal", swiftFieldName: "scomplexVal")
      }
      if !_int64Val.isEmpty {
        try visitor.visitPackedField(fieldType: ProtobufInt64.self, value: _int64Val, protoFieldNumber: 10, protoFieldName: "int64_val", jsonFieldName: "int64Val", swiftFieldName: "int64Val")
      }
      if !_boolVal.isEmpty {
        try visitor.visitPackedField(fieldType: ProtobufBool.self, value: _boolVal, protoFieldNumber: 11, protoFieldName: "bool_val", jsonFieldName: "boolVal", swiftFieldName: "boolVal")
      }
      if !_dcomplexVal.isEmpty {
        try visitor.visitPackedField(fieldType: ProtobufDouble.self, value: _dcomplexVal, protoFieldNumber: 12, protoFieldName: "dcomplex_val", jsonFieldName: "dcomplexVal", swiftFieldName: "dcomplexVal")
      }
      if !_halfVal.isEmpty {
        try visitor.visitPackedField(fieldType: ProtobufInt32.self, value: _halfVal, protoFieldNumber: 13, protoFieldName: "half_val", jsonFieldName: "halfVal", swiftFieldName: "halfVal")
      }
    }

    var isEmpty: Bool {
      if _dtype != Tensorflow_DataType.dtInvalid {return false}
      if _tensorShape != nil {return false}
      if _versionNumber != 0 {return false}
      if _tensorContent != Data() {return false}
      if !_halfVal.isEmpty {return false}
      if !_floatVal.isEmpty {return false}
      if !_doubleVal.isEmpty {return false}
      if !_intVal.isEmpty {return false}
      if !_stringVal.isEmpty {return false}
      if !_scomplexVal.isEmpty {return false}
      if !_int64Val.isEmpty {return false}
      if !_boolVal.isEmpty {return false}
      if !_dcomplexVal.isEmpty {return false}
      return true
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _dtype != other._dtype {return false}
      if _tensorShape != other._tensorShape {return false}
      if _versionNumber != other._versionNumber {return false}
      if _tensorContent != other._tensorContent {return false}
      if _halfVal != other._halfVal {return false}
      if _floatVal != other._floatVal {return false}
      if _doubleVal != other._doubleVal {return false}
      if _intVal != other._intVal {return false}
      if _stringVal != other._stringVal {return false}
      if _scomplexVal != other._scomplexVal {return false}
      if _int64Val != other._int64Val {return false}
      if _boolVal != other._boolVal {return false}
      if _dcomplexVal != other._dcomplexVal {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._dtype = _dtype
      clone._tensorShape = _tensorShape
      clone._versionNumber = _versionNumber
      clone._tensorContent = _tensorContent
      clone._halfVal = _halfVal
      clone._floatVal = _floatVal
      clone._doubleVal = _doubleVal
      clone._intVal = _intVal
      clone._stringVal = _stringVal
      clone._scomplexVal = _scomplexVal
      clone._int64Val = _int64Val
      clone._boolVal = _boolVal
      clone._dcomplexVal = _dcomplexVal
      return clone
    }
  }

  private var _storage: _StorageClass?

  public var dtype: Tensorflow_DataType {
    get {return _storage?._dtype ?? Tensorflow_DataType.dtInvalid}
    set {_uniqueStorage()._dtype = newValue}
  }

  ///   Shape of the tensor.  TODO(touts): sort out the 0-rank issues.
  public var tensorShape: Tensorflow_TensorShapeProto {
    get {return _storage?._tensorShape ?? Tensorflow_TensorShapeProto()}
    set {_uniqueStorage()._tensorShape = newValue}
  }

  //  Only one of the representations below is set, one of "tensor_contents" and
  //  the "xxx_val" attributes.  We are not using oneof because as oneofs cannot
  //  contain repeated fields it would require another extra set of messages.

  ///   Version number.
  ///  
  ///   In version 0, if the "repeated xxx" representations contain only one
  ///   element, that element is repeated to fill the shape.  This makes it easy
  ///   to represent a constant Tensor with a single value.
  public var versionNumber: Int32 {
    get {return _storage?._versionNumber ?? 0}
    set {_uniqueStorage()._versionNumber = newValue}
  }

  ///   Serialized content from Tensor::AsProtoTensorContent(). This representation
  ///   can be used for all tensor types.
  public var tensorContent: Data {
    get {return _storage?._tensorContent ?? Data()}
    set {_uniqueStorage()._tensorContent = newValue}
  }

  //  Type specific representations that make it easy to create tensor protos in
  //  all languages.  Only the representation corresponding to "dtype" can
  //  be set.  The values hold the flattened representation of the tensor in
  //  row major order.

  ///   DT_HALF. Note that since protobuf has no int16 type, we'll have some
  ///   pointless zero padding for each value here.
  public var halfVal: [Int32] {
    get {return _storage?._halfVal ?? []}
    set {_uniqueStorage()._halfVal = newValue}
  }

  ///   DT_FLOAT.
  public var floatVal: [Float] {
    get {return _storage?._floatVal ?? []}
    set {_uniqueStorage()._floatVal = newValue}
  }

  ///   DT_DOUBLE.
  public var doubleVal: [Double] {
    get {return _storage?._doubleVal ?? []}
    set {_uniqueStorage()._doubleVal = newValue}
  }

  ///   DT_INT32, DT_INT16, DT_INT8, DT_UINT8.
  public var intVal: [Int32] {
    get {return _storage?._intVal ?? []}
    set {_uniqueStorage()._intVal = newValue}
  }

  ///   DT_STRING
  public var stringVal: [Data] {
    get {return _storage?._stringVal ?? []}
    set {_uniqueStorage()._stringVal = newValue}
  }

  ///   DT_COMPLEX64. scomplex_val(2*i) and scomplex_val(2*i+1) are real
  ///   and imaginary parts of i-th single precision complex.
  public var scomplexVal: [Float] {
    get {return _storage?._scomplexVal ?? []}
    set {_uniqueStorage()._scomplexVal = newValue}
  }

  ///   DT_INT64
  public var int64Val: [Int64] {
    get {return _storage?._int64Val ?? []}
    set {_uniqueStorage()._int64Val = newValue}
  }

  ///   DT_BOOL
  public var boolVal: [Bool] {
    get {return _storage?._boolVal ?? []}
    set {_uniqueStorage()._boolVal = newValue}
  }

  ///   DT_COMPLEX128. dcomplex_val(2*i) and dcomplex_val(2*i+1) are real
  ///   and imaginary parts of i-th double precision complex.
  public var dcomplexVal: [Double] {
    get {return _storage?._dcomplexVal ?? []}
    set {_uniqueStorage()._dcomplexVal = newValue}
  }

  public init() {}

  public init(dtype: Tensorflow_DataType? = nil,
    tensorShape: Tensorflow_TensorShapeProto? = nil,
    versionNumber: Int32? = nil,
    tensorContent: Data? = nil,
    halfVal: [Int32] = [],
    floatVal: [Float] = [],
    doubleVal: [Double] = [],
    intVal: [Int32] = [],
    stringVal: [Data] = [],
    scomplexVal: [Float] = [],
    int64Val: [Int64] = [],
    boolVal: [Bool] = [],
    dcomplexVal: [Double] = [])
  {
    let storage = _uniqueStorage()
    if let v = dtype {
      storage._dtype = v
    }
    storage._tensorShape = tensorShape
    if let v = versionNumber {
      storage._versionNumber = v
    }
    if let v = tensorContent {
      storage._tensorContent = v
    }
    if !halfVal.isEmpty {
      storage._halfVal = halfVal
    }
    if !floatVal.isEmpty {
      storage._floatVal = floatVal
    }
    if !doubleVal.isEmpty {
      storage._doubleVal = doubleVal
    }
    if !intVal.isEmpty {
      storage._intVal = intVal
    }
    if !stringVal.isEmpty {
      storage._stringVal = stringVal
    }
    if !scomplexVal.isEmpty {
      storage._scomplexVal = scomplexVal
    }
    if !int64Val.isEmpty {
      storage._int64Val = int64Val
    }
    if !boolVal.isEmpty {
      storage._boolVal = boolVal
    }
    if !dcomplexVal.isEmpty {
      storage._dcomplexVal = dcomplexVal
    }
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    try _storage?.traverse(visitor: &visitor)
  }

  public var _protoc_generated_isEmpty: Bool {return _storage?.isEmpty ?? true}

  public func _protoc_generated_isEqualTo(other: Tensorflow_TensorProto) -> Bool {
    if let s = _storage {
      if let os = other._storage {
        return s === os || s.isEqualTo(other: os)
      }
      return isEmpty // empty storage == nil storage
    } else if let os = other._storage {
      return os.isEmpty // nil storage == empty storage
    }
    return true // Both nil, both empty
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if _storage == nil {
      _storage = _StorageClass()
    } else if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage!.copy()
    }
    return _storage!
  }
}
