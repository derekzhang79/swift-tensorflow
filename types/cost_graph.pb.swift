/*
 * DO NOT EDIT.
 *
 * Generated by the protocol buffer compiler.
 * Source: tensorflow/core/framework/cost_graph.proto
 *
 */

import Foundation
import SwiftProtobuf


public struct Tensorflow_CostGraphDef: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_CostGraphDef"}
  public var protoMessageName: String {return "CostGraphDef"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "node": 1,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "node": 1,
  ]}

  public struct Node: ProtobufGeneratedMessage {
    public var swiftClassName: String {return "Tensorflow_CostGraphDef.Node"}
    public var protoMessageName: String {return "Node"}
    public var protoPackageName: String {return "tensorflow"}
    public var jsonFieldNames: [String: Int] {return [
      "name": 1,
      "device": 2,
      "id": 3,
      "inputInfo": 4,
      "outputInfo": 5,
      "temporaryMemorySize": 6,
      "computeCost": 9,
      "isFinal": 7,
      "controlInput": 8,
    ]}
    public var protoFieldNames: [String: Int] {return [
      "name": 1,
      "device": 2,
      "id": 3,
      "input_info": 4,
      "output_info": 5,
      "temporary_memory_size": 6,
      "compute_cost": 9,
      "is_final": 7,
      "control_input": 8,
    ]}

    ///   Inputs of this node. They must be executed before this node can be
    ///   executed. An input is a particular output of another node, specified
    ///   by the node id and the output index.
    public struct InputInfo: ProtobufGeneratedMessage {
      public var swiftClassName: String {return "Tensorflow_CostGraphDef.Node.InputInfo"}
      public var protoMessageName: String {return "InputInfo"}
      public var protoPackageName: String {return "tensorflow"}
      public var jsonFieldNames: [String: Int] {return [
        "precedingNode": 1,
        "precedingPort": 2,
      ]}
      public var protoFieldNames: [String: Int] {return [
        "preceding_node": 1,
        "preceding_port": 2,
      ]}

      public var precedingNode: Int32 = 0

      public var precedingPort: Int32 = 0

      public init() {}

      public init(precedingNode: Int32? = nil,
        precedingPort: Int32? = nil)
      {
        if let v = precedingNode {
          self.precedingNode = v
        }
        if let v = precedingPort {
          self.precedingPort = v
        }
      }

      public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
        let handled: Bool
        switch protoFieldNumber {
        case 1: handled = try setter.decodeSingularField(fieldType: ProtobufInt32.self, value: &precedingNode)
        case 2: handled = try setter.decodeSingularField(fieldType: ProtobufInt32.self, value: &precedingPort)
        default:
          handled = false
        }
        return handled
      }

      public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
        if precedingNode != 0 {
          try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: precedingNode, protoFieldNumber: 1, protoFieldName: "preceding_node", jsonFieldName: "precedingNode", swiftFieldName: "precedingNode")
        }
        if precedingPort != 0 {
          try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: precedingPort, protoFieldNumber: 2, protoFieldName: "preceding_port", jsonFieldName: "precedingPort", swiftFieldName: "precedingPort")
        }
      }

      public var _protoc_generated_isEmpty: Bool {
        if precedingNode != 0 {return false}
        if precedingPort != 0 {return false}
        return true
      }

      public func _protoc_generated_isEqualTo(other: Tensorflow_CostGraphDef.Node.InputInfo) -> Bool {
        if precedingNode != other.precedingNode {return false}
        if precedingPort != other.precedingPort {return false}
        return true
      }
    }

    ///   Outputs of this node.
    public struct OutputInfo: ProtobufGeneratedMessage {
      public var swiftClassName: String {return "Tensorflow_CostGraphDef.Node.OutputInfo"}
      public var protoMessageName: String {return "OutputInfo"}
      public var protoPackageName: String {return "tensorflow"}
      public var jsonFieldNames: [String: Int] {return [
        "size": 1,
        "aliasInputPort": 2,
      ]}
      public var protoFieldNames: [String: Int] {return [
        "size": 1,
        "alias_input_port": 2,
      ]}

      public var size: Int64 = 0

      ///   If >= 0, the output is an alias of an input. Note that an alias input
      ///   may itself be an alias. The algorithm will therefore need to follow
      ///   those pointers.
      public var aliasInputPort: Int64 = 0

      public init() {}

      public init(size: Int64? = nil,
        aliasInputPort: Int64? = nil)
      {
        if let v = size {
          self.size = v
        }
        if let v = aliasInputPort {
          self.aliasInputPort = v
        }
      }

      public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
        let handled: Bool
        switch protoFieldNumber {
        case 1: handled = try setter.decodeSingularField(fieldType: ProtobufInt64.self, value: &size)
        case 2: handled = try setter.decodeSingularField(fieldType: ProtobufInt64.self, value: &aliasInputPort)
        default:
          handled = false
        }
        return handled
      }

      public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
        if size != 0 {
          try visitor.visitSingularField(fieldType: ProtobufInt64.self, value: size, protoFieldNumber: 1, protoFieldName: "size", jsonFieldName: "size", swiftFieldName: "size")
        }
        if aliasInputPort != 0 {
          try visitor.visitSingularField(fieldType: ProtobufInt64.self, value: aliasInputPort, protoFieldNumber: 2, protoFieldName: "alias_input_port", jsonFieldName: "aliasInputPort", swiftFieldName: "aliasInputPort")
        }
      }

      public var _protoc_generated_isEmpty: Bool {
        if size != 0 {return false}
        if aliasInputPort != 0 {return false}
        return true
      }

      public func _protoc_generated_isEqualTo(other: Tensorflow_CostGraphDef.Node.OutputInfo) -> Bool {
        if size != other.size {return false}
        if aliasInputPort != other.aliasInputPort {return false}
        return true
      }
    }

    ///   The name of the node. Names are globally unique.
    public var name: String = ""

    ///   The device of the node. Can be empty if the node is mapped to the
    ///   default partition or partitioning hasn't been run yet.
    public var device: String = ""

    ///   The id of the node. Node ids are only unique inside a partition.
    public var id: Int32 = 0

    public var inputInfo: [Tensorflow_CostGraphDef.Node.InputInfo] = []

    public var outputInfo: [Tensorflow_CostGraphDef.Node.OutputInfo] = []

    ///   Temporary memory used by this node.
    public var temporaryMemorySize: Int64 = 0

    ///   Estimate of the computational cost of this node.
    public var computeCost: Int64 = 0

    ///   If true, the output is permanent: it can't be discarded, because this
    ///   node is part of the "final output". Nodes may depend on final nodes.
    public var isFinal: Bool = false

    ///   Ids of the control inputs for this node.
    public var controlInput: [Int32] = []

    public init() {}

    public init(name: String? = nil,
      device: String? = nil,
      id: Int32? = nil,
      inputInfo: [Tensorflow_CostGraphDef.Node.InputInfo] = [],
      outputInfo: [Tensorflow_CostGraphDef.Node.OutputInfo] = [],
      temporaryMemorySize: Int64? = nil,
      computeCost: Int64? = nil,
      isFinal: Bool? = nil,
      controlInput: [Int32] = [])
    {
      if let v = name {
        self.name = v
      }
      if let v = device {
        self.device = v
      }
      if let v = id {
        self.id = v
      }
      if !inputInfo.isEmpty {
        self.inputInfo = inputInfo
      }
      if !outputInfo.isEmpty {
        self.outputInfo = outputInfo
      }
      if let v = temporaryMemorySize {
        self.temporaryMemorySize = v
      }
      if let v = computeCost {
        self.computeCost = v
      }
      if let v = isFinal {
        self.isFinal = v
      }
      if !controlInput.isEmpty {
        self.controlInput = controlInput
      }
    }

    public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &name)
      case 2: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &device)
      case 3: handled = try setter.decodeSingularField(fieldType: ProtobufInt32.self, value: &id)
      case 4: handled = try setter.decodeRepeatedMessageField(fieldType: Tensorflow_CostGraphDef.Node.InputInfo.self, value: &inputInfo)
      case 5: handled = try setter.decodeRepeatedMessageField(fieldType: Tensorflow_CostGraphDef.Node.OutputInfo.self, value: &outputInfo)
      case 6: handled = try setter.decodeSingularField(fieldType: ProtobufInt64.self, value: &temporaryMemorySize)
      case 9: handled = try setter.decodeSingularField(fieldType: ProtobufInt64.self, value: &computeCost)
      case 7: handled = try setter.decodeSingularField(fieldType: ProtobufBool.self, value: &isFinal)
      case 8: handled = try setter.decodePackedField(fieldType: ProtobufInt32.self, value: &controlInput)
      default:
        handled = false
      }
      return handled
    }

    public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
      if name != "" {
        try visitor.visitSingularField(fieldType: ProtobufString.self, value: name, protoFieldNumber: 1, protoFieldName: "name", jsonFieldName: "name", swiftFieldName: "name")
      }
      if device != "" {
        try visitor.visitSingularField(fieldType: ProtobufString.self, value: device, protoFieldNumber: 2, protoFieldName: "device", jsonFieldName: "device", swiftFieldName: "device")
      }
      if id != 0 {
        try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: id, protoFieldNumber: 3, protoFieldName: "id", jsonFieldName: "id", swiftFieldName: "id")
      }
      if !inputInfo.isEmpty {
        try visitor.visitRepeatedMessageField(value: inputInfo, protoFieldNumber: 4, protoFieldName: "input_info", jsonFieldName: "inputInfo", swiftFieldName: "inputInfo")
      }
      if !outputInfo.isEmpty {
        try visitor.visitRepeatedMessageField(value: outputInfo, protoFieldNumber: 5, protoFieldName: "output_info", jsonFieldName: "outputInfo", swiftFieldName: "outputInfo")
      }
      if temporaryMemorySize != 0 {
        try visitor.visitSingularField(fieldType: ProtobufInt64.self, value: temporaryMemorySize, protoFieldNumber: 6, protoFieldName: "temporary_memory_size", jsonFieldName: "temporaryMemorySize", swiftFieldName: "temporaryMemorySize")
      }
      if isFinal != false {
        try visitor.visitSingularField(fieldType: ProtobufBool.self, value: isFinal, protoFieldNumber: 7, protoFieldName: "is_final", jsonFieldName: "isFinal", swiftFieldName: "isFinal")
      }
      if !controlInput.isEmpty {
        try visitor.visitPackedField(fieldType: ProtobufInt32.self, value: controlInput, protoFieldNumber: 8, protoFieldName: "control_input", jsonFieldName: "controlInput", swiftFieldName: "controlInput")
      }
      if computeCost != 0 {
        try visitor.visitSingularField(fieldType: ProtobufInt64.self, value: computeCost, protoFieldNumber: 9, protoFieldName: "compute_cost", jsonFieldName: "computeCost", swiftFieldName: "computeCost")
      }
    }

    public var _protoc_generated_isEmpty: Bool {
      if name != "" {return false}
      if device != "" {return false}
      if id != 0 {return false}
      if !inputInfo.isEmpty {return false}
      if !outputInfo.isEmpty {return false}
      if temporaryMemorySize != 0 {return false}
      if computeCost != 0 {return false}
      if isFinal != false {return false}
      if !controlInput.isEmpty {return false}
      return true
    }

    public func _protoc_generated_isEqualTo(other: Tensorflow_CostGraphDef.Node) -> Bool {
      if name != other.name {return false}
      if device != other.device {return false}
      if id != other.id {return false}
      if inputInfo != other.inputInfo {return false}
      if outputInfo != other.outputInfo {return false}
      if temporaryMemorySize != other.temporaryMemorySize {return false}
      if computeCost != other.computeCost {return false}
      if isFinal != other.isFinal {return false}
      if controlInput != other.controlInput {return false}
      return true
    }
  }

  public var node: [Tensorflow_CostGraphDef.Node] = []

  public init() {}

  public init(node: [Tensorflow_CostGraphDef.Node] = [])
  {
    if !node.isEmpty {
      self.node = node
    }
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeRepeatedMessageField(fieldType: Tensorflow_CostGraphDef.Node.self, value: &node)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if !node.isEmpty {
      try visitor.visitRepeatedMessageField(value: node, protoFieldNumber: 1, protoFieldName: "node", jsonFieldName: "node", swiftFieldName: "node")
    }
  }

  public var _protoc_generated_isEmpty: Bool {
    if !node.isEmpty {return false}
    return true
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_CostGraphDef) -> Bool {
    if node != other.node {return false}
    return true
  }
}
