/*
 * DO NOT EDIT.
 *
 * Generated by the protocol buffer compiler.
 * Source: tensorflow/core/framework/tensor_description.proto
 *
 */

import Foundation
import SwiftProtobuf


public struct Tensorflow_TensorDescription: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_TensorDescription"}
  public var protoMessageName: String {return "TensorDescription"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "dtype": 1,
    "shape": 2,
    "allocationDescription": 4,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "dtype": 1,
    "shape": 2,
    "allocation_description": 4,
  ]}

  private class _StorageClass {
    typealias ProtobufExtendedMessage = Tensorflow_TensorDescription
    var _dtype: Tensorflow_DataType = Tensorflow_DataType.dtInvalid
    var _shape: Tensorflow_TensorShapeProto? = nil
    var _allocationDescription: Tensorflow_AllocationDescription? = nil

    init() {}

    func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodeSingularField(fieldType: Tensorflow_DataType.self, value: &_dtype)
      case 2: handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_TensorShapeProto.self, value: &_shape)
      case 4: handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_AllocationDescription.self, value: &_allocationDescription)
      default:
        handled = false
      }
      return handled
    }

    func traverse(visitor: inout ProtobufVisitor) throws {
      if _dtype != Tensorflow_DataType.dtInvalid {
        try visitor.visitSingularField(fieldType: Tensorflow_DataType.self, value: _dtype, protoFieldNumber: 1, protoFieldName: "dtype", jsonFieldName: "dtype", swiftFieldName: "dtype")
      }
      if let v = _shape {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 2, protoFieldName: "shape", jsonFieldName: "shape", swiftFieldName: "shape")
      }
      if let v = _allocationDescription {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 4, protoFieldName: "allocation_description", jsonFieldName: "allocationDescription", swiftFieldName: "allocationDescription")
      }
    }

    var isEmpty: Bool {
      if _dtype != Tensorflow_DataType.dtInvalid {return false}
      if _shape != nil {return false}
      if _allocationDescription != nil {return false}
      return true
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _dtype != other._dtype {return false}
      if _shape != other._shape {return false}
      if _allocationDescription != other._allocationDescription {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._dtype = _dtype
      clone._shape = _shape
      clone._allocationDescription = _allocationDescription
      return clone
    }
  }

  private var _storage: _StorageClass?

  ///   Data type of tensor elements
  public var dtype: Tensorflow_DataType {
    get {return _storage?._dtype ?? Tensorflow_DataType.dtInvalid}
    set {_uniqueStorage()._dtype = newValue}
  }

  ///   Shape of the tensor.
  public var shape: Tensorflow_TensorShapeProto {
    get {return _storage?._shape ?? Tensorflow_TensorShapeProto()}
    set {_uniqueStorage()._shape = newValue}
  }

  ///   Information about the size and allocator used for the data
  public var allocationDescription: Tensorflow_AllocationDescription {
    get {return _storage?._allocationDescription ?? Tensorflow_AllocationDescription()}
    set {_uniqueStorage()._allocationDescription = newValue}
  }

  public init() {}

  public init(dtype: Tensorflow_DataType? = nil,
    shape: Tensorflow_TensorShapeProto? = nil,
    allocationDescription: Tensorflow_AllocationDescription? = nil)
  {
    let storage = _uniqueStorage()
    if let v = dtype {
      storage._dtype = v
    }
    storage._shape = shape
    storage._allocationDescription = allocationDescription
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    try _storage?.traverse(visitor: &visitor)
  }

  public var _protoc_generated_isEmpty: Bool {return _storage?.isEmpty ?? true}

  public func _protoc_generated_isEqualTo(other: Tensorflow_TensorDescription) -> Bool {
    if let s = _storage {
      if let os = other._storage {
        return s === os || s.isEqualTo(other: os)
      }
      return isEmpty // empty storage == nil storage
    } else if let os = other._storage {
      return os.isEmpty // nil storage == empty storage
    }
    return true // Both nil, both empty
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if _storage == nil {
      _storage = _StorageClass()
    } else if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage!.copy()
    }
    return _storage!
  }
}
