/*
 * DO NOT EDIT.
 *
 * Generated by the protocol buffer compiler.
 * Source: tensorflow/core/framework/tensor_slice.proto
 *
 */

//  Protocol buffer representing slices of a tensor

import Foundation
import SwiftProtobuf


///   Can only be interpreted if you know the corresponding TensorShape.
public struct Tensorflow_TensorSliceProto: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_TensorSliceProto"}
  public var protoMessageName: String {return "TensorSliceProto"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "extent": 1,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "extent": 1,
  ]}

  ///   Extent of the slice in one dimension.
  public struct Extent: ProtobufGeneratedMessage {
    public var swiftClassName: String {return "Tensorflow_TensorSliceProto.Extent"}
    public var protoMessageName: String {return "Extent"}
    public var protoPackageName: String {return "tensorflow"}
    public var jsonFieldNames: [String: Int] {return [
      "start": 1,
      "length": 2,
    ]}
    public var protoFieldNames: [String: Int] {return [
      "start": 1,
      "length": 2,
    ]}

    public enum OneOf_HasLength: ExpressibleByNilLiteral, ProtobufOneofEnum {
      case length(Int64)
      case None

      public init(nilLiteral: ()) {
        self = .None
      }

      public init() {
        self = .None
      }

      public mutating func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
        if self != .None && setter.rejectConflictingOneof {
          throw ProtobufDecodingError.duplicatedOneOf
        }
        let handled: Bool
        switch protoFieldNumber {
        case 2:
          var value = Int64()
          handled = try setter.decodeSingularField(fieldType: ProtobufInt64.self, value: &value)
          self = .length(value)
        default:
          handled = false
          self = .None
        }
        return handled
      }

      public func traverse(visitor: inout ProtobufVisitor, start: Int, end: Int) throws {
        switch self {
        case .length(let v):
          if start <= 2 && 2 < end {
            try visitor.visitSingularField(fieldType: ProtobufInt64.self, value: v, protoFieldNumber: 2, protoFieldName: "length", jsonFieldName: "length", swiftFieldName: "length")
          }
        case .None:
          break
        }
      }

      public var isEmpty: Bool {return self == .None}
    }

    ///   Start index of the slice, starting at 0.
    public var start: Int64 = 0

    public var length: Int64? {
      get {
        if case .length(let v) = hasLength {
          return v
        }
        return nil
      }
      set {
        if let newValue = newValue {
          hasLength = .length(newValue)
        } else {
          hasLength = .None
        }
      }
    }

    public var hasLength: Tensorflow_TensorSliceProto.Extent.OneOf_HasLength = .None

    public init() {}

    public init(start: Int64? = nil,
      length: Int64? = nil)
    {
      if let v = start {
        self.start = v
      }
      if let v = length {
        self.hasLength = .length(v)
      }
    }

    public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodeSingularField(fieldType: ProtobufInt64.self, value: &start)
      case 2:
        handled = try hasLength.decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
      default:
        handled = false
      }
      return handled
    }

    public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
      if start != 0 {
        try visitor.visitSingularField(fieldType: ProtobufInt64.self, value: start, protoFieldNumber: 1, protoFieldName: "start", jsonFieldName: "start", swiftFieldName: "start")
      }
      try hasLength.traverse(visitor: &visitor, start: 2, end: 3)
    }

    public var _protoc_generated_isEmpty: Bool {
      if start != 0 {return false}
      if !hasLength.isEmpty {return false}
      return true
    }

    public func _protoc_generated_isEqualTo(other: Tensorflow_TensorSliceProto.Extent) -> Bool {
      if start != other.start {return false}
      if hasLength != other.hasLength {return false}
      return true
    }
  }

  ///   Extent of the slice in all tensor dimensions.
  ///  
  ///   Must have one entry for each of the dimension of the tensor that this
  ///   slice belongs to.  The order of sizes is the same as the order of
  ///   dimensions in the TensorShape.
  public var extent: [Tensorflow_TensorSliceProto.Extent] = []

  public init() {}

  public init(extent: [Tensorflow_TensorSliceProto.Extent] = [])
  {
    if !extent.isEmpty {
      self.extent = extent
    }
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeRepeatedMessageField(fieldType: Tensorflow_TensorSliceProto.Extent.self, value: &extent)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if !extent.isEmpty {
      try visitor.visitRepeatedMessageField(value: extent, protoFieldNumber: 1, protoFieldName: "extent", jsonFieldName: "extent", swiftFieldName: "extent")
    }
  }

  public var _protoc_generated_isEmpty: Bool {
    if !extent.isEmpty {return false}
    return true
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_TensorSliceProto) -> Bool {
    if extent != other.extent {return false}
    return true
  }
}

public func ==(lhs: Tensorflow_TensorSliceProto.Extent.OneOf_HasLength, rhs: Tensorflow_TensorSliceProto.Extent.OneOf_HasLength) -> Bool {
  switch (lhs, rhs) {
  case (.length(let l), .length(let r)): return l == r
  case (.None, .None): return true
  default: return false
  }
}
