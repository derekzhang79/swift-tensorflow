/*
 * DO NOT EDIT.
 *
 * Generated by the protocol buffer compiler.
 * Source: tensorflow/core/framework/variable.proto
 *
 */

import Foundation
import SwiftProtobuf


///   Protocol buffer representing a Variable.
public struct Tensorflow_VariableDef: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_VariableDef"}
  public var protoMessageName: String {return "VariableDef"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "variableName": 1,
    "initializerName": 2,
    "snapshotName": 3,
    "saveSliceInfoDef": 4,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "variable_name": 1,
    "initializer_name": 2,
    "snapshot_name": 3,
    "save_slice_info_def": 4,
  ]}

  private class _StorageClass {
    typealias ProtobufExtendedMessage = Tensorflow_VariableDef
    var _variableName: String = ""
    var _initializerName: String = ""
    var _snapshotName: String = ""
    var _saveSliceInfoDef: Tensorflow_SaveSliceInfoDef? = nil

    init() {}

    func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &_variableName)
      case 2: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &_initializerName)
      case 3: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &_snapshotName)
      case 4: handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_SaveSliceInfoDef.self, value: &_saveSliceInfoDef)
      default:
        handled = false
      }
      return handled
    }

    func traverse(visitor: inout ProtobufVisitor) throws {
      if _variableName != "" {
        try visitor.visitSingularField(fieldType: ProtobufString.self, value: _variableName, protoFieldNumber: 1, protoFieldName: "variable_name", jsonFieldName: "variableName", swiftFieldName: "variableName")
      }
      if _initializerName != "" {
        try visitor.visitSingularField(fieldType: ProtobufString.self, value: _initializerName, protoFieldNumber: 2, protoFieldName: "initializer_name", jsonFieldName: "initializerName", swiftFieldName: "initializerName")
      }
      if _snapshotName != "" {
        try visitor.visitSingularField(fieldType: ProtobufString.self, value: _snapshotName, protoFieldNumber: 3, protoFieldName: "snapshot_name", jsonFieldName: "snapshotName", swiftFieldName: "snapshotName")
      }
      if let v = _saveSliceInfoDef {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 4, protoFieldName: "save_slice_info_def", jsonFieldName: "saveSliceInfoDef", swiftFieldName: "saveSliceInfoDef")
      }
    }

    var isEmpty: Bool {
      if _variableName != "" {return false}
      if _initializerName != "" {return false}
      if _snapshotName != "" {return false}
      if _saveSliceInfoDef != nil {return false}
      return true
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _variableName != other._variableName {return false}
      if _initializerName != other._initializerName {return false}
      if _snapshotName != other._snapshotName {return false}
      if _saveSliceInfoDef != other._saveSliceInfoDef {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._variableName = _variableName
      clone._initializerName = _initializerName
      clone._snapshotName = _snapshotName
      clone._saveSliceInfoDef = _saveSliceInfoDef
      return clone
    }
  }

  private var _storage: _StorageClass?

  ///   Name of the variable tensor.
  public var variableName: String {
    get {return _storage?._variableName ?? ""}
    set {_uniqueStorage()._variableName = newValue}
  }

  ///   Name of the initializer op.
  public var initializerName: String {
    get {return _storage?._initializerName ?? ""}
    set {_uniqueStorage()._initializerName = newValue}
  }

  ///   Name of the snapshot tensor.
  public var snapshotName: String {
    get {return _storage?._snapshotName ?? ""}
    set {_uniqueStorage()._snapshotName = newValue}
  }

  ///   Support for saving variables as slices of a larger variable.
  public var saveSliceInfoDef: Tensorflow_SaveSliceInfoDef {
    get {return _storage?._saveSliceInfoDef ?? Tensorflow_SaveSliceInfoDef()}
    set {_uniqueStorage()._saveSliceInfoDef = newValue}
  }

  public init() {}

  public init(variableName: String? = nil,
    initializerName: String? = nil,
    snapshotName: String? = nil,
    saveSliceInfoDef: Tensorflow_SaveSliceInfoDef? = nil)
  {
    let storage = _uniqueStorage()
    if let v = variableName {
      storage._variableName = v
    }
    if let v = initializerName {
      storage._initializerName = v
    }
    if let v = snapshotName {
      storage._snapshotName = v
    }
    storage._saveSliceInfoDef = saveSliceInfoDef
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    try _storage?.traverse(visitor: &visitor)
  }

  public var _protoc_generated_isEmpty: Bool {return _storage?.isEmpty ?? true}

  public func _protoc_generated_isEqualTo(other: Tensorflow_VariableDef) -> Bool {
    if let s = _storage {
      if let os = other._storage {
        return s === os || s.isEqualTo(other: os)
      }
      return isEmpty // empty storage == nil storage
    } else if let os = other._storage {
      return os.isEmpty // nil storage == empty storage
    }
    return true // Both nil, both empty
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if _storage == nil {
      _storage = _StorageClass()
    } else if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage!.copy()
    }
    return _storage!
  }
}

public struct Tensorflow_SaveSliceInfoDef: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_SaveSliceInfoDef"}
  public var protoMessageName: String {return "SaveSliceInfoDef"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "fullName": 1,
    "fullShape": 2,
    "varOffset": 3,
    "varShape": 4,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "full_name": 1,
    "full_shape": 2,
    "var_offset": 3,
    "var_shape": 4,
  ]}

  ///   Name of the full variable of which this is a slice.
  public var fullName: String = ""

  ///   Shape of the full variable.
  public var fullShape: [Int32] = []

  ///   Offset of this variable into the full variable.
  public var varOffset: [Int32] = []

  ///   Shape of this variable.
  public var varShape: [Int32] = []

  public init() {}

  public init(fullName: String? = nil,
    fullShape: [Int32] = [],
    varOffset: [Int32] = [],
    varShape: [Int32] = [])
  {
    if let v = fullName {
      self.fullName = v
    }
    if !fullShape.isEmpty {
      self.fullShape = fullShape
    }
    if !varOffset.isEmpty {
      self.varOffset = varOffset
    }
    if !varShape.isEmpty {
      self.varShape = varShape
    }
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &fullName)
    case 2: handled = try setter.decodePackedField(fieldType: ProtobufInt32.self, value: &fullShape)
    case 3: handled = try setter.decodePackedField(fieldType: ProtobufInt32.self, value: &varOffset)
    case 4: handled = try setter.decodePackedField(fieldType: ProtobufInt32.self, value: &varShape)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if fullName != "" {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: fullName, protoFieldNumber: 1, protoFieldName: "full_name", jsonFieldName: "fullName", swiftFieldName: "fullName")
    }
    if !fullShape.isEmpty {
      try visitor.visitPackedField(fieldType: ProtobufInt32.self, value: fullShape, protoFieldNumber: 2, protoFieldName: "full_shape", jsonFieldName: "fullShape", swiftFieldName: "fullShape")
    }
    if !varOffset.isEmpty {
      try visitor.visitPackedField(fieldType: ProtobufInt32.self, value: varOffset, protoFieldNumber: 3, protoFieldName: "var_offset", jsonFieldName: "varOffset", swiftFieldName: "varOffset")
    }
    if !varShape.isEmpty {
      try visitor.visitPackedField(fieldType: ProtobufInt32.self, value: varShape, protoFieldNumber: 4, protoFieldName: "var_shape", jsonFieldName: "varShape", swiftFieldName: "varShape")
    }
  }

  public var _protoc_generated_isEmpty: Bool {
    if fullName != "" {return false}
    if !fullShape.isEmpty {return false}
    if !varOffset.isEmpty {return false}
    if !varShape.isEmpty {return false}
    return true
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_SaveSliceInfoDef) -> Bool {
    if fullName != other.fullName {return false}
    if fullShape != other.fullShape {return false}
    if varOffset != other.varOffset {return false}
    if varShape != other.varShape {return false}
    return true
  }
}
