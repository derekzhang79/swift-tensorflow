/*
 * DO NOT EDIT.
 *
 * Generated by the protocol buffer compiler.
 * Source: tensorflow/core/framework/log_memory.proto
 *
 */

import Foundation
import SwiftProtobuf


public struct Tensorflow_MemoryLogStep: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_MemoryLogStep"}
  public var protoMessageName: String {return "MemoryLogStep"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "stepId": 1,
    "handle": 2,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "step_id": 1,
    "handle": 2,
  ]}

  ///   Process-unique step id.
  public var stepId: Int64 = 0

  ///   Handle describing the feeds and fetches of the step.
  public var handle: String = ""

  public init() {}

  public init(stepId: Int64? = nil,
    handle: String? = nil)
  {
    if let v = stepId {
      self.stepId = v
    }
    if let v = handle {
      self.handle = v
    }
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeSingularField(fieldType: ProtobufInt64.self, value: &stepId)
    case 2: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &handle)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if stepId != 0 {
      try visitor.visitSingularField(fieldType: ProtobufInt64.self, value: stepId, protoFieldNumber: 1, protoFieldName: "step_id", jsonFieldName: "stepId", swiftFieldName: "stepId")
    }
    if handle != "" {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: handle, protoFieldNumber: 2, protoFieldName: "handle", jsonFieldName: "handle", swiftFieldName: "handle")
    }
  }

  public var _protoc_generated_isEmpty: Bool {
    if stepId != 0 {return false}
    if handle != "" {return false}
    return true
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_MemoryLogStep) -> Bool {
    if stepId != other.stepId {return false}
    if handle != other.handle {return false}
    return true
  }
}

public struct Tensorflow_MemoryLogTensorAllocation: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_MemoryLogTensorAllocation"}
  public var protoMessageName: String {return "MemoryLogTensorAllocation"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "stepId": 1,
    "kernelName": 2,
    "tensor": 3,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "step_id": 1,
    "kernel_name": 2,
    "tensor": 3,
  ]}

  private class _StorageClass {
    typealias ProtobufExtendedMessage = Tensorflow_MemoryLogTensorAllocation
    var _stepId: Int64 = 0
    var _kernelName: String = ""
    var _tensor: Tensorflow_TensorDescription? = nil

    init() {}

    func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodeSingularField(fieldType: ProtobufInt64.self, value: &_stepId)
      case 2: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &_kernelName)
      case 3: handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_TensorDescription.self, value: &_tensor)
      default:
        handled = false
      }
      return handled
    }

    func traverse(visitor: inout ProtobufVisitor) throws {
      if _stepId != 0 {
        try visitor.visitSingularField(fieldType: ProtobufInt64.self, value: _stepId, protoFieldNumber: 1, protoFieldName: "step_id", jsonFieldName: "stepId", swiftFieldName: "stepId")
      }
      if _kernelName != "" {
        try visitor.visitSingularField(fieldType: ProtobufString.self, value: _kernelName, protoFieldNumber: 2, protoFieldName: "kernel_name", jsonFieldName: "kernelName", swiftFieldName: "kernelName")
      }
      if let v = _tensor {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 3, protoFieldName: "tensor", jsonFieldName: "tensor", swiftFieldName: "tensor")
      }
    }

    var isEmpty: Bool {
      if _stepId != 0 {return false}
      if _kernelName != "" {return false}
      if _tensor != nil {return false}
      return true
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _stepId != other._stepId {return false}
      if _kernelName != other._kernelName {return false}
      if _tensor != other._tensor {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._stepId = _stepId
      clone._kernelName = _kernelName
      clone._tensor = _tensor
      return clone
    }
  }

  private var _storage: _StorageClass?

  ///   Process-unique step id.
  public var stepId: Int64 {
    get {return _storage?._stepId ?? 0}
    set {_uniqueStorage()._stepId = newValue}
  }

  ///   Name of the kernel making the allocation as set in GraphDef,
  ///   e.g., "affine2/weights/Assign".
  public var kernelName: String {
    get {return _storage?._kernelName ?? ""}
    set {_uniqueStorage()._kernelName = newValue}
  }

  ///   Allocated tensor details.
  public var tensor: Tensorflow_TensorDescription {
    get {return _storage?._tensor ?? Tensorflow_TensorDescription()}
    set {_uniqueStorage()._tensor = newValue}
  }

  public init() {}

  public init(stepId: Int64? = nil,
    kernelName: String? = nil,
    tensor: Tensorflow_TensorDescription? = nil)
  {
    let storage = _uniqueStorage()
    if let v = stepId {
      storage._stepId = v
    }
    if let v = kernelName {
      storage._kernelName = v
    }
    storage._tensor = tensor
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    try _storage?.traverse(visitor: &visitor)
  }

  public var _protoc_generated_isEmpty: Bool {return _storage?.isEmpty ?? true}

  public func _protoc_generated_isEqualTo(other: Tensorflow_MemoryLogTensorAllocation) -> Bool {
    if let s = _storage {
      if let os = other._storage {
        return s === os || s.isEqualTo(other: os)
      }
      return isEmpty // empty storage == nil storage
    } else if let os = other._storage {
      return os.isEmpty // nil storage == empty storage
    }
    return true // Both nil, both empty
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if _storage == nil {
      _storage = _StorageClass()
    } else if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage!.copy()
    }
    return _storage!
  }
}

public struct Tensorflow_MemoryLogTensorDeallocation: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_MemoryLogTensorDeallocation"}
  public var protoMessageName: String {return "MemoryLogTensorDeallocation"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "allocationId": 1,
    "allocatorName": 2,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "allocation_id": 1,
    "allocator_name": 2,
  ]}

  ///   Id of the tensor buffer being deallocated, used to match to a
  ///   corresponding allocation.
  public var allocationId: Int64 = 0

  ///   Name of the allocator used.
  public var allocatorName: String = ""

  public init() {}

  public init(allocationId: Int64? = nil,
    allocatorName: String? = nil)
  {
    if let v = allocationId {
      self.allocationId = v
    }
    if let v = allocatorName {
      self.allocatorName = v
    }
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeSingularField(fieldType: ProtobufInt64.self, value: &allocationId)
    case 2: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &allocatorName)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if allocationId != 0 {
      try visitor.visitSingularField(fieldType: ProtobufInt64.self, value: allocationId, protoFieldNumber: 1, protoFieldName: "allocation_id", jsonFieldName: "allocationId", swiftFieldName: "allocationId")
    }
    if allocatorName != "" {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: allocatorName, protoFieldNumber: 2, protoFieldName: "allocator_name", jsonFieldName: "allocatorName", swiftFieldName: "allocatorName")
    }
  }

  public var _protoc_generated_isEmpty: Bool {
    if allocationId != 0 {return false}
    if allocatorName != "" {return false}
    return true
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_MemoryLogTensorDeallocation) -> Bool {
    if allocationId != other.allocationId {return false}
    if allocatorName != other.allocatorName {return false}
    return true
  }
}

public struct Tensorflow_MemoryLogTensorOutput: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_MemoryLogTensorOutput"}
  public var protoMessageName: String {return "MemoryLogTensorOutput"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "stepId": 1,
    "kernelName": 2,
    "index": 3,
    "tensor": 4,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "step_id": 1,
    "kernel_name": 2,
    "index": 3,
    "tensor": 4,
  ]}

  private class _StorageClass {
    typealias ProtobufExtendedMessage = Tensorflow_MemoryLogTensorOutput
    var _stepId: Int64 = 0
    var _kernelName: String = ""
    var _index: Int32 = 0
    var _tensor: Tensorflow_TensorDescription? = nil

    init() {}

    func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodeSingularField(fieldType: ProtobufInt64.self, value: &_stepId)
      case 2: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &_kernelName)
      case 3: handled = try setter.decodeSingularField(fieldType: ProtobufInt32.self, value: &_index)
      case 4: handled = try setter.decodeSingularMessageField(fieldType: Tensorflow_TensorDescription.self, value: &_tensor)
      default:
        handled = false
      }
      return handled
    }

    func traverse(visitor: inout ProtobufVisitor) throws {
      if _stepId != 0 {
        try visitor.visitSingularField(fieldType: ProtobufInt64.self, value: _stepId, protoFieldNumber: 1, protoFieldName: "step_id", jsonFieldName: "stepId", swiftFieldName: "stepId")
      }
      if _kernelName != "" {
        try visitor.visitSingularField(fieldType: ProtobufString.self, value: _kernelName, protoFieldNumber: 2, protoFieldName: "kernel_name", jsonFieldName: "kernelName", swiftFieldName: "kernelName")
      }
      if _index != 0 {
        try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: _index, protoFieldNumber: 3, protoFieldName: "index", jsonFieldName: "index", swiftFieldName: "index")
      }
      if let v = _tensor {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 4, protoFieldName: "tensor", jsonFieldName: "tensor", swiftFieldName: "tensor")
      }
    }

    var isEmpty: Bool {
      if _stepId != 0 {return false}
      if _kernelName != "" {return false}
      if _index != 0 {return false}
      if _tensor != nil {return false}
      return true
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _stepId != other._stepId {return false}
      if _kernelName != other._kernelName {return false}
      if _index != other._index {return false}
      if _tensor != other._tensor {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone._stepId = _stepId
      clone._kernelName = _kernelName
      clone._index = _index
      clone._tensor = _tensor
      return clone
    }
  }

  private var _storage: _StorageClass?

  ///   Process-unique step id.
  public var stepId: Int64 {
    get {return _storage?._stepId ?? 0}
    set {_uniqueStorage()._stepId = newValue}
  }

  ///   Name of the kernel producing an output as set in GraphDef, e.g.,
  ///   "affine2/weights/Assign".
  public var kernelName: String {
    get {return _storage?._kernelName ?? ""}
    set {_uniqueStorage()._kernelName = newValue}
  }

  ///   Index of the output being set.
  public var index: Int32 {
    get {return _storage?._index ?? 0}
    set {_uniqueStorage()._index = newValue}
  }

  ///   Output tensor details.
  public var tensor: Tensorflow_TensorDescription {
    get {return _storage?._tensor ?? Tensorflow_TensorDescription()}
    set {_uniqueStorage()._tensor = newValue}
  }

  public init() {}

  public init(stepId: Int64? = nil,
    kernelName: String? = nil,
    index: Int32? = nil,
    tensor: Tensorflow_TensorDescription? = nil)
  {
    let storage = _uniqueStorage()
    if let v = stepId {
      storage._stepId = v
    }
    if let v = kernelName {
      storage._kernelName = v
    }
    if let v = index {
      storage._index = v
    }
    storage._tensor = tensor
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    try _storage?.traverse(visitor: &visitor)
  }

  public var _protoc_generated_isEmpty: Bool {return _storage?.isEmpty ?? true}

  public func _protoc_generated_isEqualTo(other: Tensorflow_MemoryLogTensorOutput) -> Bool {
    if let s = _storage {
      if let os = other._storage {
        return s === os || s.isEqualTo(other: os)
      }
      return isEmpty // empty storage == nil storage
    } else if let os = other._storage {
      return os.isEmpty // nil storage == empty storage
    }
    return true // Both nil, both empty
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if _storage == nil {
      _storage = _StorageClass()
    } else if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage!.copy()
    }
    return _storage!
  }
}

public struct Tensorflow_MemoryLogRawAllocation: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_MemoryLogRawAllocation"}
  public var protoMessageName: String {return "MemoryLogRawAllocation"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "stepId": 1,
    "operation": 2,
    "numBytes": 3,
    "ptr": 4,
    "allocationId": 5,
    "allocatorName": 6,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "step_id": 1,
    "operation": 2,
    "num_bytes": 3,
    "ptr": 4,
    "allocation_id": 5,
    "allocator_name": 6,
  ]}

  ///   Process-unique step id.
  public var stepId: Int64 = 0

  ///   Name of the operation making the allocation.
  public var operation: String = ""

  ///   Number of bytes in the allocation.
  public var numBytes: Int64 = 0

  ///   Address of the allocation.
  public var ptr: UInt64 = 0

  ///   Id of the tensor buffer being allocated, used to match to a
  ///   corresponding deallocation.
  public var allocationId: Int64 = 0

  ///   Name of the allocator used.
  public var allocatorName: String = ""

  public init() {}

  public init(stepId: Int64? = nil,
    operation: String? = nil,
    numBytes: Int64? = nil,
    ptr: UInt64? = nil,
    allocationId: Int64? = nil,
    allocatorName: String? = nil)
  {
    if let v = stepId {
      self.stepId = v
    }
    if let v = operation {
      self.operation = v
    }
    if let v = numBytes {
      self.numBytes = v
    }
    if let v = ptr {
      self.ptr = v
    }
    if let v = allocationId {
      self.allocationId = v
    }
    if let v = allocatorName {
      self.allocatorName = v
    }
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeSingularField(fieldType: ProtobufInt64.self, value: &stepId)
    case 2: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &operation)
    case 3: handled = try setter.decodeSingularField(fieldType: ProtobufInt64.self, value: &numBytes)
    case 4: handled = try setter.decodeSingularField(fieldType: ProtobufUInt64.self, value: &ptr)
    case 5: handled = try setter.decodeSingularField(fieldType: ProtobufInt64.self, value: &allocationId)
    case 6: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &allocatorName)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if stepId != 0 {
      try visitor.visitSingularField(fieldType: ProtobufInt64.self, value: stepId, protoFieldNumber: 1, protoFieldName: "step_id", jsonFieldName: "stepId", swiftFieldName: "stepId")
    }
    if operation != "" {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: operation, protoFieldNumber: 2, protoFieldName: "operation", jsonFieldName: "operation", swiftFieldName: "operation")
    }
    if numBytes != 0 {
      try visitor.visitSingularField(fieldType: ProtobufInt64.self, value: numBytes, protoFieldNumber: 3, protoFieldName: "num_bytes", jsonFieldName: "numBytes", swiftFieldName: "numBytes")
    }
    if ptr != 0 {
      try visitor.visitSingularField(fieldType: ProtobufUInt64.self, value: ptr, protoFieldNumber: 4, protoFieldName: "ptr", jsonFieldName: "ptr", swiftFieldName: "ptr")
    }
    if allocationId != 0 {
      try visitor.visitSingularField(fieldType: ProtobufInt64.self, value: allocationId, protoFieldNumber: 5, protoFieldName: "allocation_id", jsonFieldName: "allocationId", swiftFieldName: "allocationId")
    }
    if allocatorName != "" {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: allocatorName, protoFieldNumber: 6, protoFieldName: "allocator_name", jsonFieldName: "allocatorName", swiftFieldName: "allocatorName")
    }
  }

  public var _protoc_generated_isEmpty: Bool {
    if stepId != 0 {return false}
    if operation != "" {return false}
    if numBytes != 0 {return false}
    if ptr != 0 {return false}
    if allocationId != 0 {return false}
    if allocatorName != "" {return false}
    return true
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_MemoryLogRawAllocation) -> Bool {
    if stepId != other.stepId {return false}
    if operation != other.operation {return false}
    if numBytes != other.numBytes {return false}
    if ptr != other.ptr {return false}
    if allocationId != other.allocationId {return false}
    if allocatorName != other.allocatorName {return false}
    return true
  }
}

public struct Tensorflow_MemoryLogRawDeallocation: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Tensorflow_MemoryLogRawDeallocation"}
  public var protoMessageName: String {return "MemoryLogRawDeallocation"}
  public var protoPackageName: String {return "tensorflow"}
  public var jsonFieldNames: [String: Int] {return [
    "stepId": 1,
    "operation": 2,
    "allocationId": 3,
    "allocatorName": 4,
    "deferred": 5,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "step_id": 1,
    "operation": 2,
    "allocation_id": 3,
    "allocator_name": 4,
    "deferred": 5,
  ]}

  ///   Process-unique step id.
  public var stepId: Int64 = 0

  ///   Name of the operation making the deallocation.
  public var operation: String = ""

  ///   Id of the tensor buffer being deallocated, used to match to a
  ///   corresponding allocation.
  public var allocationId: Int64 = 0

  ///   Name of the allocator used.
  public var allocatorName: String = ""

  ///   True if the deallocation is queued and will be performed later,
  ///   e.g. for GPU lazy freeing of buffers.
  public var deferred: Bool = false

  public init() {}

  public init(stepId: Int64? = nil,
    operation: String? = nil,
    allocationId: Int64? = nil,
    allocatorName: String? = nil,
    deferred: Bool? = nil)
  {
    if let v = stepId {
      self.stepId = v
    }
    if let v = operation {
      self.operation = v
    }
    if let v = allocationId {
      self.allocationId = v
    }
    if let v = allocatorName {
      self.allocatorName = v
    }
    if let v = deferred {
      self.deferred = v
    }
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeSingularField(fieldType: ProtobufInt64.self, value: &stepId)
    case 2: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &operation)
    case 3: handled = try setter.decodeSingularField(fieldType: ProtobufInt64.self, value: &allocationId)
    case 4: handled = try setter.decodeSingularField(fieldType: ProtobufString.self, value: &allocatorName)
    case 5: handled = try setter.decodeSingularField(fieldType: ProtobufBool.self, value: &deferred)
    default:
      handled = false
    }
    return handled
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if stepId != 0 {
      try visitor.visitSingularField(fieldType: ProtobufInt64.self, value: stepId, protoFieldNumber: 1, protoFieldName: "step_id", jsonFieldName: "stepId", swiftFieldName: "stepId")
    }
    if operation != "" {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: operation, protoFieldNumber: 2, protoFieldName: "operation", jsonFieldName: "operation", swiftFieldName: "operation")
    }
    if allocationId != 0 {
      try visitor.visitSingularField(fieldType: ProtobufInt64.self, value: allocationId, protoFieldNumber: 3, protoFieldName: "allocation_id", jsonFieldName: "allocationId", swiftFieldName: "allocationId")
    }
    if allocatorName != "" {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: allocatorName, protoFieldNumber: 4, protoFieldName: "allocator_name", jsonFieldName: "allocatorName", swiftFieldName: "allocatorName")
    }
    if deferred != false {
      try visitor.visitSingularField(fieldType: ProtobufBool.self, value: deferred, protoFieldNumber: 5, protoFieldName: "deferred", jsonFieldName: "deferred", swiftFieldName: "deferred")
    }
  }

  public var _protoc_generated_isEmpty: Bool {
    if stepId != 0 {return false}
    if operation != "" {return false}
    if allocationId != 0 {return false}
    if allocatorName != "" {return false}
    if deferred != false {return false}
    return true
  }

  public func _protoc_generated_isEqualTo(other: Tensorflow_MemoryLogRawDeallocation) -> Bool {
    if stepId != other.stepId {return false}
    if operation != other.operation {return false}
    if allocationId != other.allocationId {return false}
    if allocatorName != other.allocatorName {return false}
    if deferred != other.deferred {return false}
    return true
  }
}
